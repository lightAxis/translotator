{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"translotator","text":"<p>Lightweight C++ header-only template library for translation, rotation and homogeneous transformation. Requires C++17 or Later. No dependencies with other libraries and stl.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Translation, Rotation, Homogeneous Transformation</li> <li>Matrix based objects : Matrix N x M, SquareMatrix N x N, Vector N</li> <li>Number objects : Complex number, Quaternion, Dual number, Dual Quaternion</li> <li>Rotation objects : Unit Complex Number, Unit Quaternion, Axis Angle, Euler Angle, SO(2), SO(3)</li> <li>Transformation objects : SE(2), SE(3), UnitDualQuaternion</li> <li>Supports variaous types of data (float, double, long double)</li> <li>Many operator overloadings for object actions &amp; data type conversion</li> <li>Supports reinterpret_cast for zero-copy data type conversion between Matrix-based objects.(using this feature to convert temporary object is not recommended)</li> <li>Complile-time dimension check for matrix-based objects</li> <li>Basic Lie algebra &amp; operation supported : S1, S3, SO(2), SO(3), SE(2), SE(3). Exponential map, Logarithm map.</li> <li>Interpolation : Lerp, Slerp, ScLerp. Also Slerp x Lerp for SE(2), SE(3)</li> </ul>"},{"location":"#matrix-based-objects","title":"Matrix-based objects","text":"<p>These objects are based on Matrix form.</p> <ul> <li>Matrix (N x M)</li> <li>SquareMatrix (N x N)</li> <li>Vector (N x 1)</li> <li>ComplexNum(2 x 1)</li> <li>Quaternion(4 x 1)</li> <li>DualNumber(2 x 1)</li> <li>DualQuaternion(8 x 1)</li> <li>UnitComplexNum (2 x 1)</li> <li>UnitQuaternion (4 x 1)</li> <li>UnitDualQuaternion (8 x 1)</li> <li>Special Orthogonal Group SO(2), SO(3)</li> </ul> <p>Except SE(2), SE(3), EulerAngle, AxisAngle, all objects are based on Matrix form.</p> <p>Matrix-based objects has many operator overloadings between them.</p>"},{"location":"#1-copy-zero-copy-data-type-conversion","title":"1. Copy &amp; Zero-copy data type conversion","text":"<p>All matrix-based objects can be converted to each other by using cast function. There are two type of cast function, castContainer() and castContainerRef(). These functions are used for copy and zero-copy data type conversion respectively. Also only allowes the conversion between objects with same matrix-based dimension.</p> <p>castContainer() Returns new object with memory copy. Usually used for converting temporary object. Or when you want to keep the original object memory. Some cast functions perform extra steps like normalize, transpose, etc.</p> <p>All matrix dimension checks are performed at complile time. If the dimension is not matched, it will cause compile error.</p> <pre><code>Matrix&lt;3,3,float&gt; mat33;\nSquareMatrix&lt;3,float&gt; sqmat33_a = mat33.castContainer&lt;SquareMatrix&lt;3,float&gt;&gt;();\nSquareMAtrix&lt;3,float&gt; sqmat33_b = mat33.cast2SquareMatrix(); // alias\nMatrix&lt;3,1,float&gt; mat31;\nVector&lt;3, float&gt; v31_a = mat31.castContainer&lt;Vector&lt;3,float&gt;&gt;();\nVector&lt;3, float&gt; v31_b = mat31.cast2Vector(); // alias \n</code></pre> <p>some alias functions do extra steps</p> <pre><code>Quaternion&lt;float&gt; quat = Quaternion&lt;float&gt;{1.f, Vector&lt;3,float&gt;{{2.f, 3.f, 4.f}}};\n\n// cast the object type and normalize\nUnitQuaternion&lt;float&gt; uquat_a = quat.cast2UnitQuaternion(); \n\n// just cast the object type without normalization. \nUnitQuaternion&lt;float&gt;uquat_b = quat.castContainer&lt;UnitQuaternion&lt;float&gt;&gt;(); \n\n// usually cast2UnitQuaternion() is recommended.\n</code></pre> <p>castContainerRef() returns reinterpret_casted object. It is used for zero-copy data type conversion. This is recommended to use when you want to convert the object type without memory copy. Take extra care for temporary objects, can cause undefined behavior, the dangling reference.</p> <pre><code>Matrix&lt;3,3,float&gt; mat33{{1.f, 2.f, 3.f, \n                        3.f ,4.f, 5.f,\n                        5.f, 6.f, 7.f}};\n// zero-copy type conversion\nconst SquareMatrix&lt;3, float&gt;&amp; sqmat33_ref_a = mat33.castContainerRef&lt;SquareMatrix&lt;3,float&gt;&gt;();\n// alias\nSquareMatrix&lt;3,float&gt;&amp; sqmat33_ref_b = mat33.cast2SquareMatrixRef();\n\n// can only read from mat33(0,0), will be 1.f\nfloat val00 = sqmat33_ref_a(0,0); \n// mat33(0,0) also changed to 0.f\nsqmat33_ref_b(0,0) = 0.f;\n\n// reference of temporary object can lead to undefined behavior. \nSquareMatrix&lt;3, float&gt;&amp; sqmat33_doomed = (mat33 * mat33).cast2SquareMatrixRef();\nsqmat33_doomed(0,0) = 0.f; // undefined behavior\n</code></pre> <p>Some alias functions do extra steps, changing the data inside original object.</p> <pre><code>Quaternion&lt;float&gt; quat = Quaternion&lt;float&gt;{1.f, Vector&lt;3,float&gt;{{2.f, 3.f, 4.f}}};\n\n// cast the object type and normalize\nconst UnitQuaternion&lt;float&gt;&amp; uquat_ref_a = quat.cast2UnitQuaternionRef();\nfloat norm1 = uquat_ref_a.norm(); // 1.f\nfloat norm2 = quat.norm(); // 1.f , original object is also normalized\n</code></pre>"},{"location":"#2-operator-and-operator-","title":"2. operator+ and operator-","text":"<p>The operator+, operator- are defined only between same dimension objects. Return type of operator+ and operator- usually follows the left operand type. If operation result violates the property of left operand object, it will be converted to the superset object. (e.g. UnitComplexNum + ComplexNum -&gt; ComplexNum) (e.g. SO(3) + GL(3) =GL(3) )</p>"},{"location":"#3-operator-operator","title":"3. operator*, operator/*=","text":"<p>The operator* are basically defined only between proper matrix dimension objects. Return type of operator*follows the rules of matrix multiplication. If operation result has specific form, it will be converted to the subset object. (e.g. (2x4)*(4x3) = Matrix(2x3) ) (e.g. (2x3)*(3x2) = SquareMatrix(2x2) ) (e.g. (2x5)*(5x1) = Vector(2x1) ) (e.g. SO(3)* Scalar = SquareMatrix(3x3) )</p>"},{"location":"#4-operator-operator","title":"4. operator\\/, operator\\/=","text":"<p>The operator/ are defined only between some mathmatical inverse operation objects. (e.g. ComplexNum/ComplexNum = ComplexNum * ComplexNum.inverse() ) (e.g. SO(3) / SO(3) = SO(3) * SO(3)^T ) (e.g. SO(3) / Scalar = SquareMatrix(3x3) )</p>"},{"location":"#hierachy-of-all-objects","title":"Hierachy of All objects","text":""},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details</p>"},{"location":"#contact","title":"Contact","text":"<p>lightAxis - jisuk500@gmail.com</p>"},{"location":"axis_angle/","title":"Axis Angle","text":"<p>This class is used to represent rotation in 3D space using rotation axis and angle of rotation. The axis is a unit vector and the angle is in radian.</p>"},{"location":"axis_angle/#axis-angle-class","title":"Axis Angle Class","text":"<p>This class is not derived from MatrixBase. so most of the methods are implemented in the class itself.</p> <pre><code>// initialize \n// automatically normalize unit axis, angle, x, y, z\nAxisAngle&lt;float&gt; axisangle(1.0f, 2.0f, 3.0f, 4.0f);\nVectorf&lt;3&gt; vec3{{1.f, 2.f, 3.f}};\nAxisAngle&lt;float&gt; axisangle2(0.5f, vec3);\n\n// type alias\nAxisAnglef axisangle3 = axisangle;\n\n// accessors\nfloat angle = axisangle.angle();\nVectorf&lt;3&gt; axis = axisangle.axis();\n\naxisangle.angle() = angle;\naxisangle.axis() = axis;\n\n// normalize\naxisangle.axisNormalize();\n\n// rotate vector\nVectorf&lt;2&gt; vec2{{1.f, 2.f}};\nVectorf&lt;2&gt; vec2_rot = axisangle.rotateVector2D(vec2); // using only z angle\nVectorf&lt;3&gt; vec3_rot = axisangle.rotateVector3D(vec3);\n\n// get unit axis rotation\nAxisAnglef axisangle_rot_x = AxisAnglef::axisRotation&lt;AXIS::X&gt;(angle);\n\n// inverse\nAxisAnglef axisangle_inv = axisangle.inversed();\n\n// casting\nUnitQuaternionf quat = axisangle.toUnitQuaternion();\nUnitComplexNumf complex = axisangle.toUnitComplexNum(); // using only z angle\nSOGroupf&lt;2&gt; so2 = axisangle.toRotationMat2D(); // using only z angle\nSOGroupf&lt;3&gt; so3 = axisangle.toRotationMat3D();\nVectorf&lt;3&gt; anglevec = axisangle.toAngleVector();\nEulerAngleXYZf euler = axisangle.toEulerAngle&lt;EULER_ORDER::XYZ&gt;();\n\nAxisAngle&lt;double&gt; axisangle_d = axisangle.castDataType&lt;double&gt;();\n</code></pre>"},{"location":"complex_number/","title":"Complex Number","text":"<p>A complex number is a number that can be expressed in the form <code>a + bi</code>, where <code>a</code> and <code>b</code> are real numbers, and <code>i</code> is a solution of the equation <code>x^2 = -1</code>. Because no real number satisfies this equation, <code>i</code> is called an imaginary number. For the complex number <code>a + bi</code>, <code>a</code> is called the real part, and <code>b</code> is called the imaginary part. The set of complex numbers is denoted by \\(\\mathbb{C}\\).</p>"},{"location":"complex_number/#conjugate-norm","title":"Conjugate &amp; Norm","text":"<p>The norm of a complex number is defined as the square of the self with conjugated self. The conjugate of a complex number is the same as the original number, but the sign of the imaginary part is flipped.</p> \\[\\begin{align} z &amp;= a + bi, \\quad a, b \\in \\mathbb{R} \\quad z \\in \\mathbb{C}, i^2 = -1 \\\\ \\bar{z} &amp;= a - bi \\quad \\text{conjugate} \\\\ |z| &amp;= \\sqrt{a^2 + b^2} = \\sqrt{z \\bar{z}} \\quad \\text{norm} \\end{align}\\]"},{"location":"complex_number/#addition-subtraction","title":"Addition, Subtraction","text":"<p>Addition and subtraction of complex numbers are defined as follows:</p> \\[\\begin{align} z_1 &amp;= a_1 + b_1 i, \\quad z_2 = a_2 + b_2 i \\\\ z_1 + z_2 &amp;= (a_1 + a_2) + (b_1 + b_2) i \\\\ z_1 - z_2 &amp;= (a_1 - a_2) + (b_1 - b_2) i \\end{align}\\]"},{"location":"complex_number/#multiplication","title":"Multiplication","text":"<p>Multiplication of complex numbers is defined as follows:</p> \\[\\begin{align} z_1 &amp;= a_1 + b_1 i, \\quad z_2 = a_2 + b_2 i \\\\ z_1 z_2 &amp;= (a_1 a_2 - b_1 b_2) + (a_1 b_2 + a_2 b_1) i \\\\ &amp;= \\begin{bmatrix} a_1 a_2 - b_1 b_2 \\\\ a_1 b_2 + a_2 b_1 \\end{bmatrix} \\\\[10pt] &amp;= \\begin{bmatrix} a_1 &amp; -b_1 \\\\ b_1 &amp; a_1 \\end{bmatrix} \\begin{bmatrix} a_2 \\\\ b_2 \\end{bmatrix} \\\\[10pt] \\end{align}\\]"},{"location":"complex_number/#inverse-division","title":"Inverse &amp; Division","text":"<p>Division is defined as multiplication by the inverse of the divisor:</p> \\[\\begin{align} z &amp;= a+bi\\\\ z^{-1} &amp;= \\frac{1}{a+bi} \\\\ &amp;= \\frac{a-bi}{(a+bi)(a-bi)} \\quad \\text{multiply by conjugate} \\\\ &amp;= \\frac{a-bi}{a^2+b^2} \\\\ &amp;= \\frac{a}{a^2+b^2} - \\frac{b}{a^2+b^2}i \\\\ \\\\ z_1 / z_2 &amp;= z_1 z_2^{-1} \\end{align}\\]"},{"location":"complex_number/#complex-number-class","title":"Complex Number Class","text":"<pre><code>// initializer, 1+2i\nComlexNum&lt;float&gt; z1{1.f, 2.f}; // Re, Im\nComplexNum&lt;float&gt; z2{{1.f, 2.f}};\n\n// type alias\nComplexNumf z3 = z1\n\n// cast to other object (2 x 1)\nVectorf&lt;2&gt; vec21 = z1.cast2Vector();\nMatrixf&lt;2,1&gt; mat21 = z1.cast2Matrix();\nz1 = vec21.cast2ComplexNum();\n\n// accessor\nfloat re = z1.re();\nfloat im = z1.im();\nz1.Re() = re;\nz1.Im() = im;\n\n// conjugate\nComplexNumf z1_conj = z1.conjugated();\n\n// norm\nfloat norm = z1.norm();\nfloat normSq = z1.normSquared();\nComplexNumf z1_normed = z1.normalized();\n\n// inverse\nComplexNumf z1_inv = z1.inversed();\n\n// operators\nComplexNumf z3 = z1 + z2;\nComplexNumf z4 = z1 - z2;\nComplexNumf z5 = z1 * z2; // complex number multiplication\nComplexNumf z6 = z1 / z2; // z1 * z2.inversed()\n\n// result type casting\nVectorf&lt;2&gt; vec21 = SquareMatirxf&lt;2&gt;{} * z1; // matrix multiplication\n\n// to multiplication matrix\nSquareMatrixf&lt;2&gt; mat2 = z1.toMulMatrix();\n// | Re(), -Im() |\n// | Im(),  Re() |\n</code></pre>"},{"location":"dual_number/","title":"Dual Number","text":"<p>A dual number is a number of the form \\(a + b \\epsilon\\), where \\(a\\) and \\(b\\) are real numbers, and \\(\\epsilon\\) is a symbol that satisfies \\(\\epsilon^2 = 0\\). The dual number system is an extension of the real numbers that is useful for performing automatic differentiation. Sometimes related to homogeneous transformation in robotics.</p>"},{"location":"dual_number/#conjugate-norm","title":"Conjugate &amp; Norm","text":"<p>The norm of a dual number is defined as the square of the self with conjugated self. The conjugate of a dual number is the same as the original number.</p> \\[\\begin{align} d &amp;= a + b \\epsilon, \\quad a, b \\in \\mathbb{R} \\quad d \\in \\mathbb{D} \\\\ \\bar{d} &amp;= a - b \\epsilon \\quad \\text{dual conjugate} \\\\ |d| &amp;= \\sqrt{a^2} = \\lvert a \\rvert = \\sqrt{d \\bar{d}} \\quad \\text{norm} \\end{align}\\]"},{"location":"dual_number/#addition-subtraction","title":"Addition &amp; Subtraction","text":"<p>Dual number addition &amp; subtraction are defined as follows:</p> \\[\\begin{align} d_1 &amp;= a_1 + b_1 \\epsilon, \\quad d_2 = a_2 + b_2 \\epsilon \\\\ d_1 + d_2 &amp;= (a_1 + a_2) + (b_1 + b_2) \\epsilon \\\\ d_1 - d_2 &amp;= (a_1 - a_2) + (b_1 - b_2) \\epsilon \\end{align}\\]"},{"location":"dual_number/#multiplication","title":"Multiplication","text":"<p>Dual number multiplication is defined as follows:</p> \\[\\begin{align} d_1 &amp;= a_1 + b_1 \\epsilon, \\quad d_2 = a_2 + b_2 \\epsilon \\\\ d_1 d_2 &amp;= a_1 a_2 + a_1 b_2 \\epsilon + a_2 b_1 \\epsilon + b_1 b_2 \\epsilon^2 \\\\ &amp;= a_1 a_2 + (a_1 b_2 + a_2 b_1) \\epsilon \\\\ &amp;=\\begin{bmatrix} a_1 &amp; 0 \\\\ b_1 &amp; a_1 \\end{bmatrix} \\begin{bmatrix} a_2 \\\\ b_2 \\end{bmatrix} \\end{align}\\]"},{"location":"dual_number/#inverse-division","title":"Inverse &amp; Division","text":"<p>The inverse of a dual number is defined as the reciprocal of the dual number.</p> \\[\\begin{align} d^{-1} &amp;= \\frac{1}{d} = \\frac{1}{a + b \\epsilon} = \\frac{1}{a + b \\epsilon} \\frac{a - b \\epsilon}{a - b \\epsilon} \\\\ &amp;= \\frac{a - b \\epsilon}{a^2} = \\frac{a}{a^2} - \\frac{b}{a^2} \\epsilon \\end{align}\\] <p>Division is defined as the multiplication of the first number by the inverse of the second number.</p> \\[\\begin{align} d_1/d_2 &amp;= d_1 d_2^{-1} \\end{align}\\]"},{"location":"dual_number/#square-root","title":"Square Root","text":"<p>The square root of a dual number is defined as follows:</p> \\[\\begin{align} d &amp;= a + b \\epsilon \\\\ \\sqrt{d} &amp;= \\sqrt{a + b \\epsilon} = \\sqrt{a} + \\frac{b}{2\\sqrt{a}} \\epsilon \\\\ \\because \\left( \\sqrt{a} + \\frac{b}{2 \\sqrt{a}} \\epsilon \\right)^2 &amp;= a+b \\epsilon \\\\ \\end{align}\\]"},{"location":"dual_number/#dual-number-class","title":"Dual Number Class","text":"<pre><code>/// initializer\nDualNumber&lt;float&gt; d1{1.f, 2.f}; // Re, Du\nDualNumber&lt;float&gt; d2{{1.f, 2.f}};\n\n// type alias\nDualNumberf d3 = d1;\n\n// cast to other objects (2 x 1)\nVector2f v = d1.cast2Vector();\nMatrix2f m = d1.cast2Matrix();\n\n// accessor\nfloat re = d1.Re();\nfloat du = d1.Du();\nd1.Re() = re;\nd1.Du() = du;\n\n// conjugate, norm\nDualNumber&lt;float&gt; d4 = d1.conjugated();\nfloat norm = d1.norm();\n\n// inverse\nDualNumber&lt;float&gt; d5 = d1.inversed();\n\n// operators\nDualNumber&lt;float&gt; d6 = d1 + d2;\nDualNumber&lt;float&gt; d7 = d1 - d2;\nDualNumber&lt;float&gt; d8 = d1 * d2; // Dual number multiplication\nDualNumber&lt;float&gt; d9 = d1 / d2; // Dual number division\n\n// result type casting\nVector2f v = SquareMatrix2f{} * d1; // matrix multiplication\n\n// to multiplication matrix\nSquareMatrix2f m = d1.toMatrix();\n// | Re()  0   |  \n// | Du() Re() |\n</code></pre>"},{"location":"dual_quaternion/","title":"Dual Quaternion","text":"<p>A dual quaternion is a pair of quaternions, one for rotation and the other for translation. It is used to represent rigid transformations in 3D space. The dual quaternion is defined as</p> \\[\\begin{align} q_r + \\epsilon q_d &amp;\\in \\mathbb{DQ} \\\\ &amp;= (w_r + x_ri + y_rj + z_rk) + \\epsilon (w_d + x_di + y_dj + z_dk) \\end{align}\\] <p>where \\(q_r\\) is the real, \\(q_d\\) is the dual quaternion, and \\(\\epsilon\\) is the dual unit. The dual unit \\(\\epsilon\\) satisfies the following equation:</p> \\[\\begin{align} \\epsilon^2 = 0, \\quad \\epsilon \\neq 0 \\end{align}\\]"},{"location":"dual_quaternion/#conjugate-norm","title":"Conjugate &amp; Norm","text":"<p>There's three conjugate for dual quaternion. The primary conjugate, dual conjugate, and full conjugate.  </p> <p>I will use the Primary conjugate most of the time, with the notation \\(\\bar{d}\\). The dual conjugate is not used in robotics, and the full conjugate is used for the action of unit dual quaternion.</p>"},{"location":"dual_quaternion/#primary-conjugate","title":"Primary Conjugate","text":"<p>The primary conjugate of a dual quaternion is defined as the conjugate of each quaternion.</p> \\[\\begin{align} d &amp;= q_r + \\epsilon q_d \\\\ \\bar{d} &amp;= \\bar{q_r} + \\epsilon \\bar{q_d} \\\\ &amp;= (w_r - x_ri - y_rj - z_rk) + \\epsilon (w_d - x_di - y_dj - z_dk) \\end{align}\\] <p>The norm with the primary conjugate is defined as the square of the self with the primary conjugate.</p> \\[\\begin{align} |d| &amp;= \\sqrt{d \\bar{d}} \\\\ &amp;= \\sqrt{d_r \\bar{d_r} + \\epsilon (d_r \\bar{d_d} + d_d \\bar{d_r})} \\\\ &amp;= \\sqrt{\\lvert d_r \\rvert^2 + 2 \\epsilon (w_r w_d + x_r x_d + y_r y_d + z_r z_d)} \\\\ &amp;= \\sqrt{\\lvert d_r \\rvert^2 + 2 \\epsilon (\\vec{q_r} \\cdot \\vec{q_d})} \\quad \\text{sqrt of dual number} \\\\ &amp;= \\lvert q_r \\rvert + \\epsilon \\frac{\\vec{q_r} \\cdot \\vec{q_d}}{\\lvert q_r \\rvert} \\end{align}\\] <p>Unit Dual Quaternion is defined using this Conjugate and Norm</p>"},{"location":"dual_quaternion/#dual-conjugate","title":"Dual Conjugate","text":"<p>The dual conjugate of a dual quaternion is defined as the sign of the dual part flipped.</p> \\[\\begin{align} d &amp;= q_r + \\epsilon q_d \\\\ d^* &amp;= q_r - \\epsilon q_d \\end{align}\\] <p>This conjugate has no meaning in perspective of robotics.</p>"},{"location":"dual_quaternion/#full-conjugate","title":"Full Conjugate","text":"<p>The full conjugate of a dual quaternion is defined as the conjugate of each quaternion and the sign of the dual part flipped.</p> \\[\\begin{align} d &amp;= q_r + \\epsilon q_d \\\\ \\bar{d}^* &amp;= \\bar{q_r} - \\epsilon \\bar{q_d} \\\\ &amp;= (w_r - x_ri - y_rj - z_rk) - \\epsilon (w_d - x_di - y_dj - z_dk) \\end{align}\\] <p>This conjugate is used for action of unit dual quaternion just like SE(3) group.</p>"},{"location":"dual_quaternion/#addition-subtraction","title":"Addition &amp; Subtraction","text":"<p>Dual quaternion addition &amp; subtraction are defined as follows:</p> \\[\\begin{align} d_1 &amp;= q_{r1} + \\epsilon q_{d1}, \\quad d_2 = q_{r2} + \\epsilon q_{d2} \\\\ d_1 + d_2 &amp;= (q_{r1} + q_{r2}) + \\epsilon (q_{d1} + q_{d2}) \\\\ d_1 - d_2 &amp;= (q_{r1} - q_{r2}) + \\epsilon (q_{d1} - q_{d2}) \\end{align}\\]"},{"location":"dual_quaternion/#multiplication","title":"Multiplication","text":"<p>Dual quaternion multiplication is defined as follows:</p> \\[\\begin{align} d_1 &amp;= q_{r1} + \\epsilon q_{d1}, \\quad d_2 = q_{r2} + \\epsilon q_{d2} \\\\ d_1 d_2 &amp;= (q_{r1} q_{r2}) + \\epsilon (q_{r1} q_{d2} + q_{d1} q_{r2}) \\end{align}\\]"},{"location":"dual_quaternion/#inverse-division","title":"Inverse &amp; Division","text":"<p>The inverse of a dual quaternion is defined as the conjugate of the dual quaternion divided by the norm of the dual quaternion.</p> \\[\\begin{align} d^{-1} &amp;= \\frac{1}{d} = \\frac{\\bar{d}}{|d|^2} \\\\ &amp;= \\frac{\\bar{d}}{d \\bar{d}} \\\\ &amp;= \\frac{\\bar{d}}{\\lvert d_r \\rvert^2 + 2 \\epsilon (\\vec{q_r} \\cdot \\vec{q_d})} \\\\ &amp;= \\frac{\\bar{q_r} - \\epsilon \\bar{q_d}}{\\lvert q_r \\rvert^2 + 2 \\epsilon (\\vec{q_r} \\cdot \\vec{q_d})} \\\\ &amp;= \\frac{\\bar{q_r}}{\\lvert q_r \\rvert^2} + \\epsilon \\left( \\frac{\\bar{q_d}}{\\lvert q_r \\rvert^2} - 2 \\frac{(\\vec{q_r} \\cdot \\vec{q_d})}{\\lvert q_r \\rvert^4}q_r \\right) \\\\ \\end{align}\\] <p>Divison is defined as multiplication with the inverse.</p> \\[\\begin{align} d_1/d_2 &amp;= d_1 d_2^{-1} \\end{align}\\]"},{"location":"dual_quaternion/#dual-quaternion-class","title":"Dual Quaternion Class","text":"<pre><code>// initializer, (1+2i+3j+4k) + epsilon(5+6i+7j+8k)\nDualQuaternion&lt;float&gt; dq1{Quaternion&lt;float&gt;{1.f, 2.f, 3.f, 4.f},\n                          Quaternion&lt;float&gt;{5.f, 6.f, 7.f, 8.f}}; // Re, Du\nDualQuaternion&lt;float&gt; dq2{{1.f, 2.f, 3.f, 4.f, 5.f, 6.f, 7.f, 8.f}};\n\n// type alias\nDualQuaternionf dq3 = dq1;\n\n// access\nQuaternionf q_r = dq1.Re();\nQuaternionf q_d = dq1.Du();\ndq1.Re() = q_r;\ndq1.Du() = q_d;\n\nfloat r_w = dq1.rw();\nfloat r_x = dq1.rx();\nfloat r_y = dq1.ry();\nfloat r_z = dq1.rz();\nfloat d_w = dq1.dw();\nfloat d_x = dq1.dx();\nfloat d_y = dq1.dy();\nfloat d_z = dq1.dz();\ndq1.rw() = r_w;\ndq1.rx() = r_x;\ndq1.ry() = r_y;\ndq1.rz() = r_z;\ndq1.dw() = d_w;\ndq1.dx() = d_x;\ndq1.dy() = d_y;\ndq1.dz() = d_z;\n\n// cast to other object (8 x 1)\nVectorf&lt;8&gt; vec81 = dq1.cast2Vector();\nMatrixf&lt;8,1&gt; mat81 = dq1.cast2Matrix();\n\n// conjugates\nDualQuaternionf dq4 = dq1.conjugatedPrimary();\nDualQuaternionf dq5 = dq1.conjugatedDual();\nDualQuaternionf dq6 = dq1.conjugatedFull();\n\n// norm\nDualNumberf norm = dq1.normDualNum();\nDualNumberf norm2 = dq1.normDualNumSqared();\nfloat norm3 = dq1.normScalar();\nnorm3 = dq1.normDualNum().norm();\n\n// inverse\nDualQuaternionf dq7 = dq1.inversed(); // using Primary conjugate and Norm\n\n// operators\nDualQuaternionf dq8 = dq1 + dq2;\nDualQuaternionf dq9 = dq1 - dq2;\nDualQuaternionf dq10 = dq1 * dq2; // dual quaternion multiplication\nDualQuaternionf dq11 = dq1 / dq2; // dual quaternion division\n\n// result type casting\nVectorf&lt;8&gt; vec81 = SquareMatrixf&lt;8&gt;{} * dq1; // matrix multiplication\n\n// to multiplication matrix\nSquareMatrixf&lt;8&gt; mat8 = dq1.toMulMatrix();\n</code></pre>"},{"location":"euler_angle/","title":"Euler Angle","text":"<p>Euler angle representation is a set of three angles that represent the orientation of a rigid body in 3D space. The three angles are usually denoted as \\(\\phi\\), \\(\\theta\\), and \\(\\psi\\).</p> <p>This library provides a class 'EulerAngle' to represent Euler angles. The class provides methods to convert Euler angles to other representations like rotation matrix, quaternion, etc.</p> <p>Using intrinsic rotations, Vector rotation(active rotation), and Tait-Bryan angles. If the order is ZYX, it means that the rotation is first around the Z-axis, then around the Y-axis, and finally around the X-axis.</p> <p>Check out the Wikipedia page for more information.</p>"},{"location":"euler_angle/#euler-angle-class","title":"Euler Angle Class","text":"<p>This class is not derived from MatrixBase. so most of the methods are implemented in the class itself.</p> <pre><code>// initialize \n// by x,y,z angles\nEulerAngle&lt;float, EULER_ORDER::XYZ&gt; euler1{0.1f, 0.2f, 0.3f};\nEulerAngle&lt;float, EULER_ORDER::ZYX&gt; euler2{0.1f, 0.2f, 0.3f};\n\n// by vector3\nVectorf&lt;3&gt; vec3{{0.1f, 0.2f, 0.3f}}; // x,y,z angles in radian\nEulerAngle&lt;float, EULER_ORDER::XYZ&gt; euler3{vec3};\n\n\n// type alias\nEulerAnglef&lt;EULER_ORDER::ZYX&gt; euler4 = euler2;\nEulerAngleXYZ&lt;float&gt; euler5 = euler1;\nEulerAngleZYXf euler6 = euler2;\n\n// accessors\nfloat x_angle = euler1.x();\nfloat y_angle = euler1.y();\nfloat z_angle = euler1.z();\neuler.x() = 0.1f;\neuler.y() = 0.2f;\neuler.z() = 0.3f;\n\nx_angle = euler1[0];\ny_angle = euler1[1];\nz_angle = euler1[2];\neuler[0] = x_angle;\neuler[1] = y_angle;\neuler[2] = z_angle;\n\nx_angle = euler1.roll();\ny_angle = euler1.pitch();\nz_angle = euler1.yaw();\neuler1.roll() = 0.1f;\neuler1.pitch() = 0.2f;\neuler1.yaw() = 0.3f;\n\nz_angle = euler1.getAngleInOrder&lt;2&gt;(); // XYZ, 3rd angle = z_angle\nx_angle = euler2.getAngleInOrder&lt;2&gt;(); // ZYX, 3rd angle = x_angle\n\nAXIS z_axis = euler1.getAxisInOrder&lt;2&gt;(); // XYZ, 3rd axis = Z\nAXIS x_axis = euler2.getAxisInOrder&lt;2&gt;(); // ZYX, 3rd axis = X\n\n// rotation vector\nVectorf&lt;2&gt; vec2{{1.f, 2.f}};\nVectorf&lt;3&gt; vec3{{1.f, 2.f, 3.f}};\n\nVectorf&lt;2&gt; vec2_rot = euler1.rotateVector2D(vec2); // using only z angle\nVectorf&lt;3&gt; vec3_rot = euler2.rotateVector3D(vec3);\n\n// axis rotation \nEulerAngle&lt;EULER_ORDER::ZYX&gt; euler_rot_x = EulerAngle&lt;EULER_ORDER::ZYX&gt;::axisRotation&lt;AXIS::X&gt;(0.1f);\n\n// rotation representation conversion\neuler1.toUnitQuaternion()\neuler1.toUnitComplexNum() // using only z angle\neuler1.toAxisAngle()\neuler1.toSO3Group()\neuler1.toSO2Group() // using only z angle\neuler1.toVector() // x_angle, y_angle, z_angle\n\n// casting\nEulerAngle&lt;EULER_ORDER::ZYX&gt; zyx = euler1.castAxisOrder&lt;EULER_ORDER::ZYX&gt;();\nEulerAngleXYZ&lt;double&gt; xyz_d = euler1.castDataType&lt;double&gt;();\n</code></pre>"},{"location":"matrix_based_objects/","title":"Matrix Based Objects","text":"<p>There are many objects in this library. And many of them are based on the matrix structure.</p> <p>These are the matrix-based objects in this library.</p> <ul> <li>Matrix (N x M) <li>SquareMatriu (N x N) <li>Vector (N x 1) <li>ComplexNum (2 x 1) <li>Quaternion (4 x 1) <li>DualNumber (2 x 1) <li>DualQuaternion (8 x 1) <li>SOGroup (N x N) <li>UnitComplexNum (2 x 1) <li>UnitQuaternion (4 x 1) <li>UnitDualQuaternion (8 x 1) <p>These are not matrix-based objects, but they are also available in this library. Manual conversion is available between these objects and matrix-based objects.</p> <ul> <li>EulerAngle <li>AxisAngle <li>SEGroup"},{"location":"matrix_based_objects/#automatic-return-type-deduction-by-dimension-lhs","title":"Automatic Return Type Deduction by Dimension &amp; lhs","text":"<p>There are many matrix-based objects in this library. Every time you create a matrix-based object, you don't need to specify the data type and optimized container every time. To avoid the casting overhead and make the code more readable, the library automatically deduces the data type and optimized container by the dimension and lhs.</p> <p>There's some examples below.</p> <ul> <li>Matrix (N x M)</li> <li>SquareMatrix (N x N)</li> <li>Vector (N x 1)</li> <li>Scalar</li> </ul> <p>Every result type and dimension and return types are deduced at compile time.  </p>"},{"location":"matrix_based_objects/#operator-","title":"operator +,-","text":"<p>If the lhs and rhs have the same dimension, the return type is the same as the lhs type.  </p> <pre><code>// same dimension\nMatrix&lt;2,3,float&gt; m23;\nMatrix&lt;2,3,float&gt; m23_res = m23 + m23;\n\n// same but different type, following the lhs type\nVector&lt;3,float&gt; v31;\nMatrix&lt;3,1,float&gt; m31;\nVector&lt;3,float&gt; v31_res = v31 + m31;\nMatrix&lt;3,1,float&gt; m31_res = m31 + v31;\n\n// different dimension, following the lhs type. \nQuaternion&lt;float&gt; q;\nVector&lt;4,float&gt; v41;\nQuaternion&lt;float&gt; q_res = q + v41;\nVector&lt;4,float&gt; v41_res = v41 + q;\n\n// some objects those are constrainted type (e.g. UnitQuaternion) can be different\nUnitQuaternion&lt;float&gt; uq;\nVector&lt;4,float&gt; v41_res2 = uq + v41;\n</code></pre>"},{"location":"matrix_based_objects/#operator","title":"operator *, /","text":"<p>If the result dimension is 1x1, return type is scalar.  </p> <pre><code>float scalar1 = Matrix&lt;1,3,float&gt;{} * Matrix&lt;3,1,float&gt;{};\nfloat scalar2 = Matrix&lt;1,3,float&gt;{} * Vector&lt;3, float&gt;{};\n</code></pre> <p>If the result dimension is Nx1, return type is vector.  </p> <pre><code>Vector&lt;3,float&gt; vec1 = Matrix&lt;3,2,float&gt;{} * Matrix&lt;2,1,float&gt;{};\nVector&lt;3,float&gt; vec2 = Vector&lt;3,float&gt; * 10.f;\n</code></pre> <p>If the result dimension is NxN, return type is square matrix.  </p> <pre><code>Matrix&lt;3,2,float&gt; m32;\nVector&lt;2,float&gt; v21;\nMatrix&lt;1,3,float&gt; m13;\n\nSquareMatrix&lt;3,float&gt; sq33 = m32 * v21 * m13 / 10.f;\n</code></pre> <p>If the result dimension is NxM, return type is matrix.  </p> <pre><code>Matrix&lt;3,3,float&gt; m33;\nVector&lt;3,float&gt; v31;\nMatrix&lt;1,2,float&gt; m12;\n\nMatrix&lt;3,2,float&gt; m34 = sq32 * v31 * m12 * 10.f;\n</code></pre> <p>If the lhs is special constrainted type (e.g. UnitQuaternion), the return type can be different. If the operation does not preserves the constraint of the lhs, the return type is deduced as the next most general type.</p> <p>If the lhs is mathmatically closed to the operation, the return type is deduced as the lhs type.</p> <p>Or, some case like UnitQuaternion, operator* is Quaternion Multiplication, not Matrix Multiplication. So, the return type is deduced as Quaternion.</p> <p>These objects are closed to multiplication operation. So, unique multiplication rules can be applied to these operator* between objects.</p> <ul> <li>UnitComplexNum</li> <li>UnitQuaternion</li> <li>UnitDualQuaternion</li> <li>SOGroup</li> <li>SEGroup</li> </ul> <pre><code>UnitComplexNum&lt;float&gt; uc;\nComplexNum&lt;float&gt; c;\n\n// unit * unit = unit (closed to multiplication)\nUnitComplexNum&lt;float&gt; uc2 = uc * uc; \n// complex * unit = complex\nComplexNum&lt;float&gt; c2 = c * uc; \n// unit * scalar = complex\nComplexNum&lt;float&gt; c4 = uc * 1.f; \n\n// unit(2x1) * matrix(1x2) = square(2x2)\nSquareMatrix&lt;2,float&gt; sq22 = uc * Matrix&lt;1,2,float&gt;{};\n</code></pre>"},{"location":"matrix_based_objects/#object-type-conversion-between-matrix-based-objects","title":"Object Type Conversion between Matrix Based Objects","text":"<p>There are many matrix-based objects in this library. Every object has a conversion function to convert to another object. Of course, the conversion is defined between the same dimension objects.</p> <p>There are two versions of conversion functions. One is <code>castContainer&lt;ContainerType&gt;()</code> ant the other is <code>castContainerRef&lt;Type&gt;()</code>.  </p>"},{"location":"matrix_based_objects/#conversion-with-memory-copy","title":"Conversion with Memory Copy","text":"<p><code>castContainer&lt;ContainerType&gt;()</code> returns a new object with the specified container type. New instance is created and the data is copied. This is highly recommended most of the time.</p> <pre><code>Matrix&lt;4,1,float&gt; m41;\nVector&lt;4,float&gt; v41 = m41.castContainer&lt;Vector&lt;4,float&gt;&gt;();\nMatrix&lt;4,1,float&gt; m41_ = v41.castContainer&lt;Matrix&lt;4,float&gt;&gt;();\n</code></pre> <p>There's an alias functions for <code>castContainer&lt;ContainerType&gt;()</code>. function <code>cast2[ContainerType]()</code> is available for each object, automatically deduceing the result type &amp; dimensions at complie time.</p> <pre><code>Matrix&lt;4,1,float&gt; m41;\nVector&lt;4,float&gt; v41 = m41.cast2Vector();\nMatrix&lt;4,1,float&gt; m41_ = v41.cast2Matrix();\nMatrix&lt;4,4,float&gt; m44 = (m41 * m41.T()).cast2SquareMatrix();\n</code></pre> <p>Some functions are available for specific type of Dimension.  </p> <pre><code>Vector&lt;2,float&gt; v21\nComplexNum&lt;float&gt; c = v21.cast2ComplexNum();\nDualNumber&lt;float&gt; d = v21.cast2DualNumber();\n\nVector&lt;4,float&gt; v41;\nQuaternion&lt;float&gt; q = v41.cast2Quaternion();\n\nVector&lt;8,float&gt; v81;\nDualQuaternion&lt;float&gt; dq = v81.cast2DualQuaternion();\n</code></pre> <p>Some functions are conducting normalization during the conversion.</p> <pre><code>Matrix&lt;2,1,float&gt; m21;\n// automatically normalized\nUnitComplexNum&lt;float&gt; uc = m21.cast2UnitComplexNum();\n\nVector&lt;4,float&gt; v41;\n// automatically normalized\nUnitQuaternion&lt;float&gt; uq = v41.cast2UnitQuaternion();\n\nDualQuaternion&lt;float&gt; dq;\n// automatically normalized\nUnitDualQuaternion&lt;float&gt; udq = dq.cast2UnitDualQuaternion();\n\nSquareMatrix&lt;3,float&gt; sq33;\n// automatically normalized\nSOGroup&lt;3,float&gt; so3 = sq33.cast2SOGroup();\n</code></pre>"},{"location":"matrix_based_objects/#conversion-with-reference-zero-copy","title":"Conversion with Reference (Zero-Copy)","text":"<p><code>castContainerRef&lt;ContainerType&gt;()</code> returns a reference of current object with the specified container type. Instance is not created and the data is not copied. This function uses reinterpret_cast to convert the data type. I carefully designed the data structures of matrix-based objects to have the same memory layout for same dimension objects.  </p> <p>However This conversion is not recommended for temporary instances because it can cause dangling reference.</p> <p>Use this method only when :</p> <ul> <li>If you want to use the same data with different data types</li> <li>Save memory or avoid memory copy overhead.</li> <li>When Original object is not destroyed until the reference is destroyed.</li> </ul> <pre><code>Matrix&lt;4,1,float&gt; m41;\nVector&lt;4,float&gt; &amp;v41 = m41.castContainerRef&lt;Vec tor&lt;4,float&gt;&gt;();\nMatrix&lt;4,1,float&gt; &amp;m41_ = v41.castContainerRef&lt;Matrix&lt;4,float&gt;&gt;();\n</code></pre> <p>There's an alias functions for <code>castContainerRef&lt;ContainerType&gt;()</code>.</p> <pre><code>Matrix&lt;4,1,float&gt; m41;\nVector&lt;4,float&gt; &amp;v41 = m41.cast2VectorRef();\nMatrix&lt;4,1,float&gt; &amp;m41_ = v41.cast2MatrixRef();\n// Not Recommended for temporary instances\n// This will cause dangling reference\nMatrix&lt;4,4,float&gt; &amp;m44 = (m41 * m41.T()).cast2SquareMatrixRef();\n// const Reference can expand the lifetime of the temporary object, (C++17)\n// but still not recommended to use.\nconst Matrix&lt;4,4,float&gt; &amp;m44_constRef = (m41 * m41.T()).cast2SquareMatrixRef();\n</code></pre> <p>Some functions are available for specific type of Dimension.  </p> <pre><code>Vector&lt;2,float&gt; v21\nComplexNum&lt;float&gt; &amp;c = v21.cast2ComplexNumRef();\nDualNumber&lt;float&gt; &amp;d = v21.cast2DualNumberRef();\n\nVector&lt;4,float&gt; v41;\nQuaternion&lt;float&gt; &amp;q = v41.cast2QuaternionRef();\n</code></pre> <p>Some functions are conducting normalization during the conversion.</p> <pre><code>Matrix&lt;2,1,float&gt; m21;\n// automatically normalized\n// This will normalize the original object too.\nUnitComplexNum&lt;float&gt; &amp;uc = m21.cast2UnitComplexNumRef();\n\nVector&lt;4,float&gt; v41;\n// automatically normalized\n// This will normalize the original object too.\nUnitQuaternion&lt;float&gt; &amp;uq = v41.cast2UnitQuaternionRef();\n</code></pre>"},{"location":"matrix_vector/","title":"Matrix","text":"<p>Matrix is a two-dimensional array of numbers. It is a fundamental mathematical concept that is used in many fields such as physics, computer graphics, and machine learning. In this article, we will discuss the basics of matrices, matrix operations, and their applications.</p> <p>Many operations can be performed on matrices, such as addition, subtraction, multiplication, sometimes division.</p>"},{"location":"matrix_vector/#matrix-class","title":"Matrix Class","text":"<p>Basically, I denote row dimension as \\(N\\), col dimension as \\(M\\). All Matrices are represented in the Matrix class. <p>Almost every methods and functions in Matrix Class are implemented to other matrix-based objects, such as Vector, SquareMatrix, etc. For example, if you want to cast data type of a matrix-based object, you can use <code>castType&lt;Type&gt;()</code> method</p>"},{"location":"matrix_vector/#matrix-template","title":"Matrix Template","text":"<pre><code>// Matrix&lt;N,M,Type&gt;\nconstexpr size_t RowSize = 3;\nconstexpr size_t ColSize = 4;\nusing DataType = float; // float, double, long double is available\nMatrix&lt;RowSize,ColSize,DataType&gt; mat;\n</code></pre>"},{"location":"matrix_vector/#matrix-datatype-casting","title":"Matrix DataType Casting","text":"<pre><code>Matrix&lt;3,4,float&gt; m34f;\nMatrix&lt;3,4,double&gt; m34d = m32f.castType&lt;double&gt;();\nMatrix&lt;3,4,long double&gt; m34ld = m32f.castContainer&lt;Matrix&lt;3,4,long double&gt;&gt;();\n\n// Matrixf&lt;N,M&gt; is an alias of Matrix&lt;N,M,float&gt;\nMatrixf&lt;3,4&gt; m34f_alias = m34f;\n// Matrixd&lt;N,M&gt; is an alias of Matrix&lt;N,M,double&gt;\nMatrixd&lt;3,4&gt; m34d_alias = m34d;\n// Matrixld&lt;N,M&gt; is an alias of Matrix&lt;N,M,long double&gt;\nMatrixld&lt;3,4&gt; m34ld_alias = m34ld;\n</code></pre>"},{"location":"matrix_vector/#initialize-with-initializer_list","title":"Initialize with initializer_list","text":"<pre><code>Matrix&lt;3,4,float&gt; M34{{11.f, 12.f, 13.f, 14.f,\n                       21.f, 22.f, 23.f, 24.f,\n                       31.f, 32.f, 33.f, 34.f}};\n\nMatrix&lt;3,2,float&gt; M32{{1.f, 2.f, 3.f, 4.f, 5.f, 6.f}};\n</code></pre> \\[\\begin{align} \\text{M34} &amp;= \\begin{bmatrix} 11 &amp; 12 &amp; 13 &amp; 14 \\\\ 21 &amp; 22 &amp; 23 &amp; 24 \\\\ 31 &amp; 32 &amp; 33 &amp; 34 \\end{bmatrix} \\\\[10pt] \\text{M32} &amp;= \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\end{bmatrix} \\end{align}\\] <pre><code>// *** Indexing ***\nMatrix&lt;3, 4, float&gt; M34{{11.f, 12.f, 13.f, 14.f,\n                         21.f, 22.f, 23.f, 24.f,\n                         31.f, 32.f, 33.f, 34.f}};\n\n// get element\nfloat e23 = M34(1, 2); // 23.f\n// set element\nM34(1, 2) = 100.f; // 23.f -&gt; 100.f\n\n// get row\nMatrix&lt;1, 4, float&gt; r2 = M34.row(1); // start from idx 0, 2nd row is idx 1\n// set row\nM34.setRow(0, r2); // first row\n\n// get col\nMatrix&lt;3, 1, float&gt; c2 = M34.col(1); // start from idx 0, 1 is 2nd col\n// set col\nM34.setCol(0, c2); // first col\n\n// get block\nMatrix&lt;2, 3, float&gt; b = M34.block&lt;2, 3&gt;(0, 1); // shape : 2x3, start from 0, 1\n// set block\nM34.setBlock(1, 0, b); // start from 1, 0\n\n// get block with fixed size, compiler will deduce and check the size for you\nb = M34.block&lt;0, 1, 2, 3&gt;(); // shape : 2x3, start from 0, 1\n// set block with size, compiler will deduce and check the size for you\nM34.setBlock&lt;0, 1&gt;(b);\n</code></pre>"},{"location":"matrix_vector/#matrix-operations","title":"Matrix Operations","text":"<pre><code>// with matrices\nMatrix&lt;3, 4, float&gt; M34;\nMatrix&lt;2, 3, float&gt; M23;\nMatrix&lt;2, 4, float&gt; M24;\n\nMatrix&lt;2, 4, float&gt; M24_Res = M23 * M34 + M24;\n\n// with scalar\nfloat a;\nMatrix&lt;3, 4, float&gt; M34_Res = a * M34;\n\n// other operators, such as +, -, /, +=, -=, *=, /= are also available if the size is matched\n</code></pre> \\[\\begin{align} M_{24, Res} &amp;= M_{23} \\times M_{34} + M_{24} \\\\[10pt] M_{34, Res} &amp;= a M_{34} \\end{align}\\]"},{"location":"matrix_vector/#matrix-utils","title":"Matrix Utils","text":"<pre><code>// transpose\nMatrix&lt;4, 3, float&gt; M43 = M34.transpose();\n\n// fill\nM34.fill(1.f);\n\n// print\nM34.print();\n\n// swap rows &amp; cols\nM34.swapRows(0, 1);\nM34.swapCols(0, 1);\n\n// frobeniusNorm\nfloat norm = M34.frobeniusNorm();\n\n// to scalar. If the matrix is 1x1, it can be casted to scalar\nfloat scalar = M34.toScalar();\n</code></pre>"},{"location":"matrix_vector/#square-matrix-class","title":"Square Matrix Class","text":"<p>If \\(N=M\\), the matrix is called a square matrix \\(N\\) . This instance can be casted to SquareMatrix class, or vice versa. <p>This is a matrix-based object. So, all methods in Matrix class are also available too.</p> <pre><code>SquareMatrix&lt;3, float&gt; sq33{{1.f, 2.f, 3.f,\n                             4.f, 5.f, 6.f,\n                             7.f, 8.f, 9.f}};\n\n// cast to Matrix\nMatrix&lt;3,3,float&gt; m33 = sq33.castContainer&lt;Matrix&lt;3,3,float&gt;&gt;();\n// vice versa\nSquareMatrix&lt;3,float&gt; sq33_casted = m33.castContainer&lt;SquareMatrix&lt;3,float&gt;&gt;();\n\n// cast to matrix by alias\nMatrixf&lt;3,3&gt; m33_alias = sq33.cast2Matrix();\nSquareMatrixf&lt;3&gt; sq33_alias = m33_alias.cast2SquareMatrix();\n\n// cast to matrix with reference. zero-copy\n// This is not recommended for temporary instances because it can cause dangling reference\n// Use this method when :\n// 1. If you want to use the same data with different data types\n// 2. Save memory or avoid memory copy overhead.\n// 3. When Original object is not destroyed until the reference is destroyed.\nMatrixf&lt;3,3&gt; m33_ref = sq33.castContainerRef&lt;Matrixf&lt;3,3&gt;&gt;();\n// vice versa\nSquareMatrixf&lt;3&gt; sq33_ref = m33_ref.castContainerRef&lt;SquareMatrixf&lt;3&gt;&gt;();\n\n// by alias\nMatrixf&lt;3,3&gt; m33_ref_alias = sq33.cast2MatrixRef();\nSquareMatrixf&lt;3&gt; sq33_ref_alias = m33_ref_alias.cast2SquareMatrixRef();\n</code></pre>"},{"location":"matrix_vector/#square-matrix-special-methods","title":"Square Matrix Special Methods","text":"<pre><code>// determinant\n// only implemented for 2x2, 3x3\nfloat det = sq33.determinant();\n\n// inverse\n// fast closed-form solution for 1x1, 2x2, 3x3.\n// Otherwise, use LU decomposition\nSquareMatrix&lt;3, float&gt; inv = sq33.inverse();\n\n// trace\nfloat trace = sq33.trace();\n</code></pre>"},{"location":"matrix_vector/#vector-class","title":"Vector Class","text":"<p>if \\(M=1\\), the matrix is called a vector. This instance can be casted to <code>Vector&lt;N,Type&gt;</code> class, or vice versa.</p> <p>This is a matrix-based object. So, all methods in Matrix class are also available too.</p> <pre><code>Vector&lt;3, float&gt; vec3{{1.f, 2.f, 3.f}};\n// cast to Matrix\nMatrix&lt;3,1,float&gt; m31 = vec3.castContainer&lt;Matrix&lt;3,1,float&gt;&gt;();\n// vice versa\nVector&lt;3,float&gt; vec3_casted = m31.castContainer&lt;Vector&lt;3,float&gt;&gt;();\n\n// cast to matrix by alias\nMatrixf&lt;3,1&gt; m31_alias = vec3.cast2Matrix();\nVectorf&lt;3&gt; vec3_alias = m31_alias.cast2Vector();\n</code></pre>"},{"location":"matrix_vector/#vector-special-methods","title":"Vector Special Methods","text":"<pre><code>/// norm\nVector&lt;3, float&gt; vec3{{1.f, 2.f, 3.f}};\nfloat norm = vec3.norm();\n\n/// dot product\nVector&lt;3, float&gt; vec3_2{{4.f, 5.f, 6.f}};\nfloat dot = vec3.dot(vec3_2);\n\n/// cross product\nVector&lt;3, float&gt; cross = vec3.cross(vec3_2);\n\n// to cross product matrix\nSquareMatrix&lt;3,3,float&gt; crossMat = vec3.toCrossMatrix();\n\n// to diagonal matrix\nSquareMatrix&lt;3,float&gt; diagMat = vec3.toDiagonalMatrix();\n\n// accessors\nfloat x = vec3.x();\nfloat y = vec3.y();\nfloat z = vec3.z();\n\n// set\nvec3.x() = x;\nvec3.y() = y;\nvec3.z() = z;\n\n// array like access\nfloat x = vec3[0];\nfloat y = vec3[1];\nfloat z = vec3[2];\n\n// array like set\nvec3[0] = x;\nvec3[1] = y;\nvec3[2] = z;\n\n// element axis\nVector&lt;3, float&gt; xAxis = vec3.xAxis();\nVector&lt;3, float&gt; yAxis = vec3.yAxis();\nVector&lt;3, float&gt; zAxis = vec3.zAxis();\n</code></pre>"},{"location":"quaternion/","title":"Quaternion","text":"<p>A quaternion is a number that can be expressed in the form <code>a + bi + cj + dk</code>, where <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are real numbers, and <code>i</code>, <code>j</code>, and <code>k</code> are imaginary units that satisfy the following equations:</p> \\[\\begin{align} i^2 = j^2 = k^2 = ijk = -1 \\end{align}\\] <p>The set of quaternions is denoted by \\(\\mathbb{H}\\). The quaternion is a non-commutative number system, which means that the order of multiplication matters just like matricies.</p> <p>Quaternion has a real part and three imaginary parts. Sometimes the imaginary parts are represented as a vector.  </p>"},{"location":"quaternion/#conjugate-norm","title":"Conjugate &amp; Norm","text":"<p>The norm of a quaternion is defined as the square of the self with conjugated self. The conjugate of a quaternion is the same as the original number, but the sign of the imaginary part is flipped.</p> \\[\\begin{align} q &amp;= w + xi + yj + zk, \\quad w, x, y, z \\in \\mathbb{R} \\quad q \\in \\mathbb{H} \\\\ &amp;= w + \\mathbf{v} \\quad \\text{where} \\quad \\mathbf{v} = xi + yj + zk \\\\ \\bar{q} &amp;= w - xi - yj - zk \\quad \\text{conjugate} \\\\ |q| &amp;= \\sqrt{w^2 + x^2 + y^2 + z^2} = \\sqrt{q \\bar{q}} \\quad \\text{norm} \\end{align}\\]"},{"location":"quaternion/#addition-subtraction","title":"Addition &amp; Subtraction","text":"<p>Quaternion addition &amp; subtraction are defined as follows:</p> \\[\\begin{align} q_1 &amp;= w_1 + \\mathbf{v}_1, \\quad q_2 = w_2 + \\mathbf{v}_2 \\\\ q_1 + q_2 &amp;= (w_1 + w_2) + (\\mathbf{v}_1 + \\mathbf{v}_2) \\\\ q_1 - q_2 &amp;= (w_1 - w_2) + (\\mathbf{v}_1 - \\mathbf{v}_2) \\end{align}\\]"},{"location":"quaternion/#multiplication","title":"Multiplication","text":"<p>Quaternion addition &amp; subtraction are the same as complex numbers. Quaternion multiplication is defined as follows:</p> \\[\\begin{align} q_1 &amp;= w_1 + \\mathbf{v}_1, \\quad q_2 = w_2 + \\mathbf{v}_2 \\\\ q_1 q_2 &amp;= (w_1 w_2 - \\mathbf{v}_1 \\cdot \\mathbf{v}_2) + (w_1 \\mathbf{v}_2 + w_2 \\mathbf{v}_1 + \\mathbf{v}_1 \\times \\mathbf{v}_2) \\end{align}\\] <p>In matrix form, the multiplication can be represented as follows:</p> \\[\\begin{align} q_1 &amp;= w_1 + \\mathbf{v}_1, \\quad q_2 = w_2 + \\mathbf{v}_2 \\\\[10pt] q_1 q_2 &amp;= \\begin{bmatrix} w_1 w_2 - \\mathbf{v}_1 \\cdot \\mathbf{v}_2 \\\\ w_1 \\mathbf{v}_2 + w_2 \\mathbf{v}_1 + \\mathbf{v}_1 \\times \\mathbf{v}_2 \\end{bmatrix} \\\\[10pt] &amp; = \\begin{bmatrix} w_1 &amp; -\\mathbf{v}_1^T \\\\ \\mathbf{v}_1 &amp; w_1 I + [\\mathbf{v}_1]_{\\times} \\end{bmatrix} \\begin{bmatrix} w_2 \\\\ \\mathbf{v}_2 \\end{bmatrix} \\\\[10pt] &amp;= \\begin{bmatrix} w_1 &amp; -x_1 &amp; -y_1 &amp; -z_1 \\\\ x_1 &amp; w_1 &amp; -z_1 &amp; y_1 \\\\ y_1 &amp; z_1 &amp; w_1 &amp; -x_1 \\\\ z_1 &amp; -y_1 &amp; x_1 &amp; w_1 \\end{bmatrix} \\begin{bmatrix}w_2 \\\\ x_2 \\\\ y_2 \\\\ z_2 \\end{bmatrix} \\\\[10pt] [\\mathbf{v}]_{\\times} &amp;= \\begin{bmatrix} 0 &amp; -v_z &amp; v_y \\\\ v_z &amp; 0 &amp; -v_x \\\\ -v_y &amp; v_x &amp; 0 \\end{bmatrix} \\quad \\text{cross product matrix} \\end{align}\\]"},{"location":"quaternion/#inverse-division","title":"Inverse &amp; Division","text":"<p>The inverse of a quaternion is defined as the conjugate of the quaternion divided by the norm of the quaternion.</p> \\[\\begin{align} q^{-1} &amp;= \\frac{1}{q} = \\frac{\\bar{q}}{q \\bar{q}}\\\\ &amp;= \\frac{\\bar{q}}{|q|^2} = \\frac{w - xi - yj - zk}{w^2 + x^2 + y^2 + z^2}\\\\ q_1/q_2 &amp;= q_1 q_2^{-1} \\end{align}\\]"},{"location":"quaternion/#quaternion-class","title":"Quaternion Class","text":"<pre><code>// initializer, 1+2i+3j+4k\nQuaternion&lt;float&gt; q1{1.f, 2.f, 3.f, 4.f}; // Re, i, j, k\nQuaternion&lt;float&gt; q2{{1.f, 2.f, 3.f, 4.f}};\nQuaternion&lt;float&gt; q3{1.f, Vectorf&lt;3&gt;{{2.f, 3.f, 4.f}}}; // Re, Im(Vec3)\n\n// type alias\nQuaternionf q4 = q1;\n\n// cast to other object (4 x 1)\nVectorf&lt;4&gt; vec41 = q1.cast2Vector();\nMatrixf&lt;4,1&gt; mat41 = q1.cast2Matrix();\nq1 = vec41.cast2Quaternion();\n\n// accessor\nfloat re = q1.Re();\nVectorf&lt;3&gt; im = q1.Im();\nq1.Re() = re;\nq1.Im() = im;\n\nfloat w = q1.w();\nfloat x = q1.x();\nfloat y = q1.y();\nfloat z = q1.z();\nq1.W() = w;\nq1.X() = x;\nq1.Y() = y;\nq1.Z() = z;\n\n// conjugate, norm\nQuaternionf q5 = q1.conjugated();\nfloat norm = q1.norm();\n\n// inverse\nQuaternionf q6 = q1.inversed();\n\n// operators\nQuaternionf q7 = q1 + q2;\nQuaternionf q8 = q1 - q2;\nQuaternionf q9 = q1 * q2; // quaternion multiplication\nQuaternionf q10 = q1 / q2; // quaternion division\n\n// result type casting\nVectorf&lt;4&gt; vec41 = SquareMatrixf&lt;4&gt;{} * q1; // matrix multiplication\n\n// to multiplication matrix\nSquareMatrixf&lt;4&gt; mat4 = q1.toMulMatrix();\n// | w,     -V^T    |\n// | v,  wI + [V]_x |\n</code></pre>"},{"location":"se_group/","title":"SE Group","text":"<p>SE(2) and SE(3) groups are used to represent rigid body transformations in 2D and 3D respectively. They are used in many applications in robotics and computer vision.</p>"},{"location":"se_group/#group-properties","title":"Group Properties","text":"<p>Definition of the SE(n) is the set of all \\((n+1) \\times (n+1)\\) matrices of the form:</p> \\[\\begin{align} SE(n) &amp;= \\{ T \\in \\mathbb{R}^{(n+1) \\times (n+1)} \\mid T = \\begin{bmatrix} R &amp; t \\\\ 0 &amp; 1 \\end{bmatrix}, R \\in SO(n), t \\in \\mathbb{R}^n \\} \\end{align}\\] <p>where \\(R\\) is a rotation matrix, \\(t\\) is a translation vector, and \\(0\\) is a zero vector.</p> <p>SE(2) and SE(3) are special Euclidean group in 2D and 3D space respectively. The SE(2) group is a group of 2D rigid body transformations in the plane. The SE(3) group is a group of 3D rigid body transformations in space.</p> <p>Compositions of two rigid body transformations is equivalent to multiplication of two matrices. The composition of two rigid body transformations \\(T_1\\) and \\(T_2\\) is defined as:</p> \\[\\begin{align} T_1 \\circ T_2 &amp;= T_1 T_2 \\end{align}\\]"},{"location":"se_group/#identity-inverse","title":"Identity &amp; Inverse","text":"<p>Identity is the identity matrix. The inverse of a rigid body transformation matrix is the inverse of the rotation matrix and the negative of the rotated translation vector. The inverse of a rigid body transformation matrix \\(T\\) is defined as:</p> \\[\\begin{align} T^{-1} &amp;= \\begin{bmatrix} R^T &amp; -R^T t \\\\ 0 &amp; 1 \\end{bmatrix} \\end{align}\\]"},{"location":"se_group/#exponential","title":"Exponential","text":"<p>The rigid body transformation matrix can be represented in exponential form. The exponential form of a rigid body transformation matrix is defined as:</p> \\[\\begin{align} T &amp;= \\exp{\\begin{bmatrix}[\\theta \\vec{u}]_{\\times} &amp; v \\\\ 0  &amp; 0\\end{bmatrix}} \\\\ \\end{align}\\] <p>where \\([\\theta \\vec{u}]_{\\times}\\) is the skew-symmetric matrix representing the rotation axis. \\(\\theta\\) is rotation angle, and \\(\\vec{u}\\) is the unit vector representing the rotation axis. \\(v\\) is the translation vector, but not an real translation vector. It is a vector that represents the translation in the direction of the rotation axis, screw motion.</p> <p>In case of 2D rigid body transformation, this can be simplified to:</p> \\[\\begin{align} T &amp;= \\exp{\\begin{bmatrix} 0 &amp; -\\theta &amp; v_x \\\\ \\theta &amp; 0 &amp; v_y \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}} \\\\ &amp;= \\begin{bmatrix} R &amp; Jv \\\\ 0  &amp; 1\\end{bmatrix} \\\\ \\end{align}\\] <p>Where \\(R\\) is rotation matrix in 2D,  \\(Jv\\) is the translation vector in 2D.</p> \\[\\begin{align} R &amp;= \\begin{bmatrix} \\cos{\\theta} &amp; -\\sin{\\theta} \\\\ \\sin{\\theta} &amp; \\cos{\\theta} \\end{bmatrix} \\\\ J &amp;= \\frac{1}{\\theta}\\begin{bmatrix} \\sin{\\theta} &amp; -(1-\\cos{\\theta}) \\\\ 1 - \\cos{\\theta} &amp; \\sin{\\theta} \\end{bmatrix}, if \\theta \\neq 0 \\\\ J &amp; = I, if \\theta = 0 \\end{align}\\] <p>In case of 3D rigid body transformation, this can be simplified to:</p> \\[\\begin{align} T &amp;= \\exp{\\begin{bmatrix} 0 &amp; -\\theta u_z &amp; \\theta u_y &amp; v_x \\\\ \\theta u_z &amp; 0 &amp; -\\theta u_x &amp; v_y \\\\ -\\theta u_y &amp; \\theta u_x &amp; 0 &amp; v_z \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix}} \\\\ &amp;= \\begin{bmatrix} R &amp; Jv \\\\ 0  &amp; 1\\end{bmatrix} \\\\ \\end{align}\\] <p>Where \\(R\\) is rotation matrix in 3D,  \\(Jv\\) is the translation vector in 3D.</p> \\[\\begin{align} R &amp;= \\exp([\\theta \\vec{u}]_{\\times}) \\\\ &amp;= I + \\sin{\\theta}[\\vec{u}]_{\\times} + [1-\\cos{\\theta}](\\vec{u})_{\\times}^2 \\\\ J &amp;= I + \\frac{1-\\cos{\\theta}}{\\theta}[\\vec{u}]_{\\times} + \\frac{\\theta - \\sin{\\theta}}{\\theta}[\\vec{u}]_{\\times}^2, if \\theta \\neq 0 \\\\ J &amp; = I, if \\theta = 0 \\end{align}\\]"},{"location":"se_group/#logarithmic","title":"Logarithmic","text":"<p>The logarithm of a rigid body transformation matrix is defined as:</p> \\[\\begin{align} \\log(T) &amp;= \\begin{bmatrix} \\theta[\\vec{u}]_{\\times} &amp; v \\\\ 0 &amp; 0 \\end{bmatrix} \\\\ \\end{align}\\] <p>where \\(\\theta\\) is the angle of rotation. \\(\\vec{u}\\) is the unit vector representing the rotation axis. \\(v\\) is the translation vector, but not an real translation vector. It is a vector that represents the translation in the direction of the rotation axis, screw motion.</p> <p>In case of 2D rigid body transformation, this can be simplified to:</p> \\[\\begin{align} \\log(T)=\\log{\\begin{bmatrix}R &amp; t \\\\ 0 &amp; 1\\end{bmatrix}} &amp;= \\begin{bmatrix} 0 &amp; -\\theta &amp; v_x \\\\ \\theta &amp; 0 &amp; v_y \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix} = \\begin{bmatrix} [\\theta]_{\\times} &amp; v \\\\ 0 &amp; 0\\end{bmatrix} \\\\ \\end{align}\\] <p>Where \\(R\\) is rotation matrix in 2D,  \\(v\\) is the translation vector in screw motion.</p> \\[\\begin{align} R &amp;= \\begin{bmatrix} \\cos{\\theta} &amp; -\\sin{\\theta} \\\\ \\sin{\\theta} &amp; \\cos{\\theta} \\end{bmatrix} \\\\ v &amp;= J^{-1}t \\\\ J &amp;= \\frac{\\theta}{2(1-\\cos{\\theta})}\\begin{bmatrix}\\sin{\\theta} &amp; 1-\\cos{\\theta} \\\\ -(1-\\cos{\\theta}) &amp; \\sin{\\theta}\\end{bmatrix}, if \\theta \\neq 0 \\\\ J &amp; = I, if \\theta = 0 \\end{align}\\] <p>In case of 3D rigid body transformation, this can be simplified to:</p> \\[\\begin{align} \\log(T)=\\log{\\begin{bmatrix}R &amp; t \\\\ 0 &amp; 1\\end{bmatrix}} &amp;= \\begin{bmatrix} 0 &amp; -\\theta u_z &amp; \\theta u_y &amp; v_x \\\\ \\theta u_z &amp; 0 &amp; -\\theta u_x &amp; v_y \\\\ -\\theta u_y &amp; \\theta u_x &amp; 0 &amp; v_z \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix} = \\begin{bmatrix}[\\theta \\vec{u}]_{\\times} &amp; v \\\\ 0 &amp; 0\\end{bmatrix} \\\\ \\end{align}\\] <p>Where \\(R\\) is rotation matrix in 3D,  \\(v\\) is the translation vector in screw motion.</p> \\[\\begin{align} R &amp;= \\exp([\\theta \\vec{u}]_{\\times}) \\\\ \\theta &amp;= \\cos^{-1} \\left( \\frac{\\text{trace}(R) - 1}{2} \\right) \\\\ [\\vec{u}]_{\\times} &amp;= \\frac{1}{2 \\sin{\\theta}}(R-R^T) \\\\[10pt] v &amp;= J^{-1}t \\\\ J^{-1} &amp;= I - \\frac{\\theta}{2}[\\vec{u}]_{\\times} + \\left( 1 - \\frac{\\theta \\sin{\\theta}}{2(1-\\cos{\\theta})} \\right)[\\vec{u}]_{\\times}^2 , if \\theta \\neq 0 \\\\ J^{-1} &amp;= I, if \\theta = 0 \\end{align}\\]"},{"location":"se_group/#power","title":"Power","text":"<p>The power of a rigid body transformation matrix is defined as:</p> \\[\\begin{align} T^n &amp;= \\exp(n \\log{T}) \\\\ &amp;= \\exp(n \\begin{bmatrix} \\theta[\\vec{u}]_{\\times} &amp; v \\\\ 0 &amp; 0 \\end{bmatrix}) \\\\ &amp;= \\exp(n \\begin{bmatrix} [\\theta]_{\\times} &amp; v \\\\ 0 &amp; 0 \\end{bmatrix}) \\end{align}\\]"},{"location":"se_group/#action-on-vector","title":"Action on Vector","text":"<p>The action of a rigid body transformation matrix on a 2D or 3D vector is defined as:</p> \\[\\begin{align} \\begin{bmatrix}\\mathbf{v}' \\\\ 1\\end{bmatrix} &amp;= \\begin{bmatrix} R &amp; t \\\\ 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix}\\mathbf{v} \\\\ 1\\end{bmatrix} \\\\ &amp;= \\begin{bmatrix} R\\mathbf{v} + t \\\\ 1 \\end{bmatrix} \\end{align}\\] <p>where \\(\\vec{v}'\\) is the transformed vector.</p>"},{"location":"se_group/#normalization","title":"Normalization","text":"<p>Just normalize the rotation matrix \\(R\\) to get the rotation matrix in SO(n) group. Translation vector \\(t\\) is not normalized.</p> <p>Other structure like unit dual quaternion can be used to represent the rigid body transformation, and the normalization can affect both the rotation and translation.</p>"},{"location":"se_group/#se-group-class","title":"SE Group Class","text":"<p>This is not a matrix-based object, but a composition of two objects. The SO group object is used to represent the rotation matrix, and the Vector object is used to represent the translation vector.</p> <p>I manually overload the operators to perform the operations on the SE group object as full operation with matirx form is not effiecient. Every operation has to do unneccessary matrix multiplication, like multiplication with 1s and 0s if we use matrix form.</p> <pre><code>// initialize\nSOGroup&lt;2,float&gt; so2{};\nVector&lt;2,float&gt; vec2{};\nSEGroup&lt;2,float&gt; se2{so2, vec2};\n\nSOGroup&lt;3,float&gt; so3{};\nVector&lt;3,float&gt; vec3{};\nSEGroup&lt;3,float&gt; se3{so3, vec3};\n\nSquareMatrix&lt;3,float&gt; mat33{{0, -1, 11,\n                             1,  0, 12,\n                             0,  0, 1}};\nSEGroup&lt;2, float&gt; se2_from_mat{mat33};\n\n// type alias\nSEGroupf&lt;2&gt; se2f = se2;\nSE3Groupf se3ff = se3;\n\n// accessors\nSOGroup&lt;2,float&gt; so2 = se2.rotation();\nse2.rotation() = so2;\nVector&lt;2,float&gt; vec2 = se2.translation();\nse2.translation() = vec2;\n\n// operators\n// no operator overloading except for multiplication &amp; division\n// if you want to do action on vector, or get matrix form, use the methods below\nSEGroup&lt;2,float&gt; se2_1 = se2 * se2; // se2 * se2 = se2\nSEGroup&lt;3,float&gt; se3_1 = se3 * se3; // se3 * se3 = se3\n\nSEGroup&lt;2,float&gt; se2_2 = se2 / se2; // se2 / se2 = se2.inverse()\n\n// inversed\nSEGroup&lt;3,float&gt; se3_2 = se3.inversed();\n\n// action on vector\nVectorf&lt;3&gt; vec3_ac = se3.actOnVector(Vectorf&lt;3&gt;{{1.f, 2.f, 3.f}});\n\n// get matrix form\nSquareMatrixf&lt;4&gt; mat44 = se3.toSquareMatrix();\n</code></pre>"},{"location":"so_group/","title":"SO(2) &amp; SO(3) Group","text":"<p>The SO(2) group is a group of 2D rotations in the plane and SO(3) group is a group of 3D rotations in space.</p>"},{"location":"so_group/#group-properties","title":"Group Properties","text":"<p>Definition of the SO(n) is the set of all \\(n \\times n\\) orthogonal matrices with determinant 1. The SO(n) group is a group of rotations in n-dimensional space. The group is defined as:</p> \\[\\begin{align} SO(n) &amp;= \\{ R \\in \\mathbb{R}^{n \\times n} \\mid R^T R = I, \\det(R) = 1 \\} \\end{align}\\] <p>where \\(R^T\\) is the transpose of the matrix, \\(I\\) is the identity matrix, and \\(\\det(R)\\) is the determinant of the matrix.</p> <p>\\(SO(2), SO(3)\\) is special orthogonal group in 2D and 3D space respectively. The SO(2) group is a group of 2D rotations in the plane. The SO(3) group is a group of 3D rotations in space.</p> <p>Compositions of two rotations is equivalent to multiplication of two matrices. The composition of two rotations \\(R_1\\) and \\(R_2\\) is defined as:</p> \\[\\begin{align} R_1 \\circ R_2 &amp;= R_1 R_2 \\end{align}\\]"},{"location":"so_group/#identity-inverse","title":"Identity &amp; Inverse","text":"<p>Identity is the identity matrix. The inverse of a rotation matrix is the transpose of the matrix. The transpose of a matrix is defined as:</p> \\[\\begin{align} R^{-1} &amp;= R^T \\end{align}\\]"},{"location":"so_group/#exponential","title":"Exponential","text":"<p>The rotation matrix can be represented in exponential form. The exponential form of a rotation matrix is defined as:</p> \\[\\begin{align} R &amp;= \\exp([\\theta \\vec{u}]_{\\times}) \\\\ &amp;= \\exp{\\begin{bmatrix} 0 &amp; -\\theta u_z &amp; \\theta u_y \\\\ \\theta u_z &amp; 0 &amp; -\\theta u_x \\\\ -\\theta u_y &amp; \\theta u_x &amp; 0 \\end{bmatrix}} \\\\ &amp;= I + [\\theta \\vec{u}]_{\\times} + \\frac{[\\theta \\vec{u}]_{\\times}^2}{2!} + \\frac{[\\theta \\vec{u}]_{\\times}^3}{3!} + \\ldots\\\\ &amp;= I + \\sin{\\theta} [\\vec{u}]_{\\times} + (1 - \\cos{\\theta}) [\\vec{u}]_{\\times}^2 \\end{align}\\] <p>where \\([\\theta]_{\\times}\\) is the skew-symmetric matrix representing the rotation axis. \\(\\theta\\) is rotation angle, and \\(\\vec{u}\\) is the unit vector representing the rotation axis.</p> <p>In case of 2D rotation, this can be simplified to:</p> \\[\\begin{align} R &amp;= \\begin{bmatrix} \\cos{\\theta} &amp; -\\sin{\\theta} \\\\ \\sin{\\theta} &amp; \\cos{\\theta} \\end{bmatrix} \\end{align}\\]"},{"location":"so_group/#logarithmic","title":"Logarithmic","text":"<p>The logarithm of a rotation matrix is defined as:</p> \\[\\begin{align} \\log(R) &amp;= \\theta[\\vec{u}]_{\\times}\\\\ \\theta &amp;= \\cos^{-1} \\left( \\frac{\\text{trace}(R) - 1}{2} \\right) \\\\ [\\vec{u}]_{\\times} &amp;= \\frac{1}{2 \\sin{\\theta}}(R-R^T) \\\\ &amp;= \\frac{1}{2 \\sin{\\theta}} \\begin{bmatrix} R_{32} - R_{23} \\\\ R_{13} - R_{31} \\\\ R_{21} - R_{12} \\end{bmatrix} \\end{align}\\] <p>where \\(\\theta\\) is the angle of rotation. \\(\\vec{u}\\) is the unit vector representing the rotation axis.</p> <p>In case of 2D rotation, this can be simplified to:</p> \\[\\begin{align} \\log(R) &amp;= \\begin{bmatrix} 0 &amp; -\\theta \\\\ \\theta &amp; 0 \\end{bmatrix} \\end{align}\\]"},{"location":"so_group/#power","title":"Power","text":"<p>The power of a rotation matrix is defined as:</p> \\[\\begin{align} R^n &amp;= \\exp(n \\theta [\\vec{u}]_{\\times}) \\\\ &amp;= \\exp(n \\log{R}) \\end{align}\\]"},{"location":"so_group/#action-on-vector","title":"Action on Vector","text":"<p>The action of a rotation matrix on a 2D or 3D vector is defined as:</p> \\[\\begin{align} \\vec{v}' &amp;= R \\vec{v} \\end{align}\\] <p>where \\(\\vec{v}'\\) is the rotated vector around the axis \\(\\vec{u}\\) by angle \\(\\theta\\).</p> <p>In case of 2D rotation, this can be simplified to:</p> \\[\\begin{align} \\begin{bmatrix} x' \\\\ y' \\end{bmatrix} &amp;= \\begin{bmatrix} \\cos{\\theta} &amp; -\\sin{\\theta} \\\\ \\sin{\\theta} &amp; \\cos{\\theta} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\end{align}\\]"},{"location":"so_group/#normalization","title":"Normalization","text":"<p>The rotation matrix should be normalized to ensure that it is a valid rotation matrix. The mathmatically propery way to normalize a rotation matrix is to use the SVD decomposition, finding a new orthogonal matrix that minimizes the difference between the original matrix and the new one :</p> \\[\\begin{align} \\min_{\\hat{R}}{\\lVert R -\\hat{R} \\rVert_F^2} \\\\ s.t. \\quad \\hat{R} \\in SO(n) \\end{align}\\] <p>But in practice, most of the time it is not that far from the orthogonal matrix. So, I implemented a simpler normalization. Just convert to Unit Quaternion, and convert back to rotation matrix.</p> <p>This is not a mathmatically proper way, but it is good enough for most of the cases. Also much faster than SVD decomposition :</p> <pre><code>/**\n * @brief Get the orthogonalized matrix\n * @return SOGroup&lt;N, Type&gt;\n * @note This function uses UnitComplexNum &amp; UnitQuternion internally.\n * Not a mathmatically correct way, but it works pretty good.\n */\ninline SOGroup&lt;N, Type&gt; normalized() const\n{\n    if constexpr (N == 2)\n    {\n        return this-&gt;toUnitComplexNum().toRotMatrix2D();\n    }\n    else if constexpr (N == 3)\n    {\n        return this-&gt;toUnitQuaternion().toRotMatrix3D();\n    }\n    else\n    {\n        static_assert(N == 2 || N == 3, \"Supports only SO(2) &amp; SO(3) Groups\");\n        return SOGroup&lt;N, Type&gt;();\n    }\n}\n</code></pre>"},{"location":"so_group/#so-group-class","title":"SO Group Class","text":"<p>Based on MatrixBase &amp; SquareMatrix class. All functions from base classes are available. Below are additional functions.</p> <pre><code>// initinialize\nSOGroup&lt;2, float&gt; R2d(0.5f); // 2D rotation by 0.5 radian\nSOGroup&lt;3, float&gt; R3d(0.5f, 0.0f, 0.0f); // 3D rotation by 0.5 radian around x-axis\n\n// (Force initialization with norm constraint vialoation)\nSOGroup&lt;2, float&gt; R2d(0.5f, 0.0f,\n                      0.0f, 0.0f); // forced, not recommended\nSOGroup&lt;3, float&gt; R3d(0.5f, 0.0f, 1.0f,\n                      0.0f, 0.7f, 0.0f,\n                      0.0f, 0.2f, 0.9f); // fored, not recommended\n\n// initialize from other form\n// automatically normalized\nSquareMatrix&lt;2, float&gt; R2_sq{{0.5f, -0.5f},\n                             {0.5f, 0.5f}};\nSOGroup&lt;2, float&gt; so2 = R2_sq.cast2SOGroup(); // normalized\nMatrix&lt;3,3,float&gt; Mat33{{0.5f, -0.5f, 0.0f},\n                         {0.5f, 0.5f, 0.0f},\n                         {0.0f, 0.0f, 1.0f}};\nSOGroup&lt;3, float&gt; so3 = Mat33.cast2SOGroup(); // normalized\n\n// type alias\nSOGroupf&lt;2&gt; so2f = so2;\nSO2Group&lt;float&gt; so2ff = so2;\nSO2Groupf = so2fff = so2;\nRotationMatrixf&lt;2&gt; so2ffff = so2;\nRotationMatrix2D&lt;float&gt; so2fffff = so2;\nRotationMatrix2Df so2ffffff = so2;\n\n// accessors\n// same with SquareMatrix class\n\n// normalize\nSOGroupf&lt;2&gt; so2_norm = so2.normalized();\n\n// axis rotations\n// rotatation around specific axis\nSOGroupf&lt;3&gt; so3_x = SOGroupf&lt;3&gt;::axisRotation&lt;AXIS::X&gt;(0.1f);\nSOGroupf&lt;3&gt; so3_y = SOGroupf&lt;3&gt;::axisRotation&lt;AXIS::Y&gt;(0.2f);\nSOGroupf&lt;3&gt; so3_z = SOGroupf&lt;3&gt;::axisRotation&lt;AXIS::Z&gt;(0.3f);\n\n// operators\nSOGroupf&lt;2&gt; R2d_inv = R2d.inverse(); // internally calls transpose()\n\nSOGroupf&lt;3&gt; so3_1 = R3d * R3d; // SO(3) Composition\nSquareMatrixf&lt;3&gt; mat3 = R3d * R3d.cast2SquareMatrix(); // Matrix multiplication\n// no division implemented. Use inverse() instead.\n\nSquareMatrixf&lt;3&gt; mat33 = R3d + R3d; // Matrix addition\nSquareMatrixf&lt;3&gt; mat333 = R3d - R3d; // Matrix subtraction\n\n// rotation (action on 3D vector)\nVectorf&lt;3&gt; vec3{{1.f, 2.f, 3.f}};\nVectorf&lt;3&gt; vec3_rot = so3 * vec3;\n\n// identity\nSOGroupf&lt;3&gt; so3_id = SOGroupf&lt;3&gt;::identity();\n\n// rotation representation conversion\nso2.toUnitComplexNum();\nso3.toUnitComplexNum() // use 2x2 only\nso3.toUnitQuaternion();\nso3.toAxisAngle();\nso3.toEulerAngle&lt;EULER_ORDER::ZYX&gt;(); // changing euler angle order\n</code></pre>"},{"location":"unit_complex_number/","title":"Unit Complex Number","text":"<p>A unit complex number is a complex number that has a magnitude of 1. It is used to represent a rotation in 2D space. The unit complex number is defined as:</p> \\[\\begin{align} z &amp;= a + bi \\\\ &amp;= \\cos(\\theta) + i \\sin(\\theta) \\end{align}\\] <p>where \\(a\\) is the real part, \\(b\\) is the imaginary part, and \\(\\theta\\) is the angle of rotation.</p>"},{"location":"unit_complex_number/#inverse-by-conjugate","title":"Inverse by Conjugate","text":"<p>The inverse of a unit complex number is the conjugate of the complex number. The conjugate of a complex number is defined as:</p> \\[\\begin{align} z^{-1} = \\bar{z} &amp;= a - bi \\end{align}\\]"},{"location":"unit_complex_number/#s1-group","title":"S1 Group","text":"<p>The unit complex number forms a group called the S1 group. The S1 group is a group of unit complex numbers that form a circle in the complex plane. The group is defined as:</p> \\[\\begin{align} S^1 &amp;= \\{ z \\in \\mathbb{C} \\mid |z| = 1 \\} \\end{align}\\] <p>where \\(|z|\\) is the magnitude of the complex number.</p> <p>Composition of two unit complex numbers is equivalent to multiplication of two complex numbers. The composition of two unit complex numbers \\(z_1\\) and \\(z_2\\) is defined as:</p> \\[\\begin{align} z_1 \\circ z_2 &amp;= z_1 z_2 \\end{align}\\] <p>Identity is 1, and the inverse of a unit complex number is the conjugate of the complex number.</p>"},{"location":"unit_complex_number/#exponential-form","title":"Exponential Form","text":"<p>The unit complex number can be represented in exponential form. The exponential form of a unit complex number is defined as:</p> \\[\\begin{align} z &amp;= \\cos(\\theta) + i \\sin(\\theta) \\\\ &amp;= e^{i \\theta} \\end{align}\\] <p>where \\(e\\) is the base of the natural logarithm.</p>"},{"location":"unit_complex_number/#logarithmic-form","title":"Logarithmic Form","text":"<p>The logarithm of a unit complex number is defined as:</p> \\[\\begin{align} \\log(z) &amp;= i \\angle(z) \\end{align}\\] <p>where \\(\\angle(z)\\) is the angle of the complex number.</p>"},{"location":"unit_complex_number/#power","title":"Power","text":"<p>The power of a unit complex number is defined as:</p> \\[\\begin{align} z^n &amp;= \\cos(n \\theta) + i \\sin(n \\theta) \\\\ &amp;= \\exp{(n \\log{z})} \\end{align}\\] <p>where \\(n\\) is the power of the complex number.</p>"},{"location":"unit_complex_number/#action-on-2d-vector","title":"Action on 2D Vector","text":"<p>The unit complex number can be used to rotate a 2D vector. The action of a unit complex number on a 2D vector is defined as:</p> \\[\\begin{align} v' &amp;= zv \\\\ &amp;= (\\cos{\\theta} + i\\sin{\\theta})(x + yi) \\\\ &amp;= \\begin{bmatrix} \\cos{\\theta} &amp; -\\sin{\\theta} \\\\ \\sin{\\theta} &amp; \\cos{\\theta} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\end{align}\\] <p>where \\(v\\) is the 2D vector, and \\(v'\\) is the rotated vector.</p>"},{"location":"unit_complex_number/#unit-complex-number-class","title":"Unit Complex Number Class","text":"<p>Based on MatrixBase &amp; ComplexNum class. All functions from base classes are available. Below are additional functions.</p> <pre><code>// initialize\nUnitComplexNum&lt;float&gt; z1(1.f, 0); // z = 1 + 0i\n// (Force initialization with norm constraint vialoation)\nUnitComplexNum&lt;float&gt; z2(1.f, 1.f); // z = 1 + 1i,\n\n// initialize from other form\n// automatically normalized\nVectorf&lt;2&gt; vec2{1.f, 1.f};\nUnitComplexNum&lt;float&gt; z3 = vec2.cast2UnitComplexNum();\nComplexNum z4{1.f, 1.f};\nUnitComplexNum&lt;float&gt; z5 = z4.cast2UnitComplexNum();\n\n// type alias\nUnitComplexNumf z1 = z;\n\n// accessors\nfloat re = z1.Re();\nfloat im = z1.Im();\nz1.Re() = re;\nz1.Im() = im;\n\n// redirected inverse function\nUnitComplexNumf z_inv = z1.inversed(); // internally calls conjugated()\nz_inv = z1.conjugated();\n\n// operators\nUnitComplexNumf z6 = z1 * z2; // z1 * z2 (S1 composition)\nComplexNumf z7 = z1 * z2.cast2ComplexNum(); // z1 * z4 (complex number multiplication)\nUnitComplexNumf z8 = z1 / z2; // z1 * z4.conjugated() (S1 division)\nComplexNumf z9 = z1 / z2.cast2ComplexNum(); // z1 * z4.inversed() (complex number division)\n\nComplexNumf z10 = z1 + z2; // complex number addition\nComplexNumf z11 = z1 - z2; // complex number subtraction\n\n// rotation (action on 2D vector)\nVectorf&lt;2&gt; vec2{1.f, 0.f};\nVectorf&lt;2&gt; vec2_rotated = z1.rotateVector2D(vec2);\n\n// identity\nUnitComplexNumf z12 = UnitComplexNumf::identity();\n\n// rotation representation conversion\nSOGroup&lt;2, float&gt; rotationMat2D = z1.toRotMatrix2D();\nAxisAngle&lt;float&gt; axis_angle = z2.toAxisAngle();\nEulerAngle&lt;float, EULER_ORDER::ZYX&gt; euler_angle =\n                z3.toEulerAngle&lt;EULER_ORDER::ZYX&gt;();\n</code></pre>"},{"location":"unit_quaternion/","title":"Unit Quaternion","text":"<p>A unit quaternion is a quaternion with a magnitude of 1. Unit quaternions are used to represent rotations in 3D space. They are often used in computer graphics, robotics, and other fields where rotations are commonly used.</p> <p>A unit quaternion is defined as:</p> \\[\\begin{align} q &amp;= w + xi + yj + zk \\\\ &amp;= \\cos(\\theta/2) + \\sin(\\theta/2)(xi + yj + zk) \\end{align}\\] <p>where \\(w\\) is the real part, \\(x\\), \\(y\\), and \\(z\\) are the imaginary parts with norm 1(\\(x^2 + y^2 + z^2 = 1\\)) which is rotation axis, and \\(\\theta\\) is the angle of rotation.</p> <p>Also represent with unit vector :</p> \\[\\begin{align} q &amp;= \\cos(\\theta/2) + \\sin(\\theta/2) \\mathbf{u} \\end{align}\\] <p>where \\(\\mathbf{u}\\) is unit vector representing the rotation axis. \\(\\theta\\) is the angle of rotation.</p>"},{"location":"unit_quaternion/#inverse-by-conjugate","title":"Inverse by Conjugate","text":"<p>The inverse of a unit quaternion is the conjugate of the quaternion. The conjugate of a quaternion is defined as:</p> \\[\\begin{align} q^{-1} = \\bar{q} &amp;= w - xi - yj - zk \\end{align}\\]"},{"location":"unit_quaternion/#s3-group","title":"S3 Group","text":"<p>The unit quaternion forms a group called the S3 group. The S3 group is a group of unit quaternions that form a 3-sphere in 4D space. The group is defined as:</p> \\[\\begin{align} S^3 &amp;= \\{ q \\in \\mathbb{H} \\mid |q| = 1 \\} \\end{align}\\] <p>where \\(|q|\\) is the magnitude of the quaternion.</p> <p>Composition of two unit quaternions is equivalent to multiplication of two quaternions. The composition of two unit quaternions \\(q_1\\) and \\(q_2\\) is defined as:</p> \\[\\begin{align} q_1 \\circ q_2 &amp;= q_1 q_2 \\end{align}\\] <p>Identity is 1, and the inverse of a unit quaternion is the conjugate of the quaternion.</p>"},{"location":"unit_quaternion/#exponential-form","title":"Exponential Form","text":"<p>The unit quaternion can be represented in exponential form. The exponential form of a unit quaternion is defined as:</p> \\[\\begin{align} q &amp;= \\cos(\\theta/2) + \\sin(\\theta/2) \\mathbf{u} \\\\ &amp;= e^{\\frac{1}{2} \\theta \\mathbf{u} } \\end{align}\\] <p>where \\(e\\) is the base of the natural logarithm.</p>"},{"location":"unit_quaternion/#logarithmic-form","title":"Logarithmic Form","text":"<p>The logarithm of a unit quaternion is defined as:</p> \\[\\begin{align} \\log(q) &amp;=0 + \\frac{1}{2} \\theta \\mathbf{u} \\end{align}\\] <p>where \\(\\mathbf{u}\\) is the unit vector representing the rotation axis.</p>"},{"location":"unit_quaternion/#power","title":"Power","text":"<p>The power of a unit quaternion is defined as:</p> \\[\\begin{align} q^n &amp;= \\cos(n \\theta/2) + \\sin(n \\theta/2) \\mathbf{u} \\\\ &amp;= e^{\\frac{n}{2} \\theta \\mathbf{u} } \\\\ &amp;= \\exp(n \\log{q}) \\end{align}\\]"},{"location":"unit_quaternion/#action-on-3d-vector","title":"Action on 3D Vector","text":"<p>A unit quaternion can be used to rotate a 3D vector. The rotation of a 3D vector \\(\\mathbf{v}\\) by a unit quaternion \\(q\\) is defined as:</p> \\[\\begin{align} q &amp;= \\cos(\\theta/2) + \\sin(\\theta/2) \\mathbf{u} \\\\  &amp;= e^{\\frac{1}{2} \\theta \\mathbf{u} } \\\\ \\mathbf{v'} &amp;= q \\mathbf{v} q^{-1} \\\\ &amp;= q \\mathbf{v} \\bar{q} \\end{align}\\] <p>where \\(\\mathbf{v'}\\) is the rotated vector around the axis \\(\\mathbf{u}\\) by angle \\(\\theta\\).</p>"},{"location":"unit_quaternion/#unit-quaternion-class","title":"Unit Quaternion Class","text":"<p>Based on MatrixBase &amp; Quaternion class. All functions from base classes are available. Below are additional functions.</p> <pre><code>// initialize\nUnitQuaternion&lt;float&gt; q1(0.7071, 0.0, 0.0, 0.7071); // w, x, y, z\n// (Force initialization with norm constraint vialoation)\nUnitQuaternion&lt;float&gt; q2(1.f, 1.f, 1.f, 1.f); // w, x, y, z\n\n// initialize from other form\n// automatically normalized\nUnitQuaternion&lt;float&gt; q3(1.f, 2.f, 3.f, 4.f); // w, x, y, z\nUnitQuaternion&lt;float&gt; q4 = q3.cast2UnitQuaternion();\nVectorf&lt;4&gt; vec4{1.f, 1.f, 1.f, 1.f};\nUnitQuaternion&lt;float&gt; q5 = vec4.cast2UnitQuaternion();\n\n// type alias\nUnitQuaternionf q6 = q5;\n\n// accessors\n// same with Quaternion class\n\n// redirected inverse function\nUnitQuaternion&lt;float&gt; q7 = q6.inverse(); // internally calls conjugated()\n\n// canonicalize\nUnitQuaternionf q_can = q1.canonicalized(); // negate when w &lt; 0\n\n// axis rotations\n// rotatation around specific axis\nUnitQuaternionf q_rot_x = UnitQuaternionf::axisRotation&lt;AXIS::X&gt;(0.1f);\nUnitQuaternionf q_rot_y = UnitQuaternionf::axisRotation&lt;AXIS::Y&gt;(0.2f);\nUnitQuaternionf q_rot_z = UnitQuaternionf::axisRotation&lt;AXIS::Z&gt;(0.3f);\n\n// operators\nUnitQuaternionf q8 = q1 * q2; // S3 Composition\nQuaternionf q9 = q1 * q2.cast2Quaternion(); // Quaternion multiplication\nUnitQuaternionf q10 = q1 / q2; // S3 Division\nQuaternionf q11 = q1 / q2.cast2Quaternion(); // Quaternion division\n\nQuaternionf q12 = q1 + q2; // Quaternion addition\nQuaternionf q13 = q1 - q2; // Quaternion subtraction\n\n// rotation (action on 3D vector)\nVectorf&lt;3&gt; vec3{{1.f, 2.f, 3.f}};\nVectorf&lt;3&gt; vec3_rot = q1.rotateVector3D(vec3);\n\nVectorf&lt;2&gt; vec2{{1.f, 2.f}};\n// Use z-axis only for rotation\nVectorf&lt;2&gt; vec2_rot = q1.rotateVector2D(vec2);\n\n// identity\nUnitQuaternionf q14 = UnitQuaternionf::identity();\n\n// rotation representation conversion\nSOGroup&lt;2, float&gt; so2 = q1.toRotMatrix2D();\nSOGroup&lt;3, float&gt; so3 = q1.toRotMatrix3D();\nAxisAngle&lt;float&gt; axis_angle = q1.toAxisAngle&lt;&gt;();\nEulerAngle&lt;float, EULER_ORDER::ZYX&gt; euler_angle2d = q1.toEulerAngle2D&lt;EULER_ORDER::ZYX&gt;();\nEulerAngle&lt;float, EULER_ORDER::XYZ&gt; euler_angle3d = q1.toEulerAngle3D&lt;EULER_ORDER::XYZ&gt;();\n</code></pre>"},{"location":"translotator/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace TRANSLOTATOR </li> <li>namespace translotator <ul> <li>class AxisAngle Represents a rotation in 3D space by an angle around an axis. </li> <li>class ComplexNum Represents a complex number with real and imaginary parts. </li> <li>class DualNumber Represents a dual number. </li> <li>class DualQuaternion Represents a dual quaternion. </li> <li>namespace EULER_CONSTEXPR Namespace for Euler Order constexpr functions. </li> <li>class EulerAngle Represents Euler angle 3D rotation. </li> <li>class Matrix Matrix class. </li> <li>class MatrixBase Base class for all matrix objects. </li> <li>namespace MatrixBaseInternal Internal namespace for MatrixBase implementation. <ul> <li>struct operator_cast_typemapper </li> <li>struct operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt; </li> <li>struct operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt; </li> <li>struct operator_mul_typemapper </li> <li>struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; </li> <li>struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; </li> <li>struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; </li> <li>struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; </li> </ul> </li> <li>class Quaternion Representing a quaternion. </li> <li>class SEGroup Special Euclidean Group. </li> <li>class SOGroup Special Orthogonal Group. </li> <li>class SquareMatrix </li> <li>class UnitComplexNum </li> <li>class UnitDualQuaternion Represents a unit dual quaternion. </li> <li>class UnitQuaternion UnitQuaternion class. </li> <li>class Vector Vector class. </li> <li>struct all_same </li> <li>struct all_same&lt; T &gt; </li> <li>struct all_same&lt; T, First, Rest... &gt; </li> <li>struct conditional_if </li> <li>struct conditional_if&lt; false, T, F &gt; </li> <li>struct enable_if </li> <li>struct enable_if&lt; true, T &gt; </li> <li>struct initializer_list initializer_list struct </li> <li>struct integral_constant </li> <li>namespace interpolators <ul> <li>class Lerper Linear interpolation class. </li> <li>class ScLerper Screw linear interpolation class. </li> <li>class SlerpLerper Slerp for rotation component, lerp for translation component class. </li> <li>class Slerper Slerp for rotation component interpolation class. </li> <li>class SlerperFast Slerp for rotation component interpolation class. Faster than Slerper for S1, S3 group. </li> </ul> </li> <li>struct is_float </li> <li>struct is_float&lt; double &gt; </li> <li>struct is_float&lt; float &gt; </li> <li>struct is_float&lt; long double &gt; </li> <li>struct is_matrix_base </li> <li>struct is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt; </li> <li>struct is_same </li> <li>struct is_same&lt; T, T &gt; </li> <li>namespace lie Namespace for Lie Group and Algebra Operations. <ul> <li>struct LieOperator Lie Operator for Lie Group and Lie Algebra. </li> <li>struct LieOperator&lt; ObjectType::SE_GROUP, Type &gt; Lie Operator for SE. </li> <li>struct LieOperator&lt; ObjectType::SO_GROUP, Type &gt; Special Orthogonal Group. </li> <li>struct LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt; Lie Operator for S1. </li> <li>struct LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt; Lie Operator for S3. </li> </ul> </li> </ul> </li> </ul>"},{"location":"translotator/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>dir translotator <ul> <li>file config.hpp </li> <li>dir interpolators <ul> <li>file Lerp.hpp </li> <li>file ScLerp.hpp </li> <li>file Slerp.hpp </li> <li>file Slerp_Lerp.hpp </li> </ul> </li> <li>dir lie <ul> <li>file LieOperator.hpp </li> <li>file S1.hpp </li> <li>file S3.hpp </li> <li>file SE.hpp </li> <li>file SO.hpp </li> </ul> </li> <li>dir objects <ul> <li>file AxisAngle.hpp </li> <li>file ComplexNum.hpp </li> <li>file DualNumber.hpp </li> <li>file DualQuaternion.hpp </li> <li>file EulerAngle.hpp </li> <li>file Matrix.hpp </li> <li>file MatrixBase.hpp </li> <li>file MatrixBaseInternal.hpp </li> <li>file Quaternion.hpp </li> <li>file SEGroup.hpp </li> <li>file SOGroup.hpp </li> <li>file SquareMatrix.hpp </li> <li>file UnitComplexNum.hpp </li> <li>file UnitDualQuaternion.hpp </li> <li>file UnitQuaternion.hpp </li> <li>file Vector.hpp </li> <li>file initializer_list.hpp </li> <li>file objectdefs.hpp </li> <li>file tail.hpp </li> </ul> </li> <li>dir utils <ul> <li>file default_type.hpp </li> <li>file epsilon.hpp </li> <li>file micro_math.hpp </li> <li>file micro_type_traits.hpp </li> </ul> </li> <li>file translotator.hpp </li> <li>file version.hpp </li> </ul> </li> </ul> </li> </ul>"},{"location":"translotator/namespaceTRANSLOTATOR/","title":"Namespace TRANSLOTATOR","text":"<p>Namespace List &gt; TRANSLOTATOR</p> <p>The documentation for this class was generated from the following file <code>include/translotator/version.hpp</code></p>"},{"location":"translotator/namespacetranslotator/","title":"Namespace translotator","text":"<p>Namespace List &gt; translotator</p>"},{"location":"translotator/namespacetranslotator/#namespaces","title":"Namespaces","text":"Type Name namespace EULER_CONSTEXPR Namespace for Euler Order constexpr functions. namespace MatrixBaseInternal Internal namespace for MatrixBase implementation. namespace interpolators namespace lie Namespace for Lie Group and Algebra Operations."},{"location":"translotator/namespacetranslotator/#classes","title":"Classes","text":"Type Name class AxisAngle &lt;typename Type&gt;Represents a rotation in 3D space by an angle around an axis. class ComplexNum &lt;typename Type&gt;Represents a complex number with real and imaginary parts. class DualNumber &lt;typename Type&gt;Represents a dual number. class DualQuaternion &lt;typename Type&gt;Represents a dual quaternion. class EulerAngle &lt;typename Type, AxisOrder&gt;Represents Euler angle 3D rotation. class Matrix &lt;N, M, typename Type&gt;Matrix class. class MatrixBase &lt;N, M, typename Type, typename Derived&gt;Base class for all matrix objects. class Quaternion &lt;typename Type&gt;Representing a quaternion. class SEGroup &lt;N, typename Type&gt;Special Euclidean Group. class SOGroup &lt;N, typename Type&gt;Special Orthogonal Group. class SquareMatrix &lt;N, typename Type&gt; class UnitComplexNum &lt;typename Type&gt; class UnitDualQuaternion &lt;typename Type&gt;Represents a unit dual quaternion. class UnitQuaternion &lt;typename Type&gt;UnitQuaternion class. class Vector &lt;N, typename Type&gt;Vector class. struct all_same &lt;typename T, Args&gt; struct all_same&lt; T &gt; &lt;typename T&gt; struct all_same&lt; T, First, Rest... &gt; &lt;typename T, typename First, Rest&gt; struct conditional_if &lt;B, typename T, typename F&gt; struct conditional_if&lt; false, T, F &gt; &lt;typename T, typename F&gt; struct enable_if &lt;B, typename T&gt; struct enable_if&lt; true, T &gt; &lt;typename T&gt; struct initializer_list &lt;N, typename Type&gt;initializer_list struct struct integral_constant &lt;typename T, v&gt; struct is_float &lt;typename T&gt; struct is_float&lt; double &gt; &lt;&gt; struct is_float&lt; float &gt; &lt;&gt; struct is_float&lt; long double &gt; &lt;&gt; struct is_matrix_base &lt;typename T, typename&gt; struct is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt; &lt;typename T&gt; struct is_same &lt;typename T, typename U&gt; struct is_same&lt; T, T &gt; &lt;typename T&gt;"},{"location":"translotator/namespacetranslotator/#public-types","title":"Public Types","text":"Type Name enum AXIS Enum class for axis. typedef AxisAngle&lt; double &gt; AxisAngled typedef AxisAngle&lt; float &gt; AxisAnglef typedef AxisAngle&lt; long double &gt; AxisAngleld typedef ComplexNum&lt; double &gt; ComplexNumd typedef ComplexNum&lt; float &gt; ComplexNumf typedef ComplexNum&lt; long double &gt; ComplexNumld typedef DualNumber&lt; double &gt; DualNumberd typedef DualNumber&lt; float &gt; DualNumberf typedef DualNumber&lt; long double &gt; DualNumberld typedef DualQuaternion&lt; double &gt; DualQuaterniond typedef DualQuaternion&lt; float &gt; DualQuaternionf typedef DualQuaternion&lt; long double &gt; DualQuaternionld enum EULER_ORDER Enum class for euler angle order. typedef EulerAngle&lt; Type, EULER_ORDER::XYZ &gt; EulerAngleXYZ typedef EulerAngleXYZ&lt; double &gt; EulerAngleXYZd typedef EulerAngleXYZ&lt; float &gt; EulerAngleXYZf typedef EulerAngleXYZ&lt; long double &gt; EulerAngleXYZld typedef EulerAngle&lt; Type, EULER_ORDER::ZYX &gt; EulerAngleZYX typedef EulerAngleZYX&lt; double &gt; EulerAngleZYXd typedef EulerAngleZYX&lt; float &gt; EulerAngleZYXf typedef EulerAngleZYX&lt; long double &gt; EulerAngleZYXld typedef EulerAngle&lt; double, AxisOrder &gt; EulerAngled typedef EulerAngle&lt; float, AxisOrder &gt; EulerAnglef typedef EulerAngle&lt; long double, AxisOrder &gt; EulerAngleld typedef Matrix&lt; N, M, double &gt; Matrixd typedef Matrix&lt; N, M, float &gt; Matrixf typedef Matrix&lt; N, M, long double &gt; Matrixld enum ObjectType Enum class for object types. typedef Quaternion&lt; double &gt; Quaterniond typedef Quaternion&lt; float &gt; Quaternionf typedef Quaternion&lt; long double &gt; Quaternionld typedef SO2Group&lt; Type &gt; RotationMatrix2D typedef SO2Groupd RotationMatrix2Dd typedef SO2Groupf RotationMatrix2Df typedef SO2Groupld RotationMatrix2Dld typedef SO3Group&lt; Type &gt; RotationMatrix3D typedef SO3Groupd RotationMatrix3Dd typedef SO3Groupf RotationMatrix3Df typedef SO3Groupld RotationMatrix3Dld typedef SOGroupd&lt; N &gt; RotationMatrixd typedef SOGroupf&lt; N &gt; RotationMatrixf typedef SOGroupld&lt; N &gt; RotationMatrixld typedef UnitComplexNumd S1d typedef UnitComplexNumf S1f typedef UnitComplexNumld S1ld typedef UnitQuaterniond S3d typedef UnitQuaternionf S3f typedef UnitQuaternionld S3ld typedef SEGroup&lt; 2, Type &gt; SE2Group typedef SE2Group&lt; double &gt; SE2Groupd typedef SE2Group&lt; float &gt; SE2Groupf typedef SE2Group&lt; long double &gt; SE2Groupld typedef SEGroup&lt; 3, Type &gt; SE3Group typedef SE3Group&lt; double &gt; SE3Groupd typedef SE3Group&lt; float &gt; SE3Groupf typedef SE3Group&lt; long double &gt; SE3Groupld typedef SEGroup&lt; N, double &gt; SEGroupd typedef SEGroup&lt; N, float &gt; SEGroupf typedef SEGroup&lt; N, long double &gt; SEGroupld typedef SOGroup&lt; 2, Type &gt; SO2Group typedef SO2Group&lt; double &gt; SO2Groupd typedef SO2Group&lt; float &gt; SO2Groupf typedef SO2Group&lt; long double &gt; SO2Groupld typedef SOGroup&lt; 3, Type &gt; SO3Group typedef SO3Group&lt; double &gt; SO3Groupd typedef SO3Group&lt; float &gt; SO3Groupf typedef SO3Group&lt; long double &gt; SO3Groupld typedef SOGroup&lt; N, double &gt; SOGroupd typedef SOGroup&lt; N, float &gt; SOGroupf typedef SOGroup&lt; N, long double &gt; SOGroupld typedef SquareMatrix&lt; N, double &gt; SquareMatrixd typedef SquareMatrix&lt; N, float &gt; SquareMatrixf typedef SquareMatrix&lt; N, long double &gt; SquareMatrixld typedef UnitComplexNum&lt; double &gt; UnitComplexNumd typedef UnitComplexNum&lt; float &gt; UnitComplexNumf typedef UnitComplexNum&lt; long double &gt; UnitComplexNumld typedef UnitDualQuaternion&lt; double &gt; UnitDualQuaterniond typedef UnitDualQuaternion&lt; float &gt; UnitDualQuaternionf typedef UnitDualQuaternion&lt; long double &gt; UnitDualQuaternionld typedef UnitQuaternion&lt; double &gt; UnitQuaterniond typedef UnitQuaternion&lt; float &gt; UnitQuaternionf typedef UnitQuaternion&lt; long double &gt; UnitQuaternionld typedef Vector&lt; N, double &gt; Vectord typedef Vector&lt; N, float &gt; Vectorf typedef Vector&lt; N, long double &gt; Vectorld typedef typename conditional_if&lt; B, T, F &gt;::type conditional_if_t typedef typename enable_if&lt; B, T &gt;::type enable_if_t typedef integral_constant&lt; bool, false &gt; false_type typedef integral_constant&lt; bool, true &gt; true_type"},{"location":"translotator/namespacetranslotator/#public-attributes","title":"Public Attributes","text":"Type Name constexpr bool all_same_v   = = all_same&lt;T, Args...&gt;::value constexpr bool is_float_v   = = is_float&lt;T&gt;::value constexpr bool is_matrix_base_v   = = is_matrix_base&lt;T&gt;::value constexpr bool is_same_v   = = is_same&lt;T, U&gt;::value"},{"location":"translotator/namespacetranslotator/#public-functions","title":"Public Functions","text":"Type Name T abs (const T &amp; v)  T acos (const T &amp; v)  T asin (const T &amp; v)  T atan (const T &amp; v)  T atan2 (const T &amp; y, const T &amp; x)  T ceil (const T &amp; v)  T ceilf (const T &amp; v)  T cos (const T &amp; v)  T cube (const T &amp; v)  constexpr T epsilon () epsilon for floating point T exp (const T &amp; v)  constexpr T exponent_epsilon () epsilon for floating point T floorf (const T &amp; v)  T fmax (const T &amp; x, const T &amp; y)  T fmin (const T &amp; x, const T &amp; y)  T powf (const T &amp; x, const T &amp; y)  T roundf (const T &amp; v)  T sin (const T &amp; v)  T sqrt (const T &amp; v)  T square (const T &amp; v)  T tan (const T &amp; v)  T truncf (const T &amp; v)"},{"location":"translotator/namespacetranslotator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/namespacetranslotator/#enum-axis","title":"enum AXIS","text":"<p>Enum class for axis. <pre><code>enum translotator::AXIS {\n    X = 0x1,\n    Y = 0x2,\n    Z = 0x3\n};\n</code></pre></p> <p>This enum class is used to identify the axis </p>"},{"location":"translotator/namespacetranslotator/#typedef-axisangled","title":"typedef AxisAngled","text":"<pre><code>using translotator::AxisAngled = typedef AxisAngle&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-axisanglef","title":"typedef AxisAnglef","text":"<pre><code>using translotator::AxisAnglef = typedef AxisAngle&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-axisangleld","title":"typedef AxisAngleld","text":"<pre><code>using translotator::AxisAngleld = typedef AxisAngle&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-complexnumd","title":"typedef ComplexNumd","text":"<pre><code>using translotator::ComplexNumd = typedef ComplexNum&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-complexnumf","title":"typedef ComplexNumf","text":"<pre><code>using translotator::ComplexNumf = typedef ComplexNum&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-complexnumld","title":"typedef ComplexNumld","text":"<pre><code>using translotator::ComplexNumld = typedef ComplexNum&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-dualnumberd","title":"typedef DualNumberd","text":"<pre><code>using translotator::DualNumberd = typedef DualNumber&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-dualnumberf","title":"typedef DualNumberf","text":"<pre><code>using translotator::DualNumberf = typedef DualNumber&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-dualnumberld","title":"typedef DualNumberld","text":"<pre><code>using translotator::DualNumberld = typedef DualNumber&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-dualquaterniond","title":"typedef DualQuaterniond","text":"<pre><code>using translotator::DualQuaterniond = typedef DualQuaternion&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-dualquaternionf","title":"typedef DualQuaternionf","text":"<pre><code>using translotator::DualQuaternionf = typedef DualQuaternion&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-dualquaternionld","title":"typedef DualQuaternionld","text":"<pre><code>using translotator::DualQuaternionld = typedef DualQuaternion&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#enum-euler_order","title":"enum EULER_ORDER","text":"<p>Enum class for euler angle order. <pre><code>enum translotator::EULER_ORDER {\n    XYZ = 0x123,\n    XZY = 0x132,\n    YXZ = 0x213,\n    YZX = 0x231,\n    ZXY = 0x312,\n    ZYX = 0x321\n};\n</code></pre></p> <p>This enum class is used to identify the euler angle order </p> <p>Note:</p> <p>The order is represented as 3 digits, where each digit represents the axis </p> <p>Note:</p> <p>All intrinsic orders, Tait-Bryan angles </p> <p>Note:</p> <p>For example, XYZ order means the rotation is applied in the order of intrinsic X, Y, Z axis </p>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglexyz","title":"typedef EulerAngleXYZ","text":"<pre><code>using translotator::EulerAngleXYZ = typedef EulerAngle&lt;Type, EULER_ORDER::XYZ&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglexyzd","title":"typedef EulerAngleXYZd","text":"<pre><code>using translotator::EulerAngleXYZd = typedef EulerAngleXYZ&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglexyzf","title":"typedef EulerAngleXYZf","text":"<pre><code>using translotator::EulerAngleXYZf = typedef EulerAngleXYZ&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglexyzld","title":"typedef EulerAngleXYZld","text":"<pre><code>using translotator::EulerAngleXYZld = typedef EulerAngleXYZ&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglezyx","title":"typedef EulerAngleZYX","text":"<pre><code>using translotator::EulerAngleZYX = typedef EulerAngle&lt;Type, EULER_ORDER::ZYX&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglezyxd","title":"typedef EulerAngleZYXd","text":"<pre><code>using translotator::EulerAngleZYXd = typedef EulerAngleZYX&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglezyxf","title":"typedef EulerAngleZYXf","text":"<pre><code>using translotator::EulerAngleZYXf = typedef EulerAngleZYX&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglezyxld","title":"typedef EulerAngleZYXld","text":"<pre><code>using translotator::EulerAngleZYXld = typedef EulerAngleZYX&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-eulerangled","title":"typedef EulerAngled","text":"<pre><code>using translotator::EulerAngled = typedef EulerAngle&lt;double, AxisOrder&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-euleranglef","title":"typedef EulerAnglef","text":"<pre><code>using translotator::EulerAnglef = typedef EulerAngle&lt;float, AxisOrder&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-eulerangleld","title":"typedef EulerAngleld","text":"<pre><code>using translotator::EulerAngleld = typedef EulerAngle&lt;long double, AxisOrder&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-matrixd","title":"typedef Matrixd","text":"<pre><code>using translotator::Matrixd = typedef Matrix&lt;N, M, double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-matrixf","title":"typedef Matrixf","text":"<pre><code>using translotator::Matrixf = typedef Matrix&lt;N, M, float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-matrixld","title":"typedef Matrixld","text":"<pre><code>using translotator::Matrixld = typedef Matrix&lt;N, M, long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#enum-objecttype","title":"enum ObjectType","text":"<p>Enum class for object types. <pre><code>enum translotator::ObjectType {\n    MATRIX,\n    VECTOR,\n    SQUARE_MATRIX,\n    COMPLEX_NUM,\n    QUATERNION,\n    DUAL_NUMBER,\n    DUAL_QUATERNION,\n    UNIT_COMPLEX_NUM,\n    UNIT_QUATERNION,\n    AXIS_ANGLE,\n    EULER_ANGLE,\n    SO_GROUP,\n    SE_GROUP,\n    UNIT_DUAL_QUATERNION\n};\n</code></pre></p> <p>This enum class is used to identify the type of the object </p>"},{"location":"translotator/namespacetranslotator/#typedef-quaterniond","title":"typedef Quaterniond","text":"<pre><code>using translotator::Quaterniond = typedef Quaternion&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-quaternionf","title":"typedef Quaternionf","text":"<pre><code>using translotator::Quaternionf = typedef Quaternion&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-quaternionld","title":"typedef Quaternionld","text":"<pre><code>using translotator::Quaternionld = typedef Quaternion&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix2d","title":"typedef RotationMatrix2D","text":"<pre><code>using translotator::RotationMatrix2D = typedef SO2Group&lt;Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix2dd","title":"typedef RotationMatrix2Dd","text":"<pre><code>using translotator::RotationMatrix2Dd = typedef SO2Groupd;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix2df","title":"typedef RotationMatrix2Df","text":"<pre><code>using translotator::RotationMatrix2Df = typedef SO2Groupf;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix2dld","title":"typedef RotationMatrix2Dld","text":"<pre><code>using translotator::RotationMatrix2Dld = typedef SO2Groupld;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix3d","title":"typedef RotationMatrix3D","text":"<pre><code>using translotator::RotationMatrix3D = typedef SO3Group&lt;Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix3dd","title":"typedef RotationMatrix3Dd","text":"<pre><code>using translotator::RotationMatrix3Dd = typedef SO3Groupd;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix3df","title":"typedef RotationMatrix3Df","text":"<pre><code>using translotator::RotationMatrix3Df = typedef SO3Groupf;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrix3dld","title":"typedef RotationMatrix3Dld","text":"<pre><code>using translotator::RotationMatrix3Dld = typedef SO3Groupld;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrixd","title":"typedef RotationMatrixd","text":"<pre><code>using translotator::RotationMatrixd = typedef SOGroupd&lt;N&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrixf","title":"typedef RotationMatrixf","text":"<pre><code>using translotator::RotationMatrixf = typedef SOGroupf&lt;N&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-rotationmatrixld","title":"typedef RotationMatrixld","text":"<pre><code>using translotator::RotationMatrixld = typedef SOGroupld&lt;N&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-s1d","title":"typedef S1d","text":"<pre><code>using translotator::S1d = typedef UnitComplexNumd;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-s1f","title":"typedef S1f","text":"<pre><code>using translotator::S1f = typedef UnitComplexNumf;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-s1ld","title":"typedef S1ld","text":"<pre><code>using translotator::S1ld = typedef UnitComplexNumld;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-s3d","title":"typedef S3d","text":"<pre><code>using translotator::S3d = typedef UnitQuaterniond;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-s3f","title":"typedef S3f","text":"<pre><code>using translotator::S3f = typedef UnitQuaternionf;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-s3ld","title":"typedef S3ld","text":"<pre><code>using translotator::S3ld = typedef UnitQuaternionld;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se2group","title":"typedef SE2Group","text":"<pre><code>using translotator::SE2Group = typedef SEGroup&lt;2, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se2groupd","title":"typedef SE2Groupd","text":"<pre><code>using translotator::SE2Groupd = typedef SE2Group&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se2groupf","title":"typedef SE2Groupf","text":"<pre><code>using translotator::SE2Groupf = typedef SE2Group&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se2groupld","title":"typedef SE2Groupld","text":"<pre><code>using translotator::SE2Groupld = typedef SE2Group&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se3group","title":"typedef SE3Group","text":"<pre><code>using translotator::SE3Group = typedef SEGroup&lt;3, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se3groupd","title":"typedef SE3Groupd","text":"<pre><code>using translotator::SE3Groupd = typedef SE3Group&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se3groupf","title":"typedef SE3Groupf","text":"<pre><code>using translotator::SE3Groupf = typedef SE3Group&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-se3groupld","title":"typedef SE3Groupld","text":"<pre><code>using translotator::SE3Groupld = typedef SE3Group&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-segroupd","title":"typedef SEGroupd","text":"<pre><code>using translotator::SEGroupd = typedef SEGroup&lt;N, double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-segroupf","title":"typedef SEGroupf","text":"<pre><code>using translotator::SEGroupf = typedef SEGroup&lt;N, float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-segroupld","title":"typedef SEGroupld","text":"<pre><code>using translotator::SEGroupld = typedef SEGroup&lt;N, long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so2group","title":"typedef SO2Group","text":"<pre><code>using translotator::SO2Group = typedef SOGroup&lt;2, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so2groupd","title":"typedef SO2Groupd","text":"<pre><code>using translotator::SO2Groupd = typedef SO2Group&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so2groupf","title":"typedef SO2Groupf","text":"<pre><code>using translotator::SO2Groupf = typedef SO2Group&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so2groupld","title":"typedef SO2Groupld","text":"<pre><code>using translotator::SO2Groupld = typedef SO2Group&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so3group","title":"typedef SO3Group","text":"<pre><code>using translotator::SO3Group = typedef SOGroup&lt;3, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so3groupd","title":"typedef SO3Groupd","text":"<pre><code>using translotator::SO3Groupd = typedef SO3Group&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so3groupf","title":"typedef SO3Groupf","text":"<pre><code>using translotator::SO3Groupf = typedef SO3Group&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-so3groupld","title":"typedef SO3Groupld","text":"<pre><code>using translotator::SO3Groupld = typedef SO3Group&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-sogroupd","title":"typedef SOGroupd","text":"<pre><code>using translotator::SOGroupd = typedef SOGroup&lt;N, double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-sogroupf","title":"typedef SOGroupf","text":"<pre><code>using translotator::SOGroupf = typedef SOGroup&lt;N, float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-sogroupld","title":"typedef SOGroupld","text":"<pre><code>using translotator::SOGroupld = typedef SOGroup&lt;N, long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-squarematrixd","title":"typedef SquareMatrixd","text":"<pre><code>using translotator::SquareMatrixd = typedef SquareMatrix&lt;N, double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-squarematrixf","title":"typedef SquareMatrixf","text":"<pre><code>using translotator::SquareMatrixf = typedef SquareMatrix&lt;N, float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-squarematrixld","title":"typedef SquareMatrixld","text":"<pre><code>using translotator::SquareMatrixld = typedef SquareMatrix&lt;N, long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitcomplexnumd","title":"typedef UnitComplexNumd","text":"<pre><code>using translotator::UnitComplexNumd = typedef UnitComplexNum&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitcomplexnumf","title":"typedef UnitComplexNumf","text":"<pre><code>using translotator::UnitComplexNumf = typedef UnitComplexNum&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitcomplexnumld","title":"typedef UnitComplexNumld","text":"<pre><code>using translotator::UnitComplexNumld = typedef UnitComplexNum&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitdualquaterniond","title":"typedef UnitDualQuaterniond","text":"<pre><code>using translotator::UnitDualQuaterniond = typedef UnitDualQuaternion&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitdualquaternionf","title":"typedef UnitDualQuaternionf","text":"<pre><code>using translotator::UnitDualQuaternionf = typedef UnitDualQuaternion&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitdualquaternionld","title":"typedef UnitDualQuaternionld","text":"<pre><code>using translotator::UnitDualQuaternionld = typedef UnitDualQuaternion&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitquaterniond","title":"typedef UnitQuaterniond","text":"<pre><code>using translotator::UnitQuaterniond = typedef UnitQuaternion&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitquaternionf","title":"typedef UnitQuaternionf","text":"<pre><code>using translotator::UnitQuaternionf = typedef UnitQuaternion&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-unitquaternionld","title":"typedef UnitQuaternionld","text":"<pre><code>using translotator::UnitQuaternionld = typedef UnitQuaternion&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-vectord","title":"typedef Vectord","text":"<pre><code>using translotator::Vectord = typedef Vector&lt;N, double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-vectorf","title":"typedef Vectorf","text":"<pre><code>using translotator::Vectorf = typedef Vector&lt;N, float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-vectorld","title":"typedef Vectorld","text":"<pre><code>using translotator::Vectorld = typedef Vector&lt;N, long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-conditional_if_t","title":"typedef conditional_if_t","text":"<pre><code>using translotator::conditional_if_t = typedef typename conditional_if&lt;B, T, F&gt;::type;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-enable_if_t","title":"typedef enable_if_t","text":"<pre><code>using translotator::enable_if_t = typedef typename enable_if&lt;B, T&gt;::type;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-false_type","title":"typedef false_type","text":"<pre><code>using translotator::false_type = typedef integral_constant&lt;bool, false&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#typedef-true_type","title":"typedef true_type","text":"<pre><code>using translotator::true_type = typedef integral_constant&lt;bool, true&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"translotator/namespacetranslotator/#variable-all_same_v","title":"variable all_same_v","text":"<pre><code>constexpr bool translotator::all_same_v;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#variable-is_float_v","title":"variable is_float_v","text":"<pre><code>constexpr bool translotator::is_float_v;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#variable-is_matrix_base_v","title":"variable is_matrix_base_v","text":"<pre><code>constexpr bool translotator::is_matrix_base_v;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#variable-is_same_v","title":"variable is_same_v","text":"<pre><code>constexpr bool translotator::is_same_v;\n</code></pre>"},{"location":"translotator/namespacetranslotator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/namespacetranslotator/#function-abs","title":"function abs","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::abs (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-acos","title":"function acos","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::acos (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-asin","title":"function asin","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::asin (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-atan","title":"function atan","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::atan (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-atan2","title":"function atan2","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::atan2 (\n    const T &amp; y,\n    const T &amp; x\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-ceil","title":"function ceil","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::ceil (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-ceilf","title":"function ceilf","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::ceilf (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-cos","title":"function cos","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::cos (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-cube","title":"function cube","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::cube (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-epsilon","title":"function epsilon","text":"<p>epsilon for floating point <pre><code>template&lt;typename T&gt;\nconstexpr T translotator::epsilon () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> floating point type</li> </ul> <p>epsilon is a small value that is used to compare floating point numbers. </p>"},{"location":"translotator/namespacetranslotator/#function-exp","title":"function exp","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::exp (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-exponent_epsilon","title":"function exponent_epsilon","text":"<pre><code>template&lt;typename T, size_t N&gt;\nconstexpr T translotator::exponent_epsilon () \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-floorf","title":"function floorf","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::floorf (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-fmax","title":"function fmax","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::fmax (\n    const T &amp; x,\n    const T &amp; y\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-fmin","title":"function fmin","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::fmin (\n    const T &amp; x,\n    const T &amp; y\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-powf","title":"function powf","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::powf (\n    const T &amp; x,\n    const T &amp; y\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-roundf","title":"function roundf","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::roundf (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-sin","title":"function sin","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::sin (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-sqrt","title":"function sqrt","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::sqrt (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-square","title":"function square","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::square (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-tan","title":"function tan","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::tan (\n    const T &amp; v\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator/#function-truncf","title":"function truncf","text":"<pre><code>template&lt;typename T&gt;\ninline T translotator::truncf (\n    const T &amp; v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Lerp.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1AxisAngle/","title":"Class translotator::AxisAngle","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; AxisAngle</p> <p>Represents a rotation in 3D space by an angle around an axis. More...</p> <ul> <li><code>#include &lt;AxisAngle.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::AXIS_ANGLE"},{"location":"translotator/classtranslotator_1_1AxisAngle/#public-functions","title":"Public Functions","text":"Type Name AxisAngle (const Type &amp; angle, const Type &amp; x, const Type &amp; y, const Type &amp; z)  AxisAngle (const Type &amp; angle, const Vector&lt; 3, Type &gt; &amp; axis)  AxisAngle (const Type &amp; angle)  AxisAngle (const Vector&lt; 3, Type &gt; &amp; angleVector)  Type angle () const Type &amp; angle ()  const Vector&lt; 3, Type &gt; &amp; axis () const Vector&lt; 3, Type &gt; &amp; axis ()  void axisNormalize ()  AxisAngle axisNormalized () constnormalize the axis inside AxisAngle&lt; Type &gt; axisRotation (const Type &amp; angle) constreturn a new AxisAngle with the unit axis and a angle AxisAngle&lt; NewType &gt; castDataType () constconvert to a new AxisAngle with a different data type void inverse () return a new AxisAngle with normalized axis AxisAngle inversed () constinvert the angle Vector&lt; 2, Type &gt; rotateVector2D (const Vector&lt; 2, Type &gt; &amp; v) constrotate a 2D vector. Using only the z-axis of the AxisAngle __ Vector&lt; 3, Type &gt; rotateVector3D (const Vector&lt; 3, Type &gt; &amp; v) constreturn a new AxisAngle with inverted angle Vector&lt; 3, Type &gt; toAngleVector () constconvert to a Vector&lt;3, Type&gt; with the angle as the norm EulerAngle&lt; Type, AxisOrder &gt; toEulerAngle2D () constconvert to EulerAngle2D. Using only the z-axis of the AxisAngle __ EulerAngle&lt; Type, AxisOrder &gt; toEulerAngle3D () constconvert to EulerAngle3D SOGroup&lt; 2, Type &gt; toRotMatrix2D () constconvert to SOGroup&lt;2, Type&gt;. Using only the z-axis of the AxisAngle __ SOGroup&lt; 3, Type &gt; toRotMatrix3D () constconvert to SOGroup&lt;3, Type&gt; UnitComplexNum&lt; Type &gt; toUnitComplexNum () constconvert to UnitComplexNum . Using only z-axis of theAxisAngle __ UnitQuaternion&lt; Type &gt; toUnitQuaternion () constconvert to UnitQuaternion __ Type x () const Type &amp; x ()  Type y () const Type &amp; y ()  Type z () const Type &amp; z ()"},{"location":"translotator/classtranslotator_1_1AxisAngle/#public-static-functions","title":"Public Static Functions","text":"Type Name AxisAngle&lt; Type &gt; identity () Returns the identity of AxisAngle , which is a rotation of 0 degrees around the x-axis."},{"location":"translotator/classtranslotator_1_1AxisAngle/#detailed-description","title":"Detailed Description","text":"<p>AxisAngle </p> <p>Template parameters:</p> <ul> <li><code>Type</code> floating point type</li> </ul> <p>The axis is a unit vector. The angle is in radians. The rotation is counter-clockwise when looking from the positive side of the axis. </p>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1AxisAngle/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::AxisAngle&lt; Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axisangle-14","title":"function AxisAngle [1/4]","text":"<pre><code>inline translotator::AxisAngle::AxisAngle (\n    const Type &amp; angle,\n    const Type &amp; x,\n    const Type &amp; y,\n    const Type &amp; z\n) \n</code></pre> <p>Constructors </p>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axisangle-24","title":"function AxisAngle [2/4]","text":"<pre><code>inline explicit translotator::AxisAngle::AxisAngle (\n    const Type &amp; angle,\n    const Vector &lt; 3, Type &gt; &amp; axis\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axisangle-34","title":"function AxisAngle [3/4]","text":"<pre><code>inline explicit translotator::AxisAngle::AxisAngle (\n    const Type &amp; angle\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axisangle-44","title":"function AxisAngle [4/4]","text":"<pre><code>inline explicit translotator::AxisAngle::AxisAngle (\n    const Vector &lt; 3, Type &gt; &amp; angleVector\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-angle-12","title":"function angle [1/2]","text":"<pre><code>inline Type translotator::AxisAngle::angle () const\n</code></pre> <p>accessors </p>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-angle-22","title":"function angle [2/2]","text":"<pre><code>inline Type &amp; translotator::AxisAngle::angle () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axis-12","title":"function axis [1/2]","text":"<pre><code>inline const Vector &lt; 3, Type &gt; &amp; translotator::AxisAngle::axis () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axis-22","title":"function axis [2/2]","text":"<pre><code>inline Vector &lt; 3, Type &gt; &amp; translotator::AxisAngle::axis () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axisnormalize","title":"function axisNormalize","text":"<pre><code>inline void translotator::AxisAngle::axisNormalize () \n</code></pre> <p>Utils </p>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axisnormalized","title":"function axisNormalized","text":"<pre><code>inline AxisAngle translotator::AxisAngle::axisNormalized () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-axisrotation","title":"function axisRotation","text":"<pre><code>template&lt;AXIS Axis&gt;\ninline AxisAngle &lt; Type &gt; translotator::AxisAngle::axisRotation (\n    const Type &amp; angle\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-castdatatype","title":"function castDataType","text":"<pre><code>template&lt;typename NewType&gt;\ninline AxisAngle &lt; NewType &gt; translotator::AxisAngle::castDataType () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::AxisAngle::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-inversed","title":"function inversed","text":"<pre><code>inline AxisAngle translotator::AxisAngle::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-rotatevector2d","title":"function rotateVector2D","text":"<pre><code>inline Vector &lt; 2, Type &gt; translotator::AxisAngle::rotateVector2D (\n    const Vector &lt; 2, Type &gt; &amp; v\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-rotatevector3d","title":"function rotateVector3D","text":"<p>return a new AxisAngle with inverted angle <pre><code>inline Vector &lt; 3, Type &gt; translotator::AxisAngle::rotateVector3D (\n    const Vector &lt; 3, Type &gt; &amp; v\n) const\n</code></pre></p> <p>rotate a 3D vector </p>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-toanglevector","title":"function toAngleVector","text":"<pre><code>inline Vector &lt; 3, Type &gt; translotator::AxisAngle::toAngleVector () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-toeulerangle2d","title":"function toEulerAngle2D","text":"<pre><code>template&lt;EULER_ORDER AxisOrder&gt;\ninline EulerAngle &lt; Type, AxisOrder &gt; translotator::AxisAngle::toEulerAngle2D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-toeulerangle3d","title":"function toEulerAngle3D","text":"<pre><code>template&lt;EULER_ORDER AxisOrder&gt;\ninline EulerAngle &lt; Type, AxisOrder &gt; translotator::AxisAngle::toEulerAngle3D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-torotmatrix2d","title":"function toRotMatrix2D","text":"<pre><code>inline SOGroup &lt; 2, Type &gt; translotator::AxisAngle::toRotMatrix2D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-torotmatrix3d","title":"function toRotMatrix3D","text":"<pre><code>inline SOGroup &lt; 3, Type &gt; translotator::AxisAngle::toRotMatrix3D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-tounitcomplexnum","title":"function toUnitComplexNum","text":"<pre><code>inline UnitComplexNum &lt; Type &gt; translotator::AxisAngle::toUnitComplexNum () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-tounitquaternion","title":"function toUnitQuaternion","text":"<p>convert to UnitQuaternion __ <pre><code>inline UnitQuaternion &lt; Type &gt; translotator::AxisAngle::toUnitQuaternion () const\n</code></pre></p> <p>Casting </p>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-x-12","title":"function x [1/2]","text":"<pre><code>inline Type translotator::AxisAngle::x () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-x-22","title":"function x [2/2]","text":"<pre><code>inline Type &amp; translotator::AxisAngle::x () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-y-12","title":"function y [1/2]","text":"<pre><code>inline Type translotator::AxisAngle::y () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-y-22","title":"function y [2/2]","text":"<pre><code>inline Type &amp; translotator::AxisAngle::y () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-z-12","title":"function z [1/2]","text":"<pre><code>inline Type translotator::AxisAngle::z () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-z-22","title":"function z [2/2]","text":"<pre><code>inline Type &amp; translotator::AxisAngle::z () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1AxisAngle/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1AxisAngle/#function-identity","title":"function identity","text":"<p>Returns the identity of AxisAngle , which is a rotation of 0 degrees around the x-axis. <pre><code>static inline AxisAngle &lt; Type &gt; translotator::AxisAngle::identity () \n</code></pre></p> <p>static functions </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/AxisAngle.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1ComplexNum/","title":"Class translotator::ComplexNum","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; ComplexNum</p> <p>Represents a complex number with real and imaginary parts. More...</p> <ul> <li><code>#include &lt;ComplexNum.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::MatrixBase</p>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::COMPLEX_NUM"},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-functions","title":"Public Functions","text":"Type Name ComplexNum ()  ComplexNum (Type real, Type imag)  Type Im () const Type &amp; Im ()  Type Re () const Type &amp; Re ()  ComplexNum&lt; Type &gt; complexNumDiv (const ComplexNum&lt; Type &gt; &amp; c) constalias for operator*= for readability void complexNumDivEq (const ComplexNum&lt; Type &gt; &amp; c) alias for operator/ for readability ComplexNum&lt; Type &gt; complexNumMul (const ComplexNum&lt; Type &gt; &amp; c) constdivide and assign two complex numbers void complexNumMulEq (const ComplexNum&lt; Type &gt; &amp; c) alias for operator* for readability void conjugate () return the conjugated complex number ComplexNum&lt; Type &gt; conjugated () constnormalize the complex number void inverse () return the inversed complex number ComplexNum&lt; Type &gt; inversed () constconjugate the complex number Type norm () constreturn the squared norm of the complex number Type normSquared () const void normalize () return the normalized complex number ComplexNum&lt; Type &gt; normalized () constreturn the norm of the complex number ComplexNum&lt; Type &gt; operator* (const ComplexNum&lt; Type &gt; &amp; c) constmultiply two complex numbers void operator*= (const ComplexNum&lt; Type &gt; &amp; c)  ComplexNum&lt; Type &gt; operator/ (const ComplexNum&lt; Type &gt; &amp; c) constdivide two complex numbers void operator/= (const ComplexNum&lt; Type &gt; &amp; c) multiply and assign two complex numbers Type operator[] (size_t i) const Type &amp; operator[] (size_t i)  SquareMatrix&lt; 2, Type &gt; toMulMatrix () constinverse the complex number"},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1ComplexNum/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1ComplexNum/#detailed-description","title":"Detailed Description","text":"<p>ComplexNum </p> <p>Template parameters:</p> <ul> <li><code>Type</code> floating point type</li> </ul> <p>The imaginary part is multiplied by the imaginary unit i. The complex number is represented as a 2x1 matrix. The real part is the first element and the imaginary part is the second element. (2 x 1) form, [real, imag] = real + imag * i </p> <p>Note:</p> <p>Data structure : [real, imag], (2 x 1) </p>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1ComplexNum/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::ComplexNum&lt; Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-complexnum-12","title":"function ComplexNum [1/2]","text":"<pre><code>inline translotator::ComplexNum::ComplexNum () \n</code></pre> <p>constructors </p>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-complexnum-22","title":"function ComplexNum [2/2]","text":"<pre><code>inline explicit translotator::ComplexNum::ComplexNum (\n    Type real,\n    Type imag\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-im-12","title":"function Im [1/2]","text":"<pre><code>inline Type translotator::ComplexNum::Im () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-im-22","title":"function Im [2/2]","text":"<pre><code>inline Type &amp; translotator::ComplexNum::Im () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-re-12","title":"function Re [1/2]","text":"<pre><code>inline Type translotator::ComplexNum::Re () const\n</code></pre> <p>accessors </p>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-re-22","title":"function Re [2/2]","text":"<pre><code>inline Type &amp; translotator::ComplexNum::Re () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-complexnumdiv","title":"function complexNumDiv","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::ComplexNum::complexNumDiv (\n    const ComplexNum &lt; Type &gt; &amp; c\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-complexnumdiveq","title":"function complexNumDivEq","text":"<pre><code>inline void translotator::ComplexNum::complexNumDivEq (\n    const ComplexNum &lt; Type &gt; &amp; c\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-complexnummul","title":"function complexNumMul","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::ComplexNum::complexNumMul (\n    const ComplexNum &lt; Type &gt; &amp; c\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-complexnummuleq","title":"function complexNumMulEq","text":"<pre><code>inline void translotator::ComplexNum::complexNumMulEq (\n    const ComplexNum &lt; Type &gt; &amp; c\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-conjugate","title":"function conjugate","text":"<pre><code>inline void translotator::ComplexNum::conjugate () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-conjugated","title":"function conjugated","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::ComplexNum::conjugated () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::ComplexNum::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-inversed","title":"function inversed","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::ComplexNum::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-norm","title":"function norm","text":"<pre><code>inline Type translotator::ComplexNum::norm () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-normsquared","title":"function normSquared","text":"<pre><code>inline Type translotator::ComplexNum::normSquared () const\n</code></pre> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-normalize","title":"function normalize","text":"<pre><code>inline void translotator::ComplexNum::normalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-normalized","title":"function normalized","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::ComplexNum::normalized () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-operator","title":"function operator*","text":"<p>multiply two complex numbers <pre><code>inline ComplexNum &lt; Type &gt; translotator::ComplexNum::operator* (\n    const ComplexNum &lt; Type &gt; &amp; c\n) const\n</code></pre></p> <p>operators </p>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::ComplexNum::operator*= (\n    const ComplexNum &lt; Type &gt; &amp; c\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-operator_2","title":"function operator/","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::ComplexNum::operator/ (\n    const ComplexNum &lt; Type &gt; &amp; c\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-operator_3","title":"function operator/=","text":"<pre><code>inline void translotator::ComplexNum::operator/= (\n    const ComplexNum &lt; Type &gt; &amp; c\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-operator_4","title":"function operator[]","text":"<pre><code>inline Type translotator::ComplexNum::operator[] (\n    size_t i\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-operator_5","title":"function operator[]","text":"<pre><code>inline Type &amp; translotator::ComplexNum::operator[] (\n    size_t i\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1ComplexNum/#function-tomulmatrix","title":"function toMulMatrix","text":"<p>inverse the complex number <pre><code>inline SquareMatrix &lt; 2, Type &gt; translotator::ComplexNum::toMulMatrix () const\n</code></pre></p> <p>casting convert to a 2x2 multiplication matrix of complex number </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/ComplexNum.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1DualNumber/","title":"Class translotator::DualNumber","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; DualNumber</p> <p>Represents a dual number. More...</p> <ul> <li><code>#include &lt;DualNumber.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::MatrixBase</p>"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::DUAL_NUMBER"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-functions","title":"Public Functions","text":"Type Name Type Du () const Type &amp; Du ()  DualNumber ()  DualNumber (const Type &amp; r, const Type &amp; d)  Type Re () const Type &amp; Re ()  void conjugate () return the conjugate of this dual number DualNumber&lt; Type &gt; conjugated () const DualNumber&lt; Type &gt; dualNumDiv (const DualNumber&lt; Type &gt; &amp; other) constmultiply this dual number with another dual number void dualNumDivEq (const DualNumber&lt; Type &gt; &amp; other) return the division of two dual numbers DualNumber&lt; Type &gt; dualNumMul (const DualNumber&lt; Type &gt; &amp; other) constdivide this dual number with another dual number void dualNumMulEq (const DualNumber&lt; Type &gt; &amp; other) return the multiplication of two dual numbers DualNumber&lt; Type &gt; inversed () constnormalize the real part of this dual number Type norm () constreturn the squared norm of this dual number Type normSquared () constconjugate this dual number void normalize () return a new DualNumber with normalized real part DualNumber&lt; Type &gt; normalized () constreturn the norm of this dual number DualNumber&lt; Type &gt; operator* (const DualNumber&lt; Type &gt; &amp; other) constreturn the multiplication of two dual numbers void operator*= (const DualNumber&lt; Type &gt; &amp; other)  DualNumber&lt; Type &gt; operator/ (const DualNumber&lt; Type &gt; &amp; other) constreturn the division of two dual numbers void operator/= (const DualNumber&lt; Type &gt; &amp; other) multiply this dual number with another dual number Type operator[] (size_t i) const Type &amp; operator[] (size_t i)  SquareMatrix&lt; 2, Type &gt; toMulMatrix () constreturn a 2x2 matrix that represents the multiplication of this dual number"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1DualNumber/#public-static-functions","title":"Public Static Functions","text":"Type Name DualNumber&lt; Type &gt; sqrt (const DualNumber&lt; Type &gt; &amp; dn) divide this dual number with another dual number"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1DualNumber/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1DualNumber/#detailed-description","title":"Detailed Description","text":"<p>DualNumber </p> <p>Template parameters:</p> <ul> <li><code>Type</code> floating point type</li> </ul> <p>A dual number is a pair of real numbers, where one is the real part and the other is the dual part. The dual part is a number that squares to zero, i.e., e^2 = 0. It is used to represent infinitesimal quantities. </p> <p>Note:</p> <p>Data structure : [real, dual], (2 x 1) </p>"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1DualNumber/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::DualNumber&lt; Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1DualNumber/#function-du-12","title":"function Du [1/2]","text":"<pre><code>inline Type translotator::DualNumber::Du () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-du-22","title":"function Du [2/2]","text":"<pre><code>inline Type &amp; translotator::DualNumber::Du () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-dualnumber-12","title":"function DualNumber [1/2]","text":"<pre><code>inline translotator::DualNumber::DualNumber () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-dualnumber-22","title":"function DualNumber [2/2]","text":"<pre><code>inline translotator::DualNumber::DualNumber (\n    const Type &amp; r,\n    const Type &amp; d\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-re-12","title":"function Re [1/2]","text":"<pre><code>inline Type translotator::DualNumber::Re () const\n</code></pre> <p>accessors </p>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-re-22","title":"function Re [2/2]","text":"<pre><code>inline Type &amp; translotator::DualNumber::Re () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-conjugate","title":"function conjugate","text":"<pre><code>inline void translotator::DualNumber::conjugate () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-conjugated","title":"function conjugated","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualNumber::conjugated () const\n</code></pre> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-dualnumdiv","title":"function dualNumDiv","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualNumber::dualNumDiv (\n    const DualNumber &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-dualnumdiveq","title":"function dualNumDivEq","text":"<pre><code>inline void translotator::DualNumber::dualNumDivEq (\n    const DualNumber &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-dualnummul","title":"function dualNumMul","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualNumber::dualNumMul (\n    const DualNumber &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-dualnummuleq","title":"function dualNumMulEq","text":"<pre><code>inline void translotator::DualNumber::dualNumMulEq (\n    const DualNumber &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-inversed","title":"function inversed","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualNumber::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-norm","title":"function norm","text":"<pre><code>inline Type translotator::DualNumber::norm () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-normsquared","title":"function normSquared","text":"<pre><code>inline Type translotator::DualNumber::normSquared () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-normalize","title":"function normalize","text":"<pre><code>inline void translotator::DualNumber::normalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-normalized","title":"function normalized","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualNumber::normalized () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-operator","title":"function operator*","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualNumber::operator* (\n    const DualNumber &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::DualNumber::operator*= (\n    const DualNumber &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-operator_2","title":"function operator/","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualNumber::operator/ (\n    const DualNumber &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-operator_3","title":"function operator/=","text":"<pre><code>inline void translotator::DualNumber::operator/= (\n    const DualNumber &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-operator_4","title":"function operator[]","text":"<pre><code>inline Type translotator::DualNumber::operator[] (\n    size_t i\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-operator_5","title":"function operator[]","text":"<pre><code>inline Type &amp; translotator::DualNumber::operator[] (\n    size_t i\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualNumber/#function-tomulmatrix","title":"function toMulMatrix","text":"<p>return a 2x2 matrix that represents the multiplication of this dual number <pre><code>inline SquareMatrix &lt; 2, Type &gt; translotator::DualNumber::toMulMatrix () const\n</code></pre></p> <p>casts </p>"},{"location":"translotator/classtranslotator_1_1DualNumber/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1DualNumber/#function-sqrt","title":"function sqrt","text":"<p>divide this dual number with another dual number <pre><code>static inline DualNumber &lt; Type &gt; translotator::DualNumber::sqrt (\n    const DualNumber &lt; Type &gt; &amp; dn\n) \n</code></pre></p> <p>static functions return the square root of a dual number. Re &gt; 0 is required </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/DualNumber.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/","title":"Class translotator::DualQuaternion","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; DualQuaternion</p> <p>Represents a dual quaternion. More...</p> <ul> <li><code>#include &lt;DualQuaternion.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::MatrixBase</p> <p>Inherited by the following classes: translotator::UnitDualQuaternion</p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::DUAL_QUATERNION"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-functions","title":"Public Functions","text":"Type Name const Quaternion&lt; Type &gt; &amp; Du () const Quaternion&lt; Type &gt; &amp; Du ()  DualQuaternion () = default DualQuaternion (const Type &amp; rw, const Type &amp; rx, const Type &amp; ry, const Type &amp; rz, const Type &amp; dw, const Type &amp; dx, const Type &amp; dy, const Type &amp; dz)  DualQuaternion (const Quaternion&lt; Type &gt; &amp; r, const Quaternion&lt; Type &gt; &amp; d)  DualQuaternion (const DualNumber&lt; Type &gt; &amp; dn)  const Quaternion&lt; Type &gt; &amp; Re () const Quaternion&lt; Type &gt; &amp; Re ()  void conjugateDual ()  void conjugateFull ()  void conjugatePrimary ()  DualQuaternion&lt; Type &gt; conjugatedDual () constqr + qd e =&gt; qr* + qd* e DualQuaternion&lt; Type &gt; conjugatedFull () constqr + qd e =&gt; qr - qd e DualQuaternion&lt; Type &gt; conjugatedPrimary () constdual quaternion division DualQuaternion&lt; Type &gt; dualQuatDiv (const DualQuaternion&lt; Type &gt; &amp; dq) constdual quaternion multiplication void dualQuatDivEq (const DualQuaternion&lt; Type &gt; &amp; dq) dual quaternion division DualQuaternion&lt; Type &gt; dualQuatMul (const DualQuaternion&lt; Type &gt; &amp; dq) constdual quaternion division void dualQuatMulEq (const DualQuaternion&lt; Type &gt; &amp; dq) dual quaternion multiplication const Type &amp; dw () const Type &amp; dw ()  const Type &amp; dx () const Type &amp; dx ()  const Type &amp; dy () const Type &amp; dy ()  const Type &amp; dz () const Type &amp; dz ()  void inverse ()  DualQuaternion&lt; Type &gt; inversed () constdual quaternion inverse DualNumber&lt; Type &gt; normDualNum () constqr + qd e =&gt; qr* - qd* e DualNumber&lt; Type &gt; normDualNumSquared () constoriginal dual quaternion norm squared with primary conjugate Type normScalar () const Type normScalarSquared () constdual quaternion norm squared, dual number norm squared again void normalize () const DualQuaternion&lt; Type &gt; normalized () constdual quaternion inverse in place DualQuaternion&lt; Type &gt; operator* (const DualQuaternion&lt; Type &gt; &amp; other) constdual quaternion multiplication void operator*= (const DualQuaternion&lt; Type &gt; &amp; q) dual quaternion division DualQuaternion&lt; Type &gt; operator/ (const DualQuaternion&lt; Type &gt; &amp; other) const void operator/= (const DualQuaternion&lt; Type &gt; &amp; q) dual quaternion multiplication const Type &amp; operator[] (const size_t &amp; idx) const Type &amp; operator[] (const size_t &amp; idx)  const Type &amp; rw () const Type &amp; rw ()  const Type &amp; rx () const Type &amp; rx ()  const Type &amp; ry () const Type &amp; ry ()  const Type &amp; rz () const Type &amp; rz ()  SquareMatrix&lt; 8, Type &gt; toMulMatrix () constdual quaternion to multiplication matrix SquareMatrix&lt; 8, Type &gt; toRightMulMatrix () constdual quaternion to multiplication matrix from right ~DualQuaternion () = default"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-static-functions","title":"Public Static Functions","text":"Type Name DualQuaternion&lt; Type &gt; zeros () dual quaternion normalization"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1DualQuaternion/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> data type</li> </ul> <p>Dual quaternion is a hypercomplex number system that extends the idea of quaternion. Unit form is used to represent rigid transformations in 3D space. Dual quaternion is a pair of two quaternions, extension of dual number. </p> <p>Note:</p> <p>Data structure : [rw, rx, ry, rz, dw, dx, dy, dz], (8 x 1) </p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1DualQuaternion/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::DualQuaternion&lt; Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-du-12","title":"function Du [1/2]","text":"<pre><code>inline const Quaternion &lt; Type &gt; &amp; translotator::DualQuaternion::Du () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-du-22","title":"function Du [2/2]","text":"<pre><code>inline Quaternion &lt; Type &gt; &amp; translotator::DualQuaternion::Du () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquaternion-14","title":"function DualQuaternion [1/4]","text":"<pre><code>translotator::DualQuaternion::DualQuaternion () = default\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquaternion-24","title":"function DualQuaternion [2/4]","text":"<pre><code>inline translotator::DualQuaternion::DualQuaternion (\n    const Type &amp; rw,\n    const Type &amp; rx,\n    const Type &amp; ry,\n    const Type &amp; rz,\n    const Type &amp; dw,\n    const Type &amp; dx,\n    const Type &amp; dy,\n    const Type &amp; dz\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquaternion-34","title":"function DualQuaternion [3/4]","text":"<pre><code>inline translotator::DualQuaternion::DualQuaternion (\n    const Quaternion &lt; Type &gt; &amp; r,\n    const Quaternion &lt; Type &gt; &amp; d\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquaternion-44","title":"function DualQuaternion [4/4]","text":"<pre><code>inline translotator::DualQuaternion::DualQuaternion (\n    const DualNumber &lt; Type &gt; &amp; dn\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-re-12","title":"function Re [1/2]","text":"<pre><code>inline const Quaternion &lt; Type &gt; &amp; translotator::DualQuaternion::Re () const\n</code></pre> <p>accessors </p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-re-22","title":"function Re [2/2]","text":"<pre><code>inline Quaternion &lt; Type &gt; &amp; translotator::DualQuaternion::Re () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-conjugatedual","title":"function conjugateDual","text":"<pre><code>inline void translotator::DualQuaternion::conjugateDual () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-conjugatefull","title":"function conjugateFull","text":"<pre><code>inline void translotator::DualQuaternion::conjugateFull () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-conjugateprimary","title":"function conjugatePrimary","text":"<pre><code>inline void translotator::DualQuaternion::conjugatePrimary () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-conjugateddual","title":"function conjugatedDual","text":"<p>qr + qd e =&gt; qr* + qd* e <pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::conjugatedDual () const\n</code></pre></p> <p>qr + qd e =&gt; qr - qd e </p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-conjugatedfull","title":"function conjugatedFull","text":"<p>qr + qd e =&gt; qr - qd e <pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::conjugatedFull () const\n</code></pre></p> <p>qr + qd e =&gt; qr* - qd* e </p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-conjugatedprimary","title":"function conjugatedPrimary","text":"<p>dual quaternion division <pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::conjugatedPrimary () const\n</code></pre></p> <p>qr + qd e =&gt; qr* + qd* e </p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquatdiv","title":"function dualQuatDiv","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::dualQuatDiv (\n    const DualQuaternion &lt; Type &gt; &amp; dq\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquatdiveq","title":"function dualQuatDivEq","text":"<pre><code>inline void translotator::DualQuaternion::dualQuatDivEq (\n    const DualQuaternion &lt; Type &gt; &amp; dq\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquatmul","title":"function dualQuatMul","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::dualQuatMul (\n    const DualQuaternion &lt; Type &gt; &amp; dq\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquatmuleq","title":"function dualQuatMulEq","text":"<pre><code>inline void translotator::DualQuaternion::dualQuatMulEq (\n    const DualQuaternion &lt; Type &gt; &amp; dq\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dw-12","title":"function dw [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::dw () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dw-22","title":"function dw [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::dw () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dx-12","title":"function dx [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::dx () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dx-22","title":"function dx [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::dx () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dy-12","title":"function dy [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::dy () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dy-22","title":"function dy [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::dy () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dz-12","title":"function dz [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::dz () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dz-22","title":"function dz [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::dz () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::DualQuaternion::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-inversed","title":"function inversed","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-normdualnum","title":"function normDualNum","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualQuaternion::normDualNum () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-normdualnumsquared","title":"function normDualNumSquared","text":"<pre><code>inline DualNumber &lt; Type &gt; translotator::DualQuaternion::normDualNumSquared () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-normscalar","title":"function normScalar","text":"<pre><code>inline Type translotator::DualQuaternion::normScalar () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-normscalarsquared","title":"function normScalarSquared","text":"<pre><code>inline Type translotator::DualQuaternion::normScalarSquared () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-normalize","title":"function normalize","text":"<pre><code>inline void translotator::DualQuaternion::normalize () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-normalized","title":"function normalized","text":"<p>dual quaternion inverse in place <pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::normalized () const\n</code></pre></p> <p>Dual Quaternion Normalization.</p> <p>Using primary conjugate for norm. Dual quaternion normalization can be derived from division by norm Determine the real part for ordinary quaternion normlization. Determine the dual part in closed-form solution, ,which is 4 dimensional projection with scaled real part. </p> <p>Returns:</p> <p>normalized dual quaternion </p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-operator","title":"function operator*","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::operator* (\n    const DualQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::DualQuaternion::operator*= (\n    const DualQuaternion &lt; Type &gt; &amp; q\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-operator_2","title":"function operator/","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::operator/ (\n    const DualQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-operator_3","title":"function operator/=","text":"<pre><code>inline void translotator::DualQuaternion::operator/= (\n    const DualQuaternion &lt; Type &gt; &amp; q\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-operator_4","title":"function operator[]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::operator[] (\n    const size_t &amp; idx\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-operator_5","title":"function operator[]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::operator[] (\n    const size_t &amp; idx\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-rw-12","title":"function rw [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::rw () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-rw-22","title":"function rw [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::rw () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-rx-12","title":"function rx [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::rx () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-rx-22","title":"function rx [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::rx () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-ry-12","title":"function ry [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::ry () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-ry-22","title":"function ry [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::ry () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-rz-12","title":"function rz [1/2]","text":"<pre><code>inline const Type &amp; translotator::DualQuaternion::rz () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-rz-22","title":"function rz [2/2]","text":"<pre><code>inline Type &amp; translotator::DualQuaternion::rz () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-tomulmatrix","title":"function toMulMatrix","text":"<p>dual quaternion to multiplication matrix <pre><code>inline SquareMatrix &lt; 8, Type &gt; translotator::DualQuaternion::toMulMatrix () const\n</code></pre></p> <p>casts </p>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-torightmulmatrix","title":"function toRightMulMatrix","text":"<pre><code>inline SquareMatrix &lt; 8, Type &gt; translotator::DualQuaternion::toRightMulMatrix () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-dualquaternion","title":"function ~DualQuaternion","text":"<pre><code>translotator::DualQuaternion::~DualQuaternion () = default\n</code></pre>"},{"location":"translotator/classtranslotator_1_1DualQuaternion/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1DualQuaternion/#function-zeros","title":"function zeros","text":"<p>dual quaternion normalization <pre><code>static inline DualQuaternion &lt; Type &gt; translotator::DualQuaternion::zeros () \n</code></pre></p> <p>static functions</p> <p>zero dual quaternion </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/DualQuaternion.hpp</code></p>"},{"location":"translotator/namespacetranslotator_1_1EULER__CONSTEXPR/","title":"Namespace translotator::EULER_CONSTEXPR","text":"<p>Namespace List &gt; translotator &gt; EULER_CONSTEXPR</p> <p>Namespace for Euler Order constexpr functions. </p>"},{"location":"translotator/namespacetranslotator_1_1EULER__CONSTEXPR/#public-functions","title":"Public Functions","text":"Type Name constexpr AXIS AXIS_AT () noexceptGet the axis at Nth index in the euler order. constexpr size_t AXIS_IDX_AT () noexceptGet the index of the axis at Nth index in the euler order. constexpr size_t AXIS_TO_IDX () noexceptGet the index of the axis in the euler order."},{"location":"translotator/namespacetranslotator_1_1EULER__CONSTEXPR/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/namespacetranslotator_1_1EULER__CONSTEXPR/#function-axis_at","title":"function AXIS_AT","text":"<p>Get the axis at Nth index in the euler order. <pre><code>template&lt;size_t N, EULER_ORDER Order&gt;\nconstexpr AXIS translotator::EULER_CONSTEXPR::AXIS_AT () noexcept\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>N</code> Nth index </li> <li><code>Order</code> Euler order </li> </ul> <p>Returns:</p> <p>Axis at Nth index </p>"},{"location":"translotator/namespacetranslotator_1_1EULER__CONSTEXPR/#function-axis_idx_at","title":"function AXIS_IDX_AT","text":"<p>Get the index of the axis at Nth index in the euler order. <pre><code>template&lt;size_t N, EULER_ORDER Order&gt;\nconstexpr size_t translotator::EULER_CONSTEXPR::AXIS_IDX_AT () noexcept\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>N</code> Nth index </li> <li><code>Order</code> Euler order </li> </ul> <p>Returns:</p> <p>Index of the axis </p>"},{"location":"translotator/namespacetranslotator_1_1EULER__CONSTEXPR/#function-axis_to_idx","title":"function AXIS_TO_IDX","text":"<p>Get the index of the axis in the euler order. <pre><code>template&lt;AXIS Axis&gt;\nconstexpr size_t translotator::EULER_CONSTEXPR::AXIS_TO_IDX () noexcept\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Axis</code> Axis </li> <li><code>Order</code> Euler order </li> </ul> <p>Returns:</p> <p>Index of the axis </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/objectdefs.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1EulerAngle/","title":"Class translotator::EulerAngle","text":"<p>template &lt;typename Type, EULER_ORDER AxisOrder&gt;</p> <p>ClassList &gt; translotator &gt; EulerAngle</p> <p>Represents Euler angle 3D rotation. More...</p> <ul> <li><code>#include &lt;EulerAngle.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::EULER_ANGLE"},{"location":"translotator/classtranslotator_1_1EulerAngle/#public-functions","title":"Public Functions","text":"Type Name EulerAngle ()  EulerAngle (const Type &amp; angle)  EulerAngle (const Type &amp; x, const Type &amp; y, const Type &amp; z)  EulerAngle (const Vector&lt; 3, Type &gt; &amp; angles)  EulerAngle&lt; Type, NewAxisOrder &gt; castAxisOrder () constconvert to EulerAngle with new axis order EulerAngle&lt; NewType, AxisOrder &gt; castDataType () constconvert to EulerAngle with new axis order Type getAngleInOrder () constget angle in axis order (AXIS1, AXIS2, AXIS3) Type &amp; getAngleInOrder () get angle in axis order (AXIS1, AXIS2, AXIS3) constexpr AXIS getAxisInOrder () constget axis enum in axis order (AXIS1, AXIS2, AXIS3) Type operator[] (size_t idx) const Type &amp; operator[] (size_t idx)  Type pitch () const Type &amp; pitch ()  Type roll () const Type &amp; roll ()  Vector&lt; 2, Type &gt; rotateVec2D (const Vector&lt; 2, Type &gt; &amp; vec) const2D rotation. Using only z angle. Vector&lt; 3, Type &gt; rotateVec3D (const Vector&lt; 3, Type &gt; &amp; vec) const3D rotation AxisAngle&lt; Type &gt; toAxisAngle () constconvert to axis angle SOGroup&lt; 2, Type &gt; toSO2Group () constconvert to SO2 group. Using only z angle. SOGroup&lt; 3, Type &gt; toSO3Group () constconvert to SO3 group UnitComplexNum&lt; Type &gt; toUnitComplexNum () constconvert to unit complex number. Using only z angle. UnitQuaternion&lt; Type &gt; toUnitQuaternion () constconvert to unit quaternion Vector&lt; 3, Type &gt; toVector () constconvert to vector (x, y, z) Type x () const Type &amp; x ()  Type y () const Type &amp; y ()  Type yaw () const Type &amp; yaw ()  Type z () const Type &amp; z ()"},{"location":"translotator/classtranslotator_1_1EulerAngle/#public-static-functions","title":"Public Static Functions","text":"Type Name EulerAngle&lt; Type, AxisOrder &gt; axisRotation (const Type &amp; angle) axis rotation with angle"},{"location":"translotator/classtranslotator_1_1EulerAngle/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> data type </li> <li><code>AxisOrder</code> Euler angle order</li> </ul> <p>Euler angle class with 3 angles. The order of angles is determined by AxisOrder. The default order is ZYX. Intrinsic, tait-brayan angles are used. ex, XYZ means that the rotation is first around X axis, then Y axis, and finally Z axis intrinsically. Euler angle is a representation of orientation in 3D space. It is a set of three angles that specify the orientation of a rigid body in 3D space. Angles are typically in the range of [-pi, pi]. The order of angles is important because the rotation matrix is not commutative. </p>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1EulerAngle/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::EulerAngle&lt; Type, AxisOrder &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-eulerangle-14","title":"function EulerAngle [1/4]","text":"<pre><code>inline translotator::EulerAngle::EulerAngle () \n</code></pre> <p>constructor </p>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-eulerangle-24","title":"function EulerAngle [2/4]","text":"<pre><code>inline explicit translotator::EulerAngle::EulerAngle (\n    const Type &amp; angle\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-eulerangle-34","title":"function EulerAngle [3/4]","text":"<pre><code>inline translotator::EulerAngle::EulerAngle (\n    const Type &amp; x,\n    const Type &amp; y,\n    const Type &amp; z\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-eulerangle-44","title":"function EulerAngle [4/4]","text":"<pre><code>inline explicit translotator::EulerAngle::EulerAngle (\n    const Vector &lt; 3, Type &gt; &amp; angles\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-castaxisorder","title":"function castAxisOrder","text":"<p>convert to EulerAngle with new axis order <pre><code>template&lt;EULER_ORDER NewAxisOrder&gt;\ninline EulerAngle &lt; Type, NewAxisOrder &gt; translotator::EulerAngle::castAxisOrder () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NewAxisOrder</code> new axis order cast to new axis order </li> </ul>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-castdatatype","title":"function castDataType","text":"<p>convert to EulerAngle with new axis order <pre><code>template&lt;typename NewType&gt;\ninline EulerAngle &lt; NewType, AxisOrder &gt; translotator::EulerAngle::castDataType () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NewAxisOrder</code> new axis order </li> </ul>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-getangleinorder-12","title":"function getAngleInOrder [1/2]","text":"<p>get angle in axis order (AXIS1, AXIS2, AXIS3) <pre><code>template&lt;size_t N&gt;\ninline Type translotator::EulerAngle::getAngleInOrder () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>N</code> index of angle </li> </ul>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-getangleinorder-22","title":"function getAngleInOrder [2/2]","text":"<p>get angle in axis order (AXIS1, AXIS2, AXIS3) <pre><code>template&lt;size_t N&gt;\ninline Type &amp; translotator::EulerAngle::getAngleInOrder () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>N</code> index of angle </li> </ul>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-getaxisinorder","title":"function getAxisInOrder","text":"<p>get axis enum in axis order (AXIS1, AXIS2, AXIS3) <pre><code>template&lt;size_t N&gt;\ninline constexpr AXIS translotator::EulerAngle::getAxisInOrder () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>N</code> index of axis </li> </ul>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-operator","title":"function operator[]","text":"<pre><code>inline Type translotator::EulerAngle::operator[] (\n    size_t idx\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-operator_1","title":"function operator[]","text":"<pre><code>inline Type &amp; translotator::EulerAngle::operator[] (\n    size_t idx\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-pitch-12","title":"function pitch [1/2]","text":"<pre><code>inline Type translotator::EulerAngle::pitch () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-pitch-22","title":"function pitch [2/2]","text":"<pre><code>inline Type &amp; translotator::EulerAngle::pitch () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-roll-12","title":"function roll [1/2]","text":"<pre><code>inline Type translotator::EulerAngle::roll () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-roll-22","title":"function roll [2/2]","text":"<pre><code>inline Type &amp; translotator::EulerAngle::roll () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-rotatevec2d","title":"function rotateVec2D","text":"<p>2D rotation. Using only z angle. <pre><code>inline Vector &lt; 2, Type &gt; translotator::EulerAngle::rotateVec2D (\n    const Vector &lt; 2, Type &gt; &amp; vec\n) const\n</code></pre></p> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-rotatevec3d","title":"function rotateVec3D","text":"<pre><code>inline Vector &lt; 3, Type &gt; translotator::EulerAngle::rotateVec3D (\n    const Vector &lt; 3, Type &gt; &amp; vec\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-toaxisangle","title":"function toAxisAngle","text":"<pre><code>inline AxisAngle &lt; Type &gt; translotator::EulerAngle::toAxisAngle () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-toso2group","title":"function toSO2Group","text":"<pre><code>inline SOGroup &lt; 2, Type &gt; translotator::EulerAngle::toSO2Group () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-toso3group","title":"function toSO3Group","text":"<pre><code>inline SOGroup &lt; 3, Type &gt; translotator::EulerAngle::toSO3Group () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-tounitcomplexnum","title":"function toUnitComplexNum","text":"<pre><code>inline UnitComplexNum &lt; Type &gt; translotator::EulerAngle::toUnitComplexNum () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-tounitquaternion","title":"function toUnitQuaternion","text":"<p>convert to unit quaternion <pre><code>inline UnitQuaternion &lt; Type &gt; translotator::EulerAngle::toUnitQuaternion () const\n</code></pre></p> <p>casts </p>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-tovector","title":"function toVector","text":"<pre><code>inline Vector &lt; 3, Type &gt; translotator::EulerAngle::toVector () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-x-12","title":"function x [1/2]","text":"<pre><code>inline Type translotator::EulerAngle::x () const\n</code></pre> <p>accessor </p>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-x-22","title":"function x [2/2]","text":"<pre><code>inline Type &amp; translotator::EulerAngle::x () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-y-12","title":"function y [1/2]","text":"<pre><code>inline Type translotator::EulerAngle::y () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-y-22","title":"function y [2/2]","text":"<pre><code>inline Type &amp; translotator::EulerAngle::y () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-yaw-12","title":"function yaw [1/2]","text":"<pre><code>inline Type translotator::EulerAngle::yaw () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-yaw-22","title":"function yaw [2/2]","text":"<pre><code>inline Type &amp; translotator::EulerAngle::yaw () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-z-12","title":"function z [1/2]","text":"<pre><code>inline Type translotator::EulerAngle::z () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-z-22","title":"function z [2/2]","text":"<pre><code>inline Type &amp; translotator::EulerAngle::z () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1EulerAngle/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1EulerAngle/#function-axisrotation","title":"function axisRotation","text":"<p>axis rotation with angle <pre><code>template&lt;AXIS Axis&gt;\nstatic inline EulerAngle &lt; Type, AxisOrder &gt; translotator::EulerAngle::axisRotation (\n    const Type &amp; angle\n) \n</code></pre></p> <p>static functions </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/EulerAngle.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1Matrix/","title":"Class translotator::Matrix","text":"<p>template &lt;size_t N, size_t M, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; Matrix</p> <p>Matrix class.More...</p> <ul> <li><code>#include &lt;Matrix.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::MatrixBase</p>"},{"location":"translotator/classtranslotator_1_1Matrix/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1Matrix/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::MATRIX"},{"location":"translotator/classtranslotator_1_1Matrix/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1Matrix/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1Matrix/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1Matrix/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1Matrix/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>N</code> Number of rows </li> <li><code>M</code> Number of columns </li> <li><code>Type</code> Data type of the matrix</li> </ul> <p>This class is a matrix class that inherits the MatrixBase class. </p> <p>Note:</p> <p>Data Structure : [data], (N x M) </p>"},{"location":"translotator/classtranslotator_1_1Matrix/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1Matrix/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::Matrix&lt; N, M, Type &gt;::OBJECT_TYPE;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/Matrix.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/","title":"Class translotator::MatrixBase","text":"<p>template &lt;size_t N, size_t M, typename Type, typename Derived&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBase</p> <p>Base class for all matrix objects. More...</p> <ul> <li><code>#include &lt;MatrixBase.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: translotator::Vector</p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-types","title":"Public Types","text":"Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-functions","title":"Public Functions","text":"Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-static-functions","title":"Public Static Functions","text":"Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1MatrixBase/#protected-attributes","title":"Protected Attributes","text":"Type Name Type data_"},{"location":"translotator/classtranslotator_1_1MatrixBase/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>N</code> Number of rows </li> <li><code>M</code> Number of columns </li> <li><code>Type</code> Data type of the matrix </li> <li><code>Derived</code> Derived class, CRTP </li> </ul> <p>Note:</p> <p>This class is not meant to be used directly, use other matrix-based object classes instead.</p> <p>This class provides basic matrix operations and functionalities. </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/classtranslotator_1_1MatrixBase/#typedef-datatype","title":"typedef DATATYPE","text":"<pre><code>using translotator::MatrixBase&lt; N, M, Type, Derived &gt;::DATATYPE =  Type;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1MatrixBase/#variable-cols","title":"variable COLS","text":"<pre><code>constexpr static size_t translotator::MatrixBase&lt; N, M, Type, Derived &gt;::COLS;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#variable-matrix_base","title":"variable MATRIX_BASE","text":"<pre><code>constexpr static bool translotator::MatrixBase&lt; N, M, Type, Derived &gt;::MATRIX_BASE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#variable-rows","title":"variable ROWS","text":"<pre><code>constexpr static size_t translotator::MatrixBase&lt; N, M, Type, Derived &gt;::ROWS;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-matrixbase-15","title":"function MatrixBase [1/5]","text":"<p>Returns the number of columns. <pre><code>translotator::MatrixBase::MatrixBase () = default\n</code></pre></p> <p>Constructors and destructor </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-matrixbase-25","title":"function MatrixBase [2/5]","text":"<pre><code>explicit translotator::MatrixBase::MatrixBase (\n    const MatrixBase &amp; other\n) = default\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-matrixbase-35","title":"function MatrixBase [3/5]","text":"<pre><code>inline explicit translotator::MatrixBase::MatrixBase (\n    const Type data\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-matrixbase-45","title":"function MatrixBase [4/5]","text":"<pre><code>inline explicit translotator::MatrixBase::MatrixBase (\n    const Type data\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-matrixbase-55","title":"function MatrixBase [5/5]","text":"<pre><code>inline explicit translotator::MatrixBase::MatrixBase (\n    const initializer_list &lt; N *M, Type &gt; &amp; list\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-t","title":"function T","text":"<p>Transpose. <pre><code>inline auto translotator::MatrixBase::T () const\n</code></pre></p> <p>Utils </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-block-12","title":"function block [1/2]","text":"<p>Returns a block of the matrix. <pre><code>template&lt;size_t P, size_t Q&gt;\ninline Matrix &lt; P, Q, Type &gt; translotator::MatrixBase::block (\n    size_t i,\n    size_t j\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>P</code> Number of rows in the block </li> <li><code>Q</code> Number of columns in the block </li> </ul> <p>Parameters:</p> <ul> <li><code>i</code> Starting row index </li> <li><code>j</code> Starting column index </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-block-22","title":"function block [2/2]","text":"<p>Returns a block of the matrix. <pre><code>template&lt;size_t i, size_t j, size_t P, size_t Q&gt;\ninline Matrix &lt; P, Q, Type &gt; translotator::MatrixBase::block () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>i</code> Starting row index </li> <li><code>j</code> Starting column index </li> <li><code>P</code> Number of rows in the block </li> <li><code>Q</code> Number of columns in the block </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2complexnum","title":"function cast2ComplexNum","text":"<p>Casts the object to a complex number by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline ComplexNum &lt; Type &gt; translotator::MatrixBase::cast2ComplexNum () const\n</code></pre></p> <p>Returns:</p> <p>Complex number object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;ComplexNum&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2complexnumref","title":"function cast2ComplexNumRef","text":"<p>Casts the object to a complex number reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline ComplexNum &lt; Type &gt; &amp; translotator::MatrixBase::cast2ComplexNumRef () \n</code></pre></p> <p>Returns:</p> <p>Complex number object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;ComplexNum&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2dualnumber","title":"function cast2DualNumber","text":"<p>Casts the object to a dual number by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline DualNumber &lt; Type &gt; translotator::MatrixBase::cast2DualNumber () const\n</code></pre></p> <p>Returns:</p> <p>Dual number object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;DualNumber&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2dualnumberref","title":"function cast2DualNumberRef","text":"<p>Casts the object to a dual number reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline DualNumber &lt; Type &gt; &amp; translotator::MatrixBase::cast2DualNumberRef () \n</code></pre></p> <p>Returns:</p> <p>Dual number object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;DualNumber&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2dualquaternion","title":"function cast2DualQuaternion","text":"<p>Casts the object to a dual quaternion by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline DualQuaternion &lt; Type &gt; translotator::MatrixBase::cast2DualQuaternion () const\n</code></pre></p> <p>Returns:</p> <p>Dual quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 8 x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;DualQuaternion&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2dualquaternionref","title":"function cast2DualQuaternionRef","text":"<p>Casts the object to a dual quaternion reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline DualQuaternion &lt; Type &gt; &amp; translotator::MatrixBase::cast2DualQuaternionRef () \n</code></pre></p> <p>Returns:</p> <p>Dual quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 8 x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;DualQuaternion&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2matrix","title":"function cast2Matrix","text":"<p>Casts the object to a different matrix type by copying. <pre><code>inline Matrix &lt; N, M, Type &gt; translotator::MatrixBase::cast2Matrix () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NewContainer</code> New matrix type </li> </ul> <p>Returns:</p> <p>Matrix object with same dimensions and data type </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;Matrix&lt;N, M, Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2matrixref","title":"function cast2MatrixRef","text":"<p>Casts the object to a matrix reference without copying. <pre><code>inline Matrix &lt; N, M, Type &gt; &amp; translotator::MatrixBase::cast2MatrixRef () \n</code></pre></p> <p>Returns:</p> <p>Matrix object with same dimensions and data type </p> <p>Note:</p> <p>This function is only available for N x M dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;Matrix&lt;N, M, Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2quaternion","title":"function cast2Quaternion","text":"<p>Casts the object to a quaternion by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline Quaternion &lt; Type &gt; translotator::MatrixBase::cast2Quaternion () const\n</code></pre></p> <p>Returns:</p> <p>Quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 4 x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;Quaternion&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2quaternionref","title":"function cast2QuaternionRef","text":"<p>Casts the object to a quaternion reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline Quaternion &lt; Type &gt; &amp; translotator::MatrixBase::cast2QuaternionRef () \n</code></pre></p> <p>Returns:</p> <p>Quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 4 x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;Quaternion&lt;Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2sogroup","title":"function cast2SOGroup","text":"<p>Casts the object to a special orthogonal group by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline SOGroup &lt; N, Type &gt; translotator::MatrixBase::cast2SOGroup () const\n</code></pre></p> <p>Returns:</p> <p>SOGroup object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 2 or 3 x 3 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;SOGroup&lt;N, Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a special orthogonal group, the output will be normalized to be a special orthogonal group </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2sogroupref","title":"function cast2SOGroupRef","text":"<p>Casts the object to a special orthogonal group reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline SOGroup &lt; N, Type &gt; &amp; translotator::MatrixBase::cast2SOGroupRef () \n</code></pre></p> <p>Returns:</p> <p>SOGroup object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 2 or 3 x 3 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;SOGroup&lt;N, Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a special orthogonal group, the output &amp; original object will be normalized to be a special orthogonal group </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2squarematrix","title":"function cast2SquareMatrix","text":"<p>Casts the object to a square matrix by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline SquareMatrix &lt; N, Type &gt; translotator::MatrixBase::cast2SquareMatrix () const\n</code></pre></p> <p>Returns:</p> <p>Square matrix object with same dimensions and data type </p> <p>Note:</p> <p>This function is only available for N x N dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;SquareMatrix&lt;N, Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2squarematrixref","title":"function cast2SquareMatrixRef","text":"<p>Casts the object to a square matrix reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline SquareMatrix &lt; N, Type &gt; &amp; translotator::MatrixBase::cast2SquareMatrixRef () \n</code></pre></p> <p>Returns:</p> <p>Square matrix object with same dimensions and data type </p> <p>Note:</p> <p>This function is only available for N x N dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;SquareMatrix&lt;N, Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2unitcomplexnum","title":"function cast2UnitComplexNum","text":"<p>Casts the object to a unit complex number by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline UnitComplexNum &lt; Type &gt; translotator::MatrixBase::cast2UnitComplexNum () const\n</code></pre></p> <p>Returns:</p> <p>Unit complex number object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;UnitComplexNum&lt;Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a unit complex number, the output will be normalized to be a unit complex number </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2unitcomplexnumref","title":"function cast2UnitComplexNumRef","text":"<p>Casts the object to a unit complex number reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline UnitComplexNum &lt; Type &gt; &amp; translotator::MatrixBase::cast2UnitComplexNumRef () \n</code></pre></p> <p>Returns:</p> <p>Unit complex number object with same data type </p> <p>Note:</p> <p>This function is only available for 2 x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;UnitComplexNum&lt;Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a unit complex number, the output &amp; original object will be normalized to be a unit complex number </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2unitdualquaternion","title":"function cast2UnitDualQuaternion","text":"<p>Casts the object to a unit dual quaternion by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline UnitDualQuaternion &lt; Type &gt; translotator::MatrixBase::cast2UnitDualQuaternion () const\n</code></pre></p> <p>Returns:</p> <p>Unit dual quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 8 x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;UnitDualQuaternion&lt;Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a unit dual quaternion, the output will be normalized to be a unit dual quaternion </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2unitdualquaternionref","title":"function cast2UnitDualQuaternionRef","text":"<p>Casts the object to a unit dual quaternion reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline UnitDualQuaternion &lt; Type &gt; &amp; translotator::MatrixBase::cast2UnitDualQuaternionRef () \n</code></pre></p> <p>Returns:</p> <p>Unit dual quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 8 x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;UnitDualQuaternion&lt;Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a unit dual quaternion, the output &amp; original object will be normalized to be a unit dual quaternion </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2unitquaternion","title":"function cast2UnitQuaternion","text":"<p>Casts the object to a unit quaternion by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline UnitQuaternion &lt; Type &gt; translotator::MatrixBase::cast2UnitQuaternion () const\n</code></pre></p> <p>Returns:</p> <p>Unit quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 4 x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;UnitQuaternion&lt;Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a unit quaternion, the output will be normalized to be a unit quaternion </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2unitquaternionref","title":"function cast2UnitQuaternionRef","text":"<p>Casts the object to a unit quaternion reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline UnitQuaternion &lt; Type &gt; &amp; translotator::MatrixBase::cast2UnitQuaternionRef () \n</code></pre></p> <p>Returns:</p> <p>Unit quaternion object with same data type </p> <p>Note:</p> <p>This function is only available for 4 x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;UnitQuaternion&lt;Type&gt;&gt;() function </p> <p>Note:</p> <p>If the input is not a unit quaternion, the output &amp; original object will be normalized to be a unit quaternion </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2vector","title":"function cast2Vector","text":"<p>Casts the object to a vector by copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline Vector &lt; N, Type &gt; translotator::MatrixBase::cast2Vector () const\n</code></pre></p> <p>Returns:</p> <p>Vector object with same dimensions and data type </p> <p>Note:</p> <p>This function is only available for M x 1 dimensions </p> <p>Note:</p> <p>This functions is alias of castContainer&lt;Vector&lt;N, Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-cast2vectorref","title":"function cast2VectorRef","text":"<p>Casts the object to a vector reference without copying. <pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline Vector &lt; N, Type &gt; &amp; translotator::MatrixBase::cast2VectorRef () \n</code></pre></p> <p>Returns:</p> <p>Vector object with same dimensions and data type </p> <p>Note:</p> <p>This function is only available for M x 1 dimensions. Not recommended for temporary objects. </p> <p>Note:</p> <p>This function is alias of castContainerRef&lt;Vector&lt;N, Type&gt;&gt;() function </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-castcontainer","title":"function castContainer","text":"<p>Casts the matrix to a different container type by copying. <pre><code>template&lt;typename NewContainer&gt;\ninline NewContainer translotator::MatrixBase::castContainer () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NewContainer</code> New container type</li> </ul> <p>This function is only available for containers with the same size as the matrix </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-castcontainerref-12","title":"function castContainerRef [1/2]","text":"<p>Casts the object to a different container reference without copying. <pre><code>template&lt;typename NewContainer&gt;\ninline NewContainer &amp; translotator::MatrixBase::castContainerRef () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NewContainer</code> New container type</li> </ul> <p>This function is only available for containers with the same size as the matrix </p> <p>Note:</p> <p>This function is recommended for temporary objects. Use castContainer() and alias functions for permanent objects. </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-castcontainerref-22","title":"function castContainerRef [2/2]","text":"<pre><code>template&lt;typename NewDerived&gt;\ninline NewDerived &amp; translotator::MatrixBase::castContainerRef () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-castdatatype","title":"function castDataType","text":"<p>Returns the Frobenius norm. <pre><code>template&lt;typename NewType&gt;\ninline auto translotator::MatrixBase::castDataType () const\n</code></pre></p> <p>Type Casting</p> <p>Casts the matrix to a different data type </p> <p>Template parameters:</p> <ul> <li><code>NewType</code> New data type</li> </ul> <p>This function is only available for floating point types </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-col","title":"function col","text":"<pre><code>inline Matrix &lt; N, 1, Type &gt; translotator::MatrixBase::col (\n    size_t j\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-copyto","title":"function copyTo","text":"<pre><code>inline void translotator::MatrixBase::copyTo (\n    Type * data\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-fill","title":"function fill","text":"<pre><code>inline void translotator::MatrixBase::fill (\n    const Type &amp; v\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-frobeniusnorm","title":"function frobeniusNorm","text":"<pre><code>inline Type translotator::MatrixBase::frobeniusNorm () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-frobeniusnormsquared","title":"function frobeniusNormSquared","text":"<pre><code>inline Type translotator::MatrixBase::frobeniusNormSquared () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-getdata","title":"function getData","text":"<pre><code>inline Type * translotator::MatrixBase::getData () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator-12","title":"function operator() [1/2]","text":"<p>Accesses the element at (i, j) <pre><code>inline const Type &amp; translotator::MatrixBase::operator() (\n    size_t i,\n    size_t j\n) const\n</code></pre></p> <p>Accessors </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator-22","title":"function operator() [2/2]","text":"<pre><code>inline Type &amp; translotator::MatrixBase::operator() (\n    size_t i,\n    size_t j\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator","title":"function operator*","text":"<p>Matrix multiplication. <pre><code>template&lt;typename OtherDerived&gt;\ninline auto translotator::MatrixBase::operator* (\n    const OtherDerived &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherDerived</code> Matrix Derived class to multiply </li> </ul> <p>Parameters:</p> <ul> <li><code>other</code> Matrix Derived class to multiply </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator_1","title":"function operator*","text":"<p>Matrix multiplication by scalar. <pre><code>inline Derived translotator::MatrixBase::operator* (\n    const Type &amp; v\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> Scalar value</li> </ul> <p>Multiplies the matrix by a scalar value </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator_2","title":"function operator*=","text":"<p>Matrix multiplication by scalar. <pre><code>template&lt;typename OtherDerived&gt;\ninline void translotator::MatrixBase::operator*= (\n    const OtherDerived &amp; other\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> Scalar value</li> </ul> <p>Multiplies the matrix by a scalar value </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator_3","title":"function operator+","text":"<p>Multiplication by scalar. <pre><code>template&lt;typename OtherDerived&gt;\ninline Derived translotator::MatrixBase::operator+ (\n    const OtherDerived &amp; other\n) const\n</code></pre></p> <p>Operator Objects</p> <p>Matrix addition </p> <p>Template parameters:</p> <ul> <li><code>OtherDerived</code> Matrix Derived class to add </li> </ul> <p>Parameters:</p> <ul> <li><code>other</code> Matrix Derived class to add </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator_4","title":"function operator+=","text":"<p>Matrix division by scalar. <pre><code>template&lt;typename OtherDerived&gt;\ninline void translotator::MatrixBase::operator+= (\n    const OtherDerived &amp; other\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> Scalar value</li> </ul> <p>Divides the matrix by a scalar value </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator-","title":"function operator-","text":"<p>Matrix subtraction. <pre><code>template&lt;typename OtherDerived&gt;\ninline Derived translotator::MatrixBase::operator- (\n    const OtherDerived &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherDerived</code> Matrix Derived class to subtract </li> </ul> <p>Parameters:</p> <ul> <li><code>other</code> Matrix Derived class to subtract </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator-_1","title":"function operator-","text":"<p>Matrix multiplication by scalar. <pre><code>inline Derived translotator::MatrixBase::operator- () const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> Scalar value</li> </ul> <p>Multiplies the matrix by a scalar value </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator-_2","title":"function operator-=","text":"<p>Matrix subtraction by scalar. <pre><code>template&lt;typename OtherDerived&gt;\ninline void translotator::MatrixBase::operator-= (\n    const OtherDerived &amp; other\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>v</code> Scalar value</li> </ul> <p>Subtracts the matrix by a scalar value </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator_5","title":"function operator/","text":"<p>Division by scalar. <pre><code>inline Derived translotator::MatrixBase::operator/ (\n    Type v\n) const\n</code></pre></p> <p>operators Scalar </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator_6","title":"function operator/=","text":"<pre><code>inline void translotator::MatrixBase::operator/= (\n    Type v\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-operator_7","title":"function operator=","text":"<p>Copies the data to the given pointer. <pre><code>inline Derived &amp; translotator::MatrixBase::operator= (\n    const Derived &amp; other\n) \n</code></pre></p> <p>Assignments Copy assignment </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-print","title":"function print","text":"<pre><code>inline void translotator::MatrixBase::print () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-row","title":"function row","text":"<pre><code>inline Matrix &lt; 1, M, Type &gt; translotator::MatrixBase::row (\n    size_t i\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-setblock-12","title":"function setBlock [1/2]","text":"<p>Sets the element at (i, j) <pre><code>template&lt;typename OtherDerived&gt;\ninline Derived &amp; translotator::MatrixBase::setBlock (\n    size_t i,\n    size_t j,\n    const OtherDerived &amp; block\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>i</code> Row index </li> <li><code>j</code> Column index </li> </ul> <p>Template parameters:</p> <ul> <li><code>OtherDerived</code> Matrix Derived class to set the element from </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-setblock-22","title":"function setBlock [2/2]","text":"<p>Sets the i-th row. <pre><code>template&lt;size_t i, size_t j, typename OtherDerived&gt;\ninline Derived &amp; translotator::MatrixBase::setBlock (\n    const OtherDerived &amp; block\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>i</code> Row index </li> <li><code>j</code> Column index </li> <li><code>OtherDerived</code> Matrix Derived class to set the row from</li> </ul> <p>This function is a compile-time version of setRow </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-setcol-12","title":"function setCol [1/2]","text":"<p>Sets the j-th column. <pre><code>template&lt;typename OtherDerived&gt;\ninline Derived &amp; translotator::MatrixBase::setCol (\n    size_t j,\n    const OtherDerived &amp; col\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>j</code> Column index </li> </ul> <p>Template parameters:</p> <ul> <li><code>OtherDerived</code> Matrix Derived class to set the column from </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-setcol-22","title":"function setCol [2/2]","text":"<p>Sets the j-th column. <pre><code>template&lt;size_t j, typename OtherDerived&gt;\ninline Derived &amp; translotator::MatrixBase::setCol (\n    const OtherDerived &amp; col\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>j</code> Column index </li> <li><code>OtherDerived</code> Matrix Derived class to set the column from</li> </ul> <p>This function is a compile-time version of setCol </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-setrow-12","title":"function setRow [1/2]","text":"<p>Sets the i-th row. <pre><code>template&lt;typename OtherDerived&gt;\ninline Derived &amp; translotator::MatrixBase::setRow (\n    size_t i,\n    const OtherDerived &amp; row\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>i</code> Row index </li> </ul> <p>Template parameters:</p> <ul> <li><code>OtherDerived</code> Matrix Derived class to set the row from </li> </ul>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-setrow-22","title":"function setRow [2/2]","text":"<p>Sets the i-th row. <pre><code>template&lt;size_t i, typename OtherDerived&gt;\ninline Derived &amp; translotator::MatrixBase::setRow (\n    const OtherDerived &amp; row\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>i</code> Row index </li> <li><code>OtherDerived</code> Matrix Derived class to set the row from</li> </ul> <p>This function is a compile-time version of setRow </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-swapcols","title":"function swapCols","text":"<pre><code>inline void translotator::MatrixBase::swapCols (\n    size_t j1,\n    size_t j2\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-swaprows","title":"function swapRows","text":"<pre><code>inline void translotator::MatrixBase::swapRows (\n    size_t i1,\n    size_t i2\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-toscalar","title":"function toScalar","text":"<pre><code>template&lt;size_t N_, size_t M_, typename&gt;\ninline Type translotator::MatrixBase::toScalar () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-nan","title":"function NaN","text":"<pre><code>static inline Derived translotator::MatrixBase::NaN () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-colsize","title":"function colSize","text":"<pre><code>static inline constexpr static size_t translotator::MatrixBase::colSize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-eye","title":"function eye","text":"<p>Returns an identity matrix. <pre><code>static inline Derived translotator::MatrixBase::eye () \n</code></pre></p> <p>Constant Matrices </p>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-ones","title":"function ones","text":"<pre><code>static inline Derived translotator::MatrixBase::ones () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-rowsize","title":"function rowSize","text":"<pre><code>static inline constexpr static size_t translotator::MatrixBase::rowSize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#function-zeros","title":"function zeros","text":"<pre><code>static inline Derived translotator::MatrixBase::zeros () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1MatrixBase/#variable-data_","title":"variable data_","text":"<pre><code>Type translotator::MatrixBase&lt; N, M, Type, Derived &gt;::data_[N *M];\n</code></pre>"},{"location":"translotator/classtranslotator_1_1MatrixBase/#friends-documentation","title":"Friends Documentation","text":""},{"location":"translotator/classtranslotator_1_1MatrixBase/#friend-operator","title":"friend operator*","text":"<pre><code>inline Derived translotator::MatrixBase::operator* (\n    Type lhs,\n    const Derived &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBase.hpp</code></p>"},{"location":"translotator/namespacetranslotator_1_1MatrixBaseInternal/","title":"Namespace translotator::MatrixBaseInternal","text":"<p>Namespace List &gt; translotator &gt; MatrixBaseInternal</p> <p>Internal namespace for MatrixBase implementation.More...</p>"},{"location":"translotator/namespacetranslotator_1_1MatrixBaseInternal/#classes","title":"Classes","text":"Type Name struct operator_cast_typemapper &lt;typename Derived, typename NewType&gt; struct operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt; &lt;typename NewType, N, M, typename Type&gt; struct operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt; &lt;typename NewType, N, typename Type&gt; struct operator_mul_typemapper &lt;typename Derived, typename OtherDerived, typename Enable&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt;"},{"location":"translotator/namespacetranslotator_1_1MatrixBaseInternal/#detailed-description","title":"Detailed Description","text":"<p>Warning:</p> <p>This namespace is for internal use only. Do not use this namespace directly. </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper/","title":"Struct translotator::MatrixBaseInternal::operator_cast_typemapper","text":"<p>template &lt;typename Derived, typename NewType&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_cast_typemapper</p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Matrix_3_01N_00_01M_00_01Type_01_4_00_01NewType_01_4/","title":"Struct translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt;","text":"<p>template &lt;typename NewType, size_t N, size_t M, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt;</p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Matrix_3_01N_00_01M_00_01Type_01_4_00_01NewType_01_4/#public-types","title":"Public Types","text":"Type Name typedef Matrix&lt; N, M, NewType &gt; type"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Matrix_3_01N_00_01M_00_01Type_01_4_00_01NewType_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Matrix_3_01N_00_01M_00_01Type_01_4_00_01NewType_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt;::type =  Matrix&lt;N, M, NewType&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Vector_3_01N_00_01Type_01_4_00_01NewType_01_4/","title":"Struct translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt;","text":"<p>template &lt;typename NewType, size_t N, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt;</p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Vector_3_01N_00_01Type_01_4_00_01NewType_01_4/#public-types","title":"Public Types","text":"Type Name typedef Vector&lt; N, NewType &gt; type"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Vector_3_01N_00_01Type_01_4_00_01NewType_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__cast__typemapper_3_01Vector_3_01N_00_01Type_01_4_00_01NewType_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt;::type =  Vector&lt;N, NewType&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper/","title":"Struct translotator::MatrixBaseInternal::operator_mul_typemapper","text":"<p>template &lt;typename Derived, typename OtherDerived, typename Enable&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_mul_typemapper</p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri1b96ed4aed79df1e494374b57efb0a1d/","title":"Struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;","text":"<p>template &lt;typename Derived, typename OtherDerived&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;</p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri1b96ed4aed79df1e494374b57efb0a1d/#public-types","title":"Public Types","text":"Type Name typedef Vector&lt; Derived::ROWS, typename Derived::DATATYPE &gt; type"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri1b96ed4aed79df1e494374b57efb0a1d/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri1b96ed4aed79df1e494374b57efb0a1d/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;::type =  Vector&lt;Derived::ROWS, typename Derived::DATATYPE&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri2a96eb5bfa413dff0cddca3d951d6a71/","title":"Struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;","text":"<p>template &lt;typename Derived, typename OtherDerived&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;</p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri2a96eb5bfa413dff0cddca3d951d6a71/#public-types","title":"Public Types","text":"Type Name typedef Matrix&lt; Derived::ROWS, OtherDerived::COLS, typename Derived::DATATYPE &gt; type"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri2a96eb5bfa413dff0cddca3d951d6a71/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri2a96eb5bfa413dff0cddca3d951d6a71/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;::type =  Matrix&lt;Derived::ROWS, OtherDerived::COLS, typename Derived::DATATYPE&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri96d299f5dadca2759194ea845be7ed5c/","title":"Struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;","text":"<p>template &lt;typename Derived, typename OtherDerived&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;</p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri96d299f5dadca2759194ea845be7ed5c/#public-types","title":"Public Types","text":"Type Name typedef typename Derived::DATATYPE type"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri96d299f5dadca2759194ea845be7ed5c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri96d299f5dadca2759194ea845be7ed5c/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;::type =  typename Derived::DATATYPE;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri416034dcdebb2206f870a9ec06949246/","title":"Struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;","text":"<p>template &lt;typename Derived, typename OtherDerived&gt;</p> <p>ClassList &gt; translotator &gt; MatrixBaseInternal &gt; operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;</p>"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri416034dcdebb2206f870a9ec06949246/#public-types","title":"Public Types","text":"Type Name typedef SquareMatrix&lt; Derived::ROWS, typename Derived::DATATYPE &gt; type"},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri416034dcdebb2206f870a9ec06949246/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1MatrixBaseInternal_1_1operator__mul__typemapper_3_01Derived_00_01OtherDeri416034dcdebb2206f870a9ec06949246/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;::type =  SquareMatrix&lt;Derived::ROWS, typename Derived::DATATYPE&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1Quaternion/","title":"Class translotator::Quaternion","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; Quaternion</p> <p>Representing a quaternion. More...</p> <ul> <li><code>#include &lt;Quaternion.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::MatrixBase</p>"},{"location":"translotator/classtranslotator_1_1Quaternion/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1Quaternion/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::QUATERNION"},{"location":"translotator/classtranslotator_1_1Quaternion/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1Quaternion/#public-functions","title":"Public Functions","text":"Type Name const Vector&lt; 3, Type &gt; Im () const Vector&lt; 3, Type &gt; &amp; Im ()  Quaternion ()  Quaternion (Type w, Type x, Type y, Type z)  Quaternion (Type w, const Vector&lt; 3, Type &gt; &amp; v)  Quaternion (const ComplexNum&lt; Type &gt; &amp; cplx)  const Type Re () const Type &amp; Re ()  void canonicalize ()  Quaternion&lt; Type &gt; canonicalized () constnormalize the quaternion void conjugate () get the conjugated quaternion Quaternion&lt; Type &gt; conjugated () constcanonicalize the quaternion void inverse () get the inversed quaternion Quaternion&lt; Type &gt; inversed () constconjugate the quaternion Type norm () constget the squared norm of the quaternion Type normSquared () const void normalize () get the normalized quaternion Quaternion&lt; Type &gt; normalized () constget the norm of the quaternion Quaternion&lt; Type &gt; operator* (const Quaternion&lt; Type &gt; &amp; q) constquaternion multiplication void operator*= (const Quaternion&lt; Type &gt; &amp; q) quaternion division Quaternion&lt; Type &gt; operator/ (const Quaternion&lt; Type &gt; &amp; q) const void operator/= (const Quaternion&lt; Type &gt; &amp; q) quaternion multiplication Type operator[] (size_t i) const Type &amp; operator[] (size_t i)  Quaternion&lt; Type &gt; quatNumDiv (const Quaternion&lt; Type &gt; &amp; q) const void quatNumDivEq (const Quaternion&lt; Type &gt; &amp; q)  Quaternion&lt; Type &gt; quatNumMul (const Quaternion&lt; Type &gt; &amp; q) constquaternion division void quatNumMulEq (const Quaternion&lt; Type &gt; &amp; q)  SquareMatrix&lt; 4, Type &gt; toMulMatrix () constget the matrix that represents the quaternion multiplication SquareMatrix&lt; 4, Type &gt; toRightMulMatrix () constget the matrix that represents the quaternion multiplication from the right Type w () const Type &amp; w ()  Type x () const Type &amp; x ()  Type y () const Type &amp; y ()  Type z () const Type &amp; z ()"},{"location":"translotator/classtranslotator_1_1Quaternion/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1Quaternion/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1Quaternion/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1Quaternion/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> floating point type</li> </ul> <p>A quaternion is a hypercomplex number that extends the complex numbers. It can be represented as a 4-dimensional vector. The quaternion is defined as q = w + xi + yj + zk, where w, x, y, and z are real numbers, and i, j, and k are the fundamental quaternion units. The quaternion has the following properties: i^2 = j^2 = k^2 = ijk = -1. (Hamillton representation) This can be used to represent rotations in 3D space. Also can be used to represent rotations in 3D space. </p>"},{"location":"translotator/classtranslotator_1_1Quaternion/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1Quaternion/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::Quaternion&lt; Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1Quaternion/#function-im-12","title":"function Im [1/2]","text":"<pre><code>inline const Vector &lt; 3, Type &gt; translotator::Quaternion::Im () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-im-22","title":"function Im [2/2]","text":"<pre><code>inline Vector &lt; 3, Type &gt; &amp; translotator::Quaternion::Im () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quaternion-14","title":"function Quaternion [1/4]","text":"<pre><code>inline translotator::Quaternion::Quaternion () \n</code></pre> <p>constructors </p>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quaternion-24","title":"function Quaternion [2/4]","text":"<pre><code>inline explicit translotator::Quaternion::Quaternion (\n    Type w,\n    Type x,\n    Type y,\n    Type z\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quaternion-34","title":"function Quaternion [3/4]","text":"<pre><code>inline explicit translotator::Quaternion::Quaternion (\n    Type w,\n    const Vector &lt; 3, Type &gt; &amp; v\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quaternion-44","title":"function Quaternion [4/4]","text":"<pre><code>inline explicit translotator::Quaternion::Quaternion (\n    const ComplexNum &lt; Type &gt; &amp; cplx\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-re-12","title":"function Re [1/2]","text":"<pre><code>inline const Type translotator::Quaternion::Re () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-re-22","title":"function Re [2/2]","text":"<pre><code>inline Type &amp; translotator::Quaternion::Re () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-canonicalize","title":"function canonicalize","text":"<pre><code>inline void translotator::Quaternion::canonicalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-canonicalized","title":"function canonicalized","text":"<p>normalize the quaternion <pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::canonicalized () const\n</code></pre></p> <p>get the canonicalized quaternion </p>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-conjugate","title":"function conjugate","text":"<pre><code>inline void translotator::Quaternion::conjugate () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-conjugated","title":"function conjugated","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::conjugated () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::Quaternion::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-inversed","title":"function inversed","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-norm","title":"function norm","text":"<pre><code>inline Type translotator::Quaternion::norm () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-normsquared","title":"function normSquared","text":"<pre><code>inline Type translotator::Quaternion::normSquared () const\n</code></pre> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-normalize","title":"function normalize","text":"<pre><code>inline void translotator::Quaternion::normalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-normalized","title":"function normalized","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::normalized () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-operator","title":"function operator*","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::operator* (\n    const Quaternion &lt; Type &gt; &amp; q\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::Quaternion::operator*= (\n    const Quaternion &lt; Type &gt; &amp; q\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-operator_2","title":"function operator/","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::operator/ (\n    const Quaternion &lt; Type &gt; &amp; q\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-operator_3","title":"function operator/=","text":"<pre><code>inline void translotator::Quaternion::operator/= (\n    const Quaternion &lt; Type &gt; &amp; q\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-operator_4","title":"function operator[]","text":"<pre><code>inline Type translotator::Quaternion::operator[] (\n    size_t i\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-operator_5","title":"function operator[]","text":"<pre><code>inline Type &amp; translotator::Quaternion::operator[] (\n    size_t i\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quatnumdiv","title":"function quatNumDiv","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::quatNumDiv (\n    const Quaternion &lt; Type &gt; &amp; q\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quatnumdiveq","title":"function quatNumDivEq","text":"<pre><code>inline void translotator::Quaternion::quatNumDivEq (\n    const Quaternion &lt; Type &gt; &amp; q\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quatnummul","title":"function quatNumMul","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::Quaternion::quatNumMul (\n    const Quaternion &lt; Type &gt; &amp; q\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-quatnummuleq","title":"function quatNumMulEq","text":"<pre><code>inline void translotator::Quaternion::quatNumMulEq (\n    const Quaternion &lt; Type &gt; &amp; q\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-tomulmatrix","title":"function toMulMatrix","text":"<p>get the matrix that represents the quaternion multiplication <pre><code>inline SquareMatrix &lt; 4, Type &gt; translotator::Quaternion::toMulMatrix () const\n</code></pre></p> <p>casting </p>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-torightmulmatrix","title":"function toRightMulMatrix","text":"<pre><code>inline SquareMatrix &lt; 4, Type &gt; translotator::Quaternion::toRightMulMatrix () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-w-12","title":"function w [1/2]","text":"<pre><code>inline Type translotator::Quaternion::w () const\n</code></pre> <p>accessors </p>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-w-22","title":"function w [2/2]","text":"<pre><code>inline Type &amp; translotator::Quaternion::w () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-x-12","title":"function x [1/2]","text":"<pre><code>inline Type translotator::Quaternion::x () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-x-22","title":"function x [2/2]","text":"<pre><code>inline Type &amp; translotator::Quaternion::x () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-y-12","title":"function y [1/2]","text":"<pre><code>inline Type translotator::Quaternion::y () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-y-22","title":"function y [2/2]","text":"<pre><code>inline Type &amp; translotator::Quaternion::y () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-z-12","title":"function z [1/2]","text":"<pre><code>inline Type translotator::Quaternion::z () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Quaternion/#function-z-22","title":"function z [2/2]","text":"<pre><code>inline Type &amp; translotator::Quaternion::z () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/Quaternion.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1SEGroup/","title":"Class translotator::SEGroup","text":"<p>template &lt;size_t N, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; SEGroup</p> <p>Special Euclidean Group. More...</p> <ul> <li><code>#include &lt;SEGroup.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-types","title":"Public Types","text":"Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::SE_GROUP"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-functions","title":"Public Functions","text":"Type Name SEGroup () = default SEGroup (const SOGroup&lt; N, Type &gt; &amp; rotation, const Vector&lt; N, Type &gt; &amp; translation)  SEGroup (const SquareMatrix&lt; N+1, Type &gt; &amp; matrix)  Vector&lt; N, Type &gt; actOnVector (const Vector&lt; N, Type &gt; &amp; vec) constact on vector SEGroup&lt; N, Type &gt; inversed () constinverse SEGroup&lt; N, Type &gt; operator* (const SEGroup&lt; N, Type &gt; &amp; other) constSEGroup *SEGroup . SEGroup&lt; N, Type &gt; operator/ (const SEGroup&lt; N, Type &gt; &amp; other) constSEGroup /SEGroup . SEGroup&lt; N, Type &gt; pow (const Type &amp; t) constpower void print () constprint SOGroup&lt; N, Type &gt; rotation () const SOGroup&lt; N, Type &gt; &amp; rotation ()  SquareMatrix&lt; N+1, Type &gt; toSquareMatrix () constto square matrix Vector&lt; N, Type &gt; translation () const Vector&lt; N, Type &gt; &amp; translation ()  ~SEGroup () = default"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-static-functions","title":"Public Static Functions","text":"Type Name SEGroup&lt; N, Type &gt; identity () identity"},{"location":"translotator/classtranslotator_1_1SEGroup/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>N</code> dimension </li> <li><code>Type</code> data type</li> </ul> <p>Special Euclidean Group is a group of rigid body transformation in N dimension. It is a combination of rotation and translation. Subgroup of SEGroup is SOGroup and Translation. Also SEGroup is a Lie Group, which means it has a group structure and a smooth manifold structure. Exponential and Logarithm map can be defined. </p> <p>Note:</p> <p>Not a Matrix based implementation. Just a composition of SOGroup and Translation each. </p>"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/classtranslotator_1_1SEGroup/#typedef-datatype","title":"typedef DATATYPE","text":"<pre><code>using translotator::SEGroup&lt; N, Type &gt;::DATATYPE =  Type;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1SEGroup/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::SEGroup&lt; N, Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1SEGroup/#function-segroup-13","title":"function SEGroup [1/3]","text":"<pre><code>translotator::SEGroup::SEGroup () = default\n</code></pre> <p>constructor </p>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-segroup-23","title":"function SEGroup [2/3]","text":"<pre><code>inline translotator::SEGroup::SEGroup (\n    const SOGroup &lt; N, Type &gt; &amp; rotation,\n    const Vector &lt; N, Type &gt; &amp; translation\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-segroup-33","title":"function SEGroup [3/3]","text":"<pre><code>inline translotator::SEGroup::SEGroup (\n    const SquareMatrix &lt; N+1, Type &gt; &amp; matrix\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-actonvector","title":"function actOnVector","text":"<pre><code>inline Vector &lt; N, Type &gt; translotator::SEGroup::actOnVector (\n    const Vector &lt; N, Type &gt; &amp; vec\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-inversed","title":"function inversed","text":"<p>inverse <pre><code>inline SEGroup &lt; N, Type &gt; translotator::SEGroup::inversed () const\n</code></pre></p> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-operator","title":"function operator*","text":"<p>SEGroup *SEGroup . <pre><code>inline SEGroup &lt; N, Type &gt; translotator::SEGroup::operator* (\n    const SEGroup &lt; N, Type &gt; &amp; other\n) const\n</code></pre></p> <p>operator </p>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-operator_1","title":"function operator/","text":"<pre><code>inline SEGroup &lt; N, Type &gt; translotator::SEGroup::operator/ (\n    const SEGroup &lt; N, Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-pow","title":"function pow","text":"<pre><code>inline SEGroup &lt; N, Type &gt; translotator::SEGroup::pow (\n    const Type &amp; t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-print","title":"function print","text":"<pre><code>inline void translotator::SEGroup::print () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-rotation-12","title":"function rotation [1/2]","text":"<pre><code>inline SOGroup &lt; N, Type &gt; translotator::SEGroup::rotation () const\n</code></pre> <p>accessors </p>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-rotation-22","title":"function rotation [2/2]","text":"<pre><code>inline SOGroup &lt; N, Type &gt; &amp; translotator::SEGroup::rotation () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-tosquarematrix","title":"function toSquareMatrix","text":"<p>to square matrix <pre><code>inline SquareMatrix &lt; N+1, Type &gt; translotator::SEGroup::toSquareMatrix () const\n</code></pre></p> <p>casting </p>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-translation-12","title":"function translation [1/2]","text":"<pre><code>inline Vector &lt; N, Type &gt; translotator::SEGroup::translation () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-translation-22","title":"function translation [2/2]","text":"<pre><code>inline Vector &lt; N, Type &gt; &amp; translotator::SEGroup::translation () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#function-segroup","title":"function ~SEGroup","text":"<pre><code>translotator::SEGroup::~SEGroup () = default\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SEGroup/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1SEGroup/#function-identity","title":"function identity","text":"<p>identity <pre><code>static inline SEGroup &lt; N, Type &gt; translotator::SEGroup::identity () \n</code></pre></p> <p>static functions </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/SEGroup.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1SOGroup/","title":"Class translotator::SOGroup","text":"<p>template &lt;size_t N, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; SOGroup</p> <p>Special Orthogonal Group. More...</p> <ul> <li><code>#include &lt;SOGroup.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::SquareMatrix</p>"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::SO_GROUP"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-static-attributes-inherited-from-translotatorsquarematrix","title":"Public Static Attributes inherited from translotator::SquareMatrix","text":"<p>See translotator::SquareMatrix</p> Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::SQUARE_MATRIX"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-functions","title":"Public Functions","text":"Type Name SOGroup (const Vector&lt; N, Type &gt; &amp; vec1, const Vector&lt; N, Type &gt; &amp; vec2, bool col=true)  SOGroup (const Vector&lt; N, Type &gt; &amp; vec1, const Vector&lt; N, Type &gt; &amp; vec2, const Vector&lt; N, Type &gt; &amp; vec3, bool col=true)  SOGroup (const Type &amp; theta)  SOGroup (const Vector&lt; N, Type &gt; &amp; angleVector)  SOGroup&lt; N, Type &gt; T () consttranspose void inverse () inverse this matrix SOGroup&lt; N, Type &gt; inversed () constinverse is same as transpose in SOGroup __ void normalize () normalize this matrix SOGroup&lt; N, Type &gt; normalized () constGet the orthogonalized matrix. auto operator* (const OtherContainer &amp; other) constSOGroup *SOGroup =&gt;SOGroup . void operator*= (const SOGroup&lt; N, Type &gt; &amp; other) SOGroup *=SOGroup . SquareMatrix&lt; N, Type &gt; operator+ (const OtherContainer &amp; other) constSOGroup +SOGroup =&gt;SquareMatrix . SquareMatrix&lt; N, Type &gt; operator- (const OtherContainer &amp; other) constSOGroup -SOGroup =&gt;SquareMatrix . SOGroup&lt; N, Type &gt; operator- () const- SOGroup __ auto operator/ (const OtherContainer &amp; other) constSOGroup /SOGroup =&gt;SOGroup . SOGroup&lt; N, Type &gt; pow (const Type &amp; t) constpower of SOGroup . Using Exponential &amp; Logarithm Map of Lie Group AxisAngle&lt; Type &gt; toAxisAngle () constconvert to AxisAngle __ EulerAngle&lt; Type, NewOrder &gt; toEulerAngle () constConvert to Euler Angle. UnitComplexNum&lt; Type &gt; toUnitComplexNum () constconvert to UnitComplexNum . Using only z-axis UnitQuaternion&lt; Type &gt; toUnitQuaternion () constconvert to UnitQuaternion __"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-functions-inherited-from-translotatorsquarematrix","title":"Public Functions inherited from translotator::SquareMatrix","text":"<p>See translotator::SquareMatrix</p> Type Name Type determinant () constdeterminant of a square matrix. Only 2x2, 3x3 matrices are supported void inverse ()  SquareMatrix&lt; N, Type &gt; inversed (bool &amp; result) const1x1 ~ 3x3 closed form solution 4x4 ~ LU factorization with partial pivotting from PX4-Matrix Library Type trace () consttrace of a square matrix"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1SOGroup/#public-static-functions","title":"Public Static Functions","text":"Type Name SOGroup&lt; N, Type &gt; axisRotation (const Type &amp; angle) Create a rotation matrix around the axis. SOGroup&lt; N, Type &gt; identity () identity rotation element, which is identity matrix"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1SOGroup/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1SOGroup/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>N</code> dimension </li> <li><code>Type</code> data type</li> </ul> <p>Special Orthogonal Group is a group of rotation in N dimension. It is a group of orthogonal matrices with determinant 1. Subgroup of SOGroup is SO(2) and SO(3). Also SOGroup is a Lie Group. Exponential and Logarithm map can be defined. </p>"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1SOGroup/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::SOGroup&lt; N, Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1SOGroup/#function-sogroup-25","title":"function SOGroup [2/5]","text":"<pre><code>template&lt;size_t N_, typename&gt;\ninline translotator::SOGroup::SOGroup (\n    const Vector &lt; N, Type &gt; &amp; vec1,\n    const Vector &lt; N, Type &gt; &amp; vec2,\n    bool col=true\n) \n</code></pre> <p>constructors </p>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-sogroup-35","title":"function SOGroup [3/5]","text":"<pre><code>template&lt;size_t N_, typename&gt;\ninline translotator::SOGroup::SOGroup (\n    const Vector &lt; N, Type &gt; &amp; vec1,\n    const Vector &lt; N, Type &gt; &amp; vec2,\n    const Vector &lt; N, Type &gt; &amp; vec3,\n    bool col=true\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-sogroup-45","title":"function SOGroup [4/5]","text":"<pre><code>template&lt;size_t N_, typename&gt;\ninline explicit translotator::SOGroup::SOGroup (\n    const Type &amp; theta\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-sogroup-55","title":"function SOGroup [5/5]","text":"<pre><code>template&lt;size_t N_, typename&gt;\ninline explicit translotator::SOGroup::SOGroup (\n    const Vector &lt; N, Type &gt; &amp; angleVector\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-t","title":"function T","text":"<pre><code>inline SOGroup &lt; N, Type &gt; translotator::SOGroup::T () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::SOGroup::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-inversed","title":"function inversed","text":"<pre><code>inline SOGroup &lt; N, Type &gt; translotator::SOGroup::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-normalize","title":"function normalize","text":"<pre><code>inline void translotator::SOGroup::normalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-normalized","title":"function normalized","text":"<p>Get the orthogonalized matrix. <pre><code>inline SOGroup &lt; N, Type &gt; translotator::SOGroup::normalized () const\n</code></pre></p> <p>utils </p> <p>Returns:</p> <p>SOGroup&lt;N, Type&gt; </p> <p>Note:</p> <p>This function uses UnitComplexNum &amp; UnitQuternion internally. Not a mathmatically correct way, but it works. </p>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-operator","title":"function operator*","text":"<p>SOGroup *SOGroup =&gt;SOGroup . <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::SOGroup::operator* (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> Matrix based object with same dimension SOGroup * SOGroup =&gt; SOGroup </li> </ul>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::SOGroup::operator*= (\n    const SOGroup &lt; N, Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-operator_2","title":"function operator+","text":"<p>SOGroup +SOGroup =&gt;SquareMatrix . <pre><code>template&lt;typename OtherContainer&gt;\ninline SquareMatrix &lt; N, Type &gt; translotator::SOGroup::operator+ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>operators </p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> Matrix based object with same dimension </li> </ul>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-operator-","title":"function operator-","text":"<p>SOGroup -SOGroup =&gt;SquareMatrix . <pre><code>template&lt;typename OtherContainer&gt;\ninline SquareMatrix &lt; N, Type &gt; translotator::SOGroup::operator- (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> Matrix based object with same dimension SOGroup - SOGroup =&gt; SquareMatrix </li> </ul>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-operator-_1","title":"function operator-","text":"<pre><code>inline SOGroup &lt; N, Type &gt; translotator::SOGroup::operator- () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-operator_3","title":"function operator/","text":"<p>SOGroup /SOGroup =&gt;SOGroup . <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::SOGroup::operator/ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> Matrix based object with same dimension </li> </ul>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-pow","title":"function pow","text":"<pre><code>inline SOGroup &lt; N, Type &gt; translotator::SOGroup::pow (\n    const Type &amp; t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-toaxisangle","title":"function toAxisAngle","text":"<pre><code>inline AxisAngle &lt; Type &gt; translotator::SOGroup::toAxisAngle () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-toeulerangle","title":"function toEulerAngle","text":"<p>Convert to Euler Angle. <pre><code>template&lt;EULER_ORDER NewOrder&gt;\ninline EulerAngle &lt; Type, NewOrder &gt; translotator::SOGroup::toEulerAngle () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NewOrder</code> New Euler Order </li> </ul>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-tounitcomplexnum","title":"function toUnitComplexNum","text":"<p>convert to UnitComplexNum . Using only z-axis <pre><code>inline UnitComplexNum &lt; Type &gt; translotator::SOGroup::toUnitComplexNum () const\n</code></pre></p> <p>casts </p>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-tounitquaternion","title":"function toUnitQuaternion","text":"<pre><code>inline UnitQuaternion &lt; Type &gt; translotator::SOGroup::toUnitQuaternion () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SOGroup/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1SOGroup/#function-axisrotation","title":"function axisRotation","text":"<p>Create a rotation matrix around the axis. <pre><code>template&lt;AXIS Axis&gt;\nstatic inline SOGroup &lt; N, Type &gt; translotator::SOGroup::axisRotation (\n    const Type &amp; angle\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Axis</code> Axis to rotate </li> </ul> <p>Parameters:</p> <ul> <li><code>angle</code> angle in radian </li> </ul>"},{"location":"translotator/classtranslotator_1_1SOGroup/#function-identity","title":"function identity","text":"<p>identity rotation element, which is identity matrix <pre><code>static inline SOGroup &lt; N, Type &gt; translotator::SOGroup::identity () \n</code></pre></p> <p>static functions </p>"},{"location":"translotator/classtranslotator_1_1SOGroup/#friends-documentation","title":"Friends Documentation","text":""},{"location":"translotator/classtranslotator_1_1SOGroup/#friend-operator","title":"friend operator*","text":"<pre><code>inline SquareMatrix &lt; N, Type &gt; translotator::SOGroup::operator* (\n    const Type &amp; lhs,\n    const SOGroup &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/SOGroup.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1SquareMatrix/","title":"Class translotator::SquareMatrix","text":"<p>template &lt;size_t N, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; SquareMatrix</p> <p>Inherits the following classes: translotator::MatrixBase</p> <p>Inherited by the following classes: translotator::SOGroup</p>"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::SQUARE_MATRIX"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-functions","title":"Public Functions","text":"Type Name Type determinant () constdeterminant of a square matrix. Only 2x2, 3x3 matrices are supported void inverse ()  SquareMatrix&lt; N, Type &gt; inversed (bool &amp; result) const1x1 ~ 3x3 closed form solution 4x4 ~ LU factorization with partial pivotting from PX4-Matrix Library Type trace () consttrace of a square matrix"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1SquareMatrix/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1SquareMatrix/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::SquareMatrix&lt; N, Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1SquareMatrix/#function-determinant","title":"function determinant","text":"<pre><code>inline Type translotator::SquareMatrix::determinant () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::SquareMatrix::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#function-inversed","title":"function inversed","text":"<pre><code>inline SquareMatrix &lt; N, Type &gt; translotator::SquareMatrix::inversed (\n    bool &amp; result\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1SquareMatrix/#function-trace","title":"function trace","text":"<pre><code>inline Type translotator::SquareMatrix::trace () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/SquareMatrix.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/","title":"Class translotator::UnitComplexNum","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; UnitComplexNum</p> <p>Inherits the following classes: translotator::ComplexNum</p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType objType   = = ObjectType::UNIT_COMPLEX_NUM"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-static-attributes-inherited-from-translotatorcomplexnum","title":"Public Static Attributes inherited from translotator::ComplexNum","text":"<p>See translotator::ComplexNum</p> Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::COMPLEX_NUM"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-functions","title":"Public Functions","text":"Type Name UnitComplexNum ()  UnitComplexNum (const Type &amp; angle)  UnitComplexNum&lt; Type &gt; complexNumDiv (const UnitComplexNum&lt; Type &gt; &amp; other) const ComplexNum&lt; Type &gt; complexNumDiv (const ComplexNum&lt; Type &gt; &amp; other) const void complexNumDivEq (const UnitComplexNum&lt; Type &gt; &amp; other) alias for operator/ for readability UnitComplexNum&lt; Type &gt; complexNumMul (const UnitComplexNum&lt; Type &gt; &amp; other) const ComplexNum&lt; Type &gt; complexNumMul (const ComplexNum&lt; Type &gt; &amp; other) const void complexNumMulEq (const UnitComplexNum&lt; Type &gt; &amp; other)  UnitComplexNum&lt; Type &gt; conjugated () constreturn conjugated unit complex number void inverse ()  UnitComplexNum&lt; Type &gt; inversed () constreturn inversed unit complex number. It is same as conjugated. UnitComplexNum&lt; Type &gt; normalized () constreturn normalized unit complex number auto operator* (const OtherContainer &amp; other) constoperator* operator void operator*= (const UnitComplexNum&lt; Type &gt; &amp; other) Unit * Unit = Unit. ComplexNum&lt; Type &gt; operator+ (const OtherContainer &amp; other) constoperator+ operator auto operator- (const OtherContainer &amp; other) constoperator- operator auto operator/ (const OtherContainer &amp; other) constoperator/ operator void operator/= (const UnitComplexNum&lt; Type &gt; &amp; other) Unit / Unit = Unit. UnitComplexNum&lt; Type &gt; pow (const Type t) constreturn this unit complex number to the power of t. Using Lie algebra. Vector&lt; 2, Type &gt; rotateVector2D (const Vector&lt; 2, Type &gt; &amp; v) constinverse this unit complex number AxisAngle&lt; Type &gt; toAxisAngle () constreturn axis angle representation EulerAngle&lt; Type, AxisOrder &gt; toEulerAngle2D () constreturn euler angle representation SOGroup&lt; 2, Type &gt; toRotMatrix2D () constreturn identity unit complex number"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-functions-inherited-from-translotatorcomplexnum","title":"Public Functions inherited from translotator::ComplexNum","text":"<p>See translotator::ComplexNum</p> Type Name ComplexNum ()  ComplexNum (Type real, Type imag)  Type Im () const Type &amp; Im ()  Type Re () const Type &amp; Re ()  ComplexNum&lt; Type &gt; complexNumDiv (const ComplexNum&lt; Type &gt; &amp; c) constalias for operator*= for readability void complexNumDivEq (const ComplexNum&lt; Type &gt; &amp; c) alias for operator/ for readability ComplexNum&lt; Type &gt; complexNumMul (const ComplexNum&lt; Type &gt; &amp; c) constdivide and assign two complex numbers void complexNumMulEq (const ComplexNum&lt; Type &gt; &amp; c) alias for operator* for readability void conjugate () return the conjugated complex number ComplexNum&lt; Type &gt; conjugated () constnormalize the complex number void inverse () return the inversed complex number ComplexNum&lt; Type &gt; inversed () constconjugate the complex number Type norm () constreturn the squared norm of the complex number Type normSquared () const void normalize () return the normalized complex number ComplexNum&lt; Type &gt; normalized () constreturn the norm of the complex number ComplexNum&lt; Type &gt; operator* (const ComplexNum&lt; Type &gt; &amp; c) constmultiply two complex numbers void operator*= (const ComplexNum&lt; Type &gt; &amp; c)  ComplexNum&lt; Type &gt; operator/ (const ComplexNum&lt; Type &gt; &amp; c) constdivide two complex numbers void operator/= (const ComplexNum&lt; Type &gt; &amp; c) multiply and assign two complex numbers Type operator[] (size_t i) const Type &amp; operator[] (size_t i)  SquareMatrix&lt; 2, Type &gt; toMulMatrix () constinverse the complex number"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-static-functions","title":"Public Static Functions","text":"Type Name UnitComplexNum&lt; Type &gt; identity ()"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#variable-objtype","title":"variable objType","text":"<pre><code>constexpr static ObjectType translotator::UnitComplexNum&lt; Type &gt;::objType;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-unitcomplexnum-23","title":"function UnitComplexNum [2/3]","text":"<pre><code>inline translotator::UnitComplexNum::UnitComplexNum () \n</code></pre> <p>constructors </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-unitcomplexnum-33","title":"function UnitComplexNum [3/3]","text":"<pre><code>inline explicit translotator::UnitComplexNum::UnitComplexNum (\n    const Type &amp; angle\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-complexnumdiv-12","title":"function complexNumDiv [1/2]","text":"<pre><code>inline UnitComplexNum &lt; Type &gt; translotator::UnitComplexNum::complexNumDiv (\n    const UnitComplexNum &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-complexnumdiv-22","title":"function complexNumDiv [2/2]","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::UnitComplexNum::complexNumDiv (\n    const ComplexNum &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-complexnumdiveq-12","title":"function complexNumDivEq [1/2]","text":"<pre><code>inline void translotator::UnitComplexNum::complexNumDivEq (\n    const UnitComplexNum &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-complexnummul-13","title":"function complexNumMul [1/3]","text":"<pre><code>inline UnitComplexNum &lt; Type &gt; translotator::UnitComplexNum::complexNumMul (\n    const UnitComplexNum &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-complexnummul-23","title":"function complexNumMul [2/3]","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::UnitComplexNum::complexNumMul (\n    const ComplexNum &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-complexnummuleq-12","title":"function complexNumMulEq [1/2]","text":"<pre><code>inline void translotator::UnitComplexNum::complexNumMulEq (\n    const UnitComplexNum &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-conjugated","title":"function conjugated","text":"<pre><code>inline UnitComplexNum &lt; Type &gt; translotator::UnitComplexNum::conjugated () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::UnitComplexNum::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-inversed","title":"function inversed","text":"<pre><code>inline UnitComplexNum &lt; Type &gt; translotator::UnitComplexNum::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-normalized","title":"function normalized","text":"<p>return normalized unit complex number <pre><code>inline UnitComplexNum &lt; Type &gt; translotator::UnitComplexNum::normalized () const\n</code></pre></p> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-operator","title":"function operator*","text":"<p>operator* operator <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::UnitComplexNum::operator* (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul> <p>Note:</p> <p>Unit * Unit = Unit, </p> <p>Note:</p> <p>Unit * Complex = Complex, </p> <p>Note:</p> <p>Unit * Type = Complex, </p> <p>Note:</p> <p>else, follows the matrix multiplication rule </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::UnitComplexNum::operator*= (\n    const UnitComplexNum &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-operator_2","title":"function operator+","text":"<p>operator+ operator <pre><code>template&lt;typename OtherContainer&gt;\ninline ComplexNum &lt; Type &gt; translotator::UnitComplexNum::operator+ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>operators </p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-operator-","title":"function operator-","text":"<p>operator- operator <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::UnitComplexNum::operator- (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-operator_3","title":"function operator/","text":"<p>operator/ operator <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::UnitComplexNum::operator/ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul> <p>Note:</p> <p>Unit / Unit = Unit, </p> <p>Note:</p> <p>Unit / Complex = Complex, </p> <p>Note:</p> <p>Unit / Type = Complex, </p> <p>Note:</p> <p>else, follows the matrix multiplication rule </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-operator_4","title":"function operator/=","text":"<pre><code>inline void translotator::UnitComplexNum::operator/= (\n    const UnitComplexNum &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-pow","title":"function pow","text":"<pre><code>inline UnitComplexNum &lt; Type &gt; translotator::UnitComplexNum::pow (\n    const Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-rotatevector2d","title":"function rotateVector2D","text":"<p>inverse this unit complex number <pre><code>inline Vector &lt; 2, Type &gt; translotator::UnitComplexNum::rotateVector2D (\n    const Vector &lt; 2, Type &gt; &amp; v\n) const\n</code></pre></p> <p>rotate 2D vector </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-toaxisangle","title":"function toAxisAngle","text":"<pre><code>inline AxisAngle &lt; Type &gt; translotator::UnitComplexNum::toAxisAngle () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-toeulerangle2d","title":"function toEulerAngle2D","text":"<pre><code>template&lt;EULER_ORDER AxisOrder&gt;\ninline EulerAngle &lt; Type, AxisOrder &gt; translotator::UnitComplexNum::toEulerAngle2D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-torotmatrix2d","title":"function toRotMatrix2D","text":"<p>return identity unit complex number <pre><code>inline SOGroup &lt; 2, Type &gt; translotator::UnitComplexNum::toRotMatrix2D () const\n</code></pre></p> <p>casting return 2D rotation matrix </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#function-identity","title":"function identity","text":"<pre><code>static inline UnitComplexNum &lt; Type &gt; translotator::UnitComplexNum::identity () \n</code></pre> <p>static functions </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friends-documentation","title":"Friends Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-complexnumdiveq-22","title":"friend complexNumDivEq [2/2]","text":"<pre><code>inline void translotator::UnitComplexNum::complexNumDivEq (\n    ComplexNum &lt; Type &gt; &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-complexnummul-33","title":"friend complexNumMul [3/3]","text":"<p>alias for operator* for readability <pre><code>inline ComplexNum &lt; Type &gt; translotator::UnitComplexNum::complexNumMul (\n    const ComplexNum &lt; Type &gt; &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre></p> <p>alias for operator* for readability </p>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-complexnummuleq-22","title":"friend complexNumMulEq [2/2]","text":"<pre><code>inline void translotator::UnitComplexNum::complexNumMulEq (\n    ComplexNum &lt; Type &gt; &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-operator","title":"friend operator*","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::UnitComplexNum::operator* (\n    const ComplexNum &lt; Type &gt; &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-operator_1","title":"friend operator*","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::UnitComplexNum::operator* (\n    const Type &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-operator_2","title":"friend operator*=","text":"<pre><code>inline void translotator::UnitComplexNum::operator*= (\n    ComplexNum &lt; Type &gt; &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-operator_3","title":"friend operator/","text":"<pre><code>inline ComplexNum &lt; Type &gt; translotator::UnitComplexNum::operator/ (\n    const ComplexNum &lt; Type &gt; &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitComplexNum/#friend-operator_4","title":"friend operator/=","text":"<pre><code>inline void translotator::UnitComplexNum::operator/= (\n    ComplexNum &lt; Type &gt; &amp; lhs,\n    const UnitComplexNum &lt; Type &gt; &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/UnitComplexNum.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/","title":"Class translotator::UnitDualQuaternion","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; UnitDualQuaternion</p> <p>Represents a unit dual quaternion. More...</p> <ul> <li><code>#include &lt;UnitDualQuaternion.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::DualQuaternion</p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::UNIT_DUAL_QUATERNION"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-attributes-inherited-from-translotatordualquaternion","title":"Public Static Attributes inherited from translotator::DualQuaternion","text":"<p>See translotator::DualQuaternion</p> Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::DUAL_QUATERNION"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-functions","title":"Public Functions","text":"Type Name const UnitQuaternion&lt; Type &gt; &amp; Re () constreturn real part of unit dual quaternion, UnitQuaternion __ UnitQuaternion&lt; Type &gt; &amp; Re ()  UnitDualQuaternion ()  UnitDualQuaternion (const UnitQuaternion&lt; Type &gt; &amp; re, const Quaternion&lt; Type &gt; &amp; du)  UnitDualQuaternion (const UnitQuaternion&lt; Type &gt; &amp; rot, const Vector&lt; 3, Type &gt; &amp; t)  Vector&lt; 2, Type &gt; actOnVector2D (const Vector&lt; 2, Type &gt; &amp; v) constinverse this unit dual quaternion Vector&lt; 3, Type &gt; actOnVector3D (const Vector&lt; 3, Type &gt; &amp; v) constact on 3D vector void conjugate ()  UnitDualQuaternion&lt; Type &gt; conjugated () constnormalize unit dual quaternion UnitDualQuaternion&lt; Type &gt; dualQuatDiv (const UnitDualQuaternion&lt; Type &gt; &amp; other) const DualQuaternion&lt; Type &gt; dualQuatDiv (const DualQuaternion&lt; Type &gt; &amp; other) const void dualQuatDivEq (const UnitDualQuaternion&lt; Type &gt; &amp; other) alias for operator/ for readability UnitDualQuaternion&lt; Type &gt; dualQuatMul (const UnitDualQuaternion&lt; Type &gt; &amp; other) const DualQuaternion&lt; Type &gt; dualQuatMul (const DualQuaternion&lt; Type &gt; &amp; other) const void dualQuatMulEq (const UnitDualQuaternion&lt; Type &gt; &amp; other)  void inverse ()  UnitDualQuaternion&lt; Type &gt; inversed () constconjugate unit dual quaternion void normalize ()  UnitDualQuaternion&lt; Type &gt; normalized () constreturn normalized unit dual quaternion auto operator* (const OtherContainer &amp; other) constoperator* operator void operator*= (const UnitDualQuaternion&lt; Type &gt; &amp; other) Unit * Unit = Unit. DualQuaternion&lt; Type &gt; operator+ (const OtherContainer &amp; other) constoperator+ operator DualQuaternion&lt; Type &gt; operator- (const OtherContainer &amp; other) constoperator- operator auto operator/ (const OtherContainer &amp; other) constoperator/ operator void operator/= (const UnitDualQuaternion&lt; Type &gt; &amp; other) Unit / Unit = Unit. SEGroup&lt; 2, Type &gt; toSE2Group () constconvert to SE(2) group, Using only z axis rotation SEGroup&lt; 3, Type &gt; toSE3Group () constconvert to SE(3) group Vector&lt; 2, Type &gt; toTranslationVec2D () constreturn translation vector in 2D Vector&lt; 3, Type &gt; toTranslationVec3D () constreturn translation vector in 3D"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-functions-inherited-from-translotatordualquaternion","title":"Public Functions inherited from translotator::DualQuaternion","text":"<p>See translotator::DualQuaternion</p> Type Name const Quaternion&lt; Type &gt; &amp; Du () const Quaternion&lt; Type &gt; &amp; Du ()  DualQuaternion () = default DualQuaternion (const Type &amp; rw, const Type &amp; rx, const Type &amp; ry, const Type &amp; rz, const Type &amp; dw, const Type &amp; dx, const Type &amp; dy, const Type &amp; dz)  DualQuaternion (const Quaternion&lt; Type &gt; &amp; r, const Quaternion&lt; Type &gt; &amp; d)  DualQuaternion (const DualNumber&lt; Type &gt; &amp; dn)  const Quaternion&lt; Type &gt; &amp; Re () const Quaternion&lt; Type &gt; &amp; Re ()  void conjugateDual ()  void conjugateFull ()  void conjugatePrimary ()  DualQuaternion&lt; Type &gt; conjugatedDual () constqr + qd e =&gt; qr* + qd* e DualQuaternion&lt; Type &gt; conjugatedFull () constqr + qd e =&gt; qr - qd e DualQuaternion&lt; Type &gt; conjugatedPrimary () constdual quaternion division DualQuaternion&lt; Type &gt; dualQuatDiv (const DualQuaternion&lt; Type &gt; &amp; dq) constdual quaternion multiplication void dualQuatDivEq (const DualQuaternion&lt; Type &gt; &amp; dq) dual quaternion division DualQuaternion&lt; Type &gt; dualQuatMul (const DualQuaternion&lt; Type &gt; &amp; dq) constdual quaternion division void dualQuatMulEq (const DualQuaternion&lt; Type &gt; &amp; dq) dual quaternion multiplication const Type &amp; dw () const Type &amp; dw ()  const Type &amp; dx () const Type &amp; dx ()  const Type &amp; dy () const Type &amp; dy ()  const Type &amp; dz () const Type &amp; dz ()  void inverse ()  DualQuaternion&lt; Type &gt; inversed () constdual quaternion inverse DualNumber&lt; Type &gt; normDualNum () constqr + qd e =&gt; qr* - qd* e DualNumber&lt; Type &gt; normDualNumSquared () constoriginal dual quaternion norm squared with primary conjugate Type normScalar () const Type normScalarSquared () constdual quaternion norm squared, dual number norm squared again void normalize () const DualQuaternion&lt; Type &gt; normalized () constdual quaternion inverse in place DualQuaternion&lt; Type &gt; operator* (const DualQuaternion&lt; Type &gt; &amp; other) constdual quaternion multiplication void operator*= (const DualQuaternion&lt; Type &gt; &amp; q) dual quaternion division DualQuaternion&lt; Type &gt; operator/ (const DualQuaternion&lt; Type &gt; &amp; other) const void operator/= (const DualQuaternion&lt; Type &gt; &amp; q) dual quaternion multiplication const Type &amp; operator[] (const size_t &amp; idx) const Type &amp; operator[] (const size_t &amp; idx)  const Type &amp; rw () const Type &amp; rw ()  const Type &amp; rx () const Type &amp; rx ()  const Type &amp; ry () const Type &amp; ry ()  const Type &amp; rz () const Type &amp; rz ()  SquareMatrix&lt; 8, Type &gt; toMulMatrix () constdual quaternion to multiplication matrix SquareMatrix&lt; 8, Type &gt; toRightMulMatrix () constdual quaternion to multiplication matrix from right ~DualQuaternion () = default"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-functions","title":"Public Static Functions","text":"Type Name UnitDualQuaternion&lt; Type &gt; identity () identity unit dual quaternion"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-functions-inherited-from-translotatordualquaternion","title":"Public Static Functions inherited from translotator::DualQuaternion","text":"<p>See translotator::DualQuaternion</p> Type Name DualQuaternion&lt; Type &gt; zeros () dual quaternion normalization"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> floating point type</li> </ul> <p>UnitDualQuaternion is a class that represents a unit dual quaternion. It is a subclass of DualQuaternion and has a unit length. It is used to represent a rigid transformation in 3D space. </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::UnitDualQuaternion&lt; Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-re-12","title":"function Re [1/2]","text":"<p>return real part of unit dual quaternion, UnitQuaternion __ <pre><code>inline const UnitQuaternion &lt; Type &gt; &amp; translotator::UnitDualQuaternion::Re () const\n</code></pre></p> <p>accessors </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-re-22","title":"function Re [2/2]","text":"<pre><code>inline UnitQuaternion &lt; Type &gt; &amp; translotator::UnitDualQuaternion::Re () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-unitdualquaternion-24","title":"function UnitDualQuaternion [2/4]","text":"<pre><code>inline translotator::UnitDualQuaternion::UnitDualQuaternion () \n</code></pre> <p>constructors </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-unitdualquaternion-34","title":"function UnitDualQuaternion [3/4]","text":"<pre><code>inline translotator::UnitDualQuaternion::UnitDualQuaternion (\n    const UnitQuaternion &lt; Type &gt; &amp; re,\n    const Quaternion &lt; Type &gt; &amp; du\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-unitdualquaternion-44","title":"function UnitDualQuaternion [4/4]","text":"<pre><code>inline translotator::UnitDualQuaternion::UnitDualQuaternion (\n    const UnitQuaternion &lt; Type &gt; &amp; rot,\n    const Vector &lt; 3, Type &gt; &amp; t\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-actonvector2d","title":"function actOnVector2D","text":"<p>inverse this unit dual quaternion <pre><code>inline Vector &lt; 2, Type &gt; translotator::UnitDualQuaternion::actOnVector2D (\n    const Vector &lt; 2, Type &gt; &amp; v\n) const\n</code></pre></p> <p>act on 2D vector </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-actonvector3d","title":"function actOnVector3D","text":"<pre><code>inline Vector &lt; 3, Type &gt; translotator::UnitDualQuaternion::actOnVector3D (\n    const Vector &lt; 3, Type &gt; &amp; v\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-conjugate","title":"function conjugate","text":"<pre><code>inline void translotator::UnitDualQuaternion::conjugate () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-conjugated","title":"function conjugated","text":"<p>normalize unit dual quaternion <pre><code>inline UnitDualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::conjugated () const\n</code></pre></p> <p>return conjugated unit dual quaternion. Primary conjugated. </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-dualquatdiv-12","title":"function dualQuatDiv [1/2]","text":"<pre><code>inline UnitDualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::dualQuatDiv (\n    const UnitDualQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-dualquatdiv-22","title":"function dualQuatDiv [2/2]","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::dualQuatDiv (\n    const DualQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-dualquatdiveq-12","title":"function dualQuatDivEq [1/2]","text":"<pre><code>inline void translotator::UnitDualQuaternion::dualQuatDivEq (\n    const UnitDualQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-dualquatmul-13","title":"function dualQuatMul [1/3]","text":"<pre><code>inline UnitDualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::dualQuatMul (\n    const UnitDualQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-dualquatmul-23","title":"function dualQuatMul [2/3]","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::dualQuatMul (\n    const DualQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-dualquatmuleq-12","title":"function dualQuatMulEq [1/2]","text":"<pre><code>inline void translotator::UnitDualQuaternion::dualQuatMulEq (\n    const UnitDualQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::UnitDualQuaternion::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-inversed","title":"function inversed","text":"<p>conjugate unit dual quaternion <pre><code>inline UnitDualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::inversed () const\n</code></pre></p> <p>return inversed unit dual quaternion. It is same as conjugated. </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-normalize","title":"function normalize","text":"<pre><code>inline void translotator::UnitDualQuaternion::normalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-normalized","title":"function normalized","text":"<p>return normalized unit dual quaternion <pre><code>inline UnitDualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::normalized () const\n</code></pre></p> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-operator","title":"function operator*","text":"<p>operator* operator <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::UnitDualQuaternion::operator* (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul> <p>Note:</p> <p>Unit * Unit = Unit, </p> <p>Note:</p> <p>Unit * Dual = Dual, </p> <p>Note:</p> <p>Unit * Type = Dual, </p> <p>Note:</p> <p>else, follows the matrix multiplication rule </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::UnitDualQuaternion::operator*= (\n    const UnitDualQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-operator_2","title":"function operator+","text":"<p>operator+ operator <pre><code>template&lt;typename OtherContainer&gt;\ninline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::operator+ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>operators </p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type</li> </ul> <p>This operator is used to add two dual quaternions. </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-operator-","title":"function operator-","text":"<p>operator- operator <pre><code>template&lt;typename OtherContainer&gt;\ninline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::operator- (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type</li> </ul> <p>This operator is used to subtract two dual quaternions. </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-operator_3","title":"function operator/","text":"<p>operator/ operator <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::UnitDualQuaternion::operator/ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul> <p>Note:</p> <p>Unit / Unit = Unit, </p> <p>Note:</p> <p>Unit / Dual = Dual, </p> <p>Note:</p> <p>Unit / Type = Dual, </p> <p>Note:</p> <p>else, follows the matrix multiplication rule </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-operator_4","title":"function operator/=","text":"<pre><code>inline void translotator::UnitDualQuaternion::operator/= (\n    const UnitDualQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-tose2group","title":"function toSE2Group","text":"<p>convert to SE(2) group, Using only z axis rotation <pre><code>inline SEGroup &lt; 2, Type &gt; translotator::UnitDualQuaternion::toSE2Group () const\n</code></pre></p> <p>casting </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-tose3group","title":"function toSE3Group","text":"<pre><code>inline SEGroup &lt; 3, Type &gt; translotator::UnitDualQuaternion::toSE3Group () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-totranslationvec2d","title":"function toTranslationVec2D","text":"<pre><code>inline Vector &lt; 2, Type &gt; translotator::UnitDualQuaternion::toTranslationVec2D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-totranslationvec3d","title":"function toTranslationVec3D","text":"<pre><code>inline Vector &lt; 3, Type &gt; translotator::UnitDualQuaternion::toTranslationVec3D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#function-identity","title":"function identity","text":"<p>identity unit dual quaternion <pre><code>static inline UnitDualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::identity () \n</code></pre></p> <p>static functions </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friends-documentation","title":"Friends Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-dualquatdiveq-22","title":"friend dualQuatDivEq [2/2]","text":"<pre><code>inline void translotator::UnitDualQuaternion::dualQuatDivEq (\n    DualQuaternion &lt; Type &gt; &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-dualquatmul-33","title":"friend dualQuatMul [3/3]","text":"<p>alias for operator* for readability <pre><code>inline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::dualQuatMul (\n    const DualQuaternion &lt; Type &gt; &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre></p> <p>alias for operator* for readability </p>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-dualquatmuleq-22","title":"friend dualQuatMulEq [2/2]","text":"<pre><code>inline void translotator::UnitDualQuaternion::dualQuatMulEq (\n    DualQuaternion &lt; Type &gt; &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-operator","title":"friend operator*","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::operator* (\n    const DualQuaternion &lt; Type &gt; &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-operator_1","title":"friend operator*","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::operator* (\n    const Type &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-operator_2","title":"friend operator*=","text":"<pre><code>inline void translotator::UnitDualQuaternion::operator*= (\n    DualQuaternion &lt; Type &gt; &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-operator_3","title":"friend operator/","text":"<pre><code>inline DualQuaternion &lt; Type &gt; translotator::UnitDualQuaternion::operator/ (\n    const DualQuaternion &lt; Type &gt; &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitDualQuaternion/#friend-operator_4","title":"friend operator/=","text":"<pre><code>inline void translotator::UnitDualQuaternion::operator/= (\n    DualQuaternion &lt; Type &gt; &amp; lhs,\n    const UnitDualQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/UnitDualQuaternion.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/","title":"Class translotator::UnitQuaternion","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; UnitQuaternion</p> <p>UnitQuaternion class.More...</p> <ul> <li><code>#include &lt;UnitQuaternion.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::Quaternion</p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::UNIT_QUATERNION"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-static-attributes-inherited-from-translotatorquaternion","title":"Public Static Attributes inherited from translotator::Quaternion","text":"<p>See translotator::Quaternion</p> Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::QUATERNION"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-functions","title":"Public Functions","text":"Type Name UnitQuaternion ()  UnitQuaternion (const Vector&lt; 3, Type &gt; &amp; angleVec)  void canonicalize ()  UnitQuaternion&lt; Type &gt; canonicalized () constreturn canonicalized unit quaternion. if w &lt; 0, negate all components. UnitQuaternion&lt; Type &gt; conjugated () constreturn conjugated unit quaternion. Primary conjugated. void inverse ()  UnitQuaternion&lt; Type &gt; inversed () constreturn inversed unit quaternion. It is same as conjugated. UnitQuaternion&lt; Type &gt; normalized () constreturn normalized unit quaternion auto operator* (const OtherContainer &amp; other) constoperator* operator void operator*= (const UnitQuaternion&lt; Type &gt; &amp; other) Unit * Unit = Unit. Quaternion&lt; Type &gt; operator+ (const OtherContainer &amp; other) constoperator+ operator Quaternion&lt; Type &gt; operator- (const OtherContainer &amp; other) constoperator- operator auto operator/ (const OtherContainer &amp; other) constoperator/ operator void operator/= (const UnitQuaternion&lt; Type &gt; &amp; other) Unit / Unit = Unit. UnitQuaternion&lt; Type &gt; pow (const Type &amp; t) constcanonicalize this unit quaternion UnitQuaternion&lt; Type &gt; quatNumDiv (const UnitQuaternion&lt; Type &gt; &amp; other) const Quaternion&lt; Type &gt; quatNumDiv (const Quaternion&lt; Type &gt; &amp; other) constalias for operator/ for readability void quatNumDivEq (const UnitQuaternion&lt; Type &gt; &amp; other) alias for operator/ for readability UnitQuaternion&lt; Type &gt; quatNumMul (const UnitQuaternion&lt; Type &gt; &amp; other) const Quaternion&lt; Type &gt; quatNumMul (const Quaternion&lt; Type &gt; &amp; other) constalias for operator* for readability void quatNumMulEq (const UnitQuaternion&lt; Type &gt; &amp; other)  Vector&lt; 2, Type &gt; rotateVector2D (const Vector&lt; 2, Type &gt; &amp; v) constrotate 2D vector. Using only w, z component. Vector&lt; 3, Type &gt; rotateVector3D (const Vector&lt; 3, Type &gt; &amp; v) constinverse this unit quaternion AxisAngle&lt; Type &gt; toAxisAngle () constconvert to axis angle EulerAngle&lt; Type, AxisOrder &gt; toEulerAngle2D () constconvert to euler angle EulerAngle&lt; Type, NewOrder &gt; toEulerAngle3D () constconvert to euler angle SOGroup&lt; 2, Type &gt; toRotMatrix2D () constconvert to SO(2) group, Using only z axis rotation SOGroup&lt; 3, Type &gt; toRotMatrix3D () constconvert to SO(3) group"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-functions-inherited-from-translotatorquaternion","title":"Public Functions inherited from translotator::Quaternion","text":"<p>See translotator::Quaternion</p> Type Name const Vector&lt; 3, Type &gt; Im () const Vector&lt; 3, Type &gt; &amp; Im ()  Quaternion ()  Quaternion (Type w, Type x, Type y, Type z)  Quaternion (Type w, const Vector&lt; 3, Type &gt; &amp; v)  Quaternion (const ComplexNum&lt; Type &gt; &amp; cplx)  const Type Re () const Type &amp; Re ()  void canonicalize ()  Quaternion&lt; Type &gt; canonicalized () constnormalize the quaternion void conjugate () get the conjugated quaternion Quaternion&lt; Type &gt; conjugated () constcanonicalize the quaternion void inverse () get the inversed quaternion Quaternion&lt; Type &gt; inversed () constconjugate the quaternion Type norm () constget the squared norm of the quaternion Type normSquared () const void normalize () get the normalized quaternion Quaternion&lt; Type &gt; normalized () constget the norm of the quaternion Quaternion&lt; Type &gt; operator* (const Quaternion&lt; Type &gt; &amp; q) constquaternion multiplication void operator*= (const Quaternion&lt; Type &gt; &amp; q) quaternion division Quaternion&lt; Type &gt; operator/ (const Quaternion&lt; Type &gt; &amp; q) const void operator/= (const Quaternion&lt; Type &gt; &amp; q) quaternion multiplication Type operator[] (size_t i) const Type &amp; operator[] (size_t i)  Quaternion&lt; Type &gt; quatNumDiv (const Quaternion&lt; Type &gt; &amp; q) const void quatNumDivEq (const Quaternion&lt; Type &gt; &amp; q)  Quaternion&lt; Type &gt; quatNumMul (const Quaternion&lt; Type &gt; &amp; q) constquaternion division void quatNumMulEq (const Quaternion&lt; Type &gt; &amp; q)  SquareMatrix&lt; 4, Type &gt; toMulMatrix () constget the matrix that represents the quaternion multiplication SquareMatrix&lt; 4, Type &gt; toRightMulMatrix () constget the matrix that represents the quaternion multiplication from the right Type w () const Type &amp; w ()  Type x () const Type &amp; x ()  Type y () const Type &amp; y ()  Type z () const Type &amp; z ()"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-static-functions","title":"Public Static Functions","text":"Type Name UnitQuaternion&lt; Type &gt; axisRotation (const Type &amp; angle) axis rotation unit quaternion UnitQuaternion&lt; Type &gt; identity () identity unit quaternion"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> floating point type</li> </ul> <p>UnitQuaternion class is a class that represents a unit quaternion. A unit quaternion is a quaternion that has a length of 1. </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::UnitQuaternion&lt; Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-unitquaternion-23","title":"function UnitQuaternion [2/3]","text":"<pre><code>inline translotator::UnitQuaternion::UnitQuaternion () \n</code></pre> <p>constructors </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-unitquaternion-33","title":"function UnitQuaternion [3/3]","text":"<pre><code>inline translotator::UnitQuaternion::UnitQuaternion (\n    const Vector &lt; 3, Type &gt; &amp; angleVec\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-canonicalize","title":"function canonicalize","text":"<pre><code>inline void translotator::UnitQuaternion::canonicalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-canonicalized","title":"function canonicalized","text":"<pre><code>inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::canonicalized () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-conjugated","title":"function conjugated","text":"<pre><code>inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::conjugated () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-inverse","title":"function inverse","text":"<pre><code>inline void translotator::UnitQuaternion::inverse () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-inversed","title":"function inversed","text":"<pre><code>inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::inversed () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-normalized","title":"function normalized","text":"<p>return normalized unit quaternion <pre><code>inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::normalized () const\n</code></pre></p> <p>utils </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-operator","title":"function operator*","text":"<p>operator* operator <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::UnitQuaternion::operator* (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type</li> </ul> <p>This operator is used to multiply two quaternions. </p> <p>Note:</p> <p>Unit * Unit = Unit, </p> <p>Note:</p> <p>Unit * Quaternion = Quaternion, </p> <p>Note:</p> <p>Unit * Type = Quaternion, </p> <p>Note:</p> <p>else, follows the matrix multiplication rule </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-operator_1","title":"function operator*=","text":"<pre><code>inline void translotator::UnitQuaternion::operator*= (\n    const UnitQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-operator_2","title":"function operator+","text":"<p>operator+ operator <pre><code>template&lt;typename OtherContainer&gt;\ninline Quaternion &lt; Type &gt; translotator::UnitQuaternion::operator+ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>operators </p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-operator-","title":"function operator-","text":"<p>operator- operator <pre><code>template&lt;typename OtherContainer&gt;\ninline Quaternion &lt; Type &gt; translotator::UnitQuaternion::operator- (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type </li> </ul>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-operator_3","title":"function operator/","text":"<p>operator/ operator <pre><code>template&lt;typename OtherContainer&gt;\ninline auto translotator::UnitQuaternion::operator/ (\n    const OtherContainer &amp; other\n) const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>OtherContainer</code> other container matrix-base type</li> </ul> <p>This operator is used to divide two quaternions. </p> <p>Note:</p> <p>Unit / Unit = Unit, </p> <p>Note:</p> <p>Unit / Quaternion = Quaternion, </p> <p>Note:</p> <p>Unit / Type = Quaternion, </p> <p>Note:</p> <p>else, follows the matrix multiplication rule </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-operator_4","title":"function operator/=","text":"<pre><code>inline void translotator::UnitQuaternion::operator/= (\n    const UnitQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-pow","title":"function pow","text":"<p>canonicalize this unit quaternion <pre><code>inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::pow (\n    const Type &amp; t\n) const\n</code></pre></p> <p>return t-th power of this unit quaternion. Using Lie operation Exp, Log </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-quatnumdiv-12","title":"function quatNumDiv [1/2]","text":"<pre><code>inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::quatNumDiv (\n    const UnitQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-quatnumdiv-22","title":"function quatNumDiv [2/2]","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::UnitQuaternion::quatNumDiv (\n    const Quaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-quatnumdiveq-12","title":"function quatNumDivEq [1/2]","text":"<pre><code>inline void translotator::UnitQuaternion::quatNumDivEq (\n    const UnitQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-quatnummul-13","title":"function quatNumMul [1/3]","text":"<pre><code>inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::quatNumMul (\n    const UnitQuaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-quatnummul-23","title":"function quatNumMul [2/3]","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::UnitQuaternion::quatNumMul (\n    const Quaternion &lt; Type &gt; &amp; other\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-quatnummuleq-12","title":"function quatNumMulEq [1/2]","text":"<pre><code>inline void translotator::UnitQuaternion::quatNumMulEq (\n    const UnitQuaternion &lt; Type &gt; &amp; other\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-rotatevector2d","title":"function rotateVector2D","text":"<pre><code>inline Vector &lt; 2, Type &gt; translotator::UnitQuaternion::rotateVector2D (\n    const Vector &lt; 2, Type &gt; &amp; v\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-rotatevector3d","title":"function rotateVector3D","text":"<p>inverse this unit quaternion <pre><code>inline Vector &lt; 3, Type &gt; translotator::UnitQuaternion::rotateVector3D (\n    const Vector &lt; 3, Type &gt; &amp; v\n) const\n</code></pre></p> <p>rotate 3D vector </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-toaxisangle","title":"function toAxisAngle","text":"<pre><code>inline AxisAngle &lt; Type &gt; translotator::UnitQuaternion::toAxisAngle () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-toeulerangle2d","title":"function toEulerAngle2D","text":"<p>convert to euler angle <pre><code>template&lt;EULER_ORDER AxisOrder&gt;\ninline EulerAngle &lt; Type, AxisOrder &gt; translotator::UnitQuaternion::toEulerAngle2D () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>AxisOrder</code> euler angle order </li> </ul> <p>Note:</p> <p>Using only z axis rotation </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-toeulerangle3d","title":"function toEulerAngle3D","text":"<p>convert to euler angle <pre><code>template&lt;EULER_ORDER NewOrder&gt;\ninline EulerAngle &lt; Type, NewOrder &gt; translotator::UnitQuaternion::toEulerAngle3D () const\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NewOrder</code> euler angle order </li> </ul>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-torotmatrix2d","title":"function toRotMatrix2D","text":"<p>convert to SO(2) group, Using only z axis rotation <pre><code>inline SOGroup &lt; 2, Type &gt; translotator::UnitQuaternion::toRotMatrix2D () const\n</code></pre></p> <p>casting </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-torotmatrix3d","title":"function toRotMatrix3D","text":"<pre><code>inline SOGroup &lt; 3, Type &gt; translotator::UnitQuaternion::toRotMatrix3D () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-axisrotation","title":"function axisRotation","text":"<p>axis rotation unit quaternion <pre><code>template&lt;AXIS Axis&gt;\nstatic inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::axisRotation (\n    const Type &amp; angle\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Axis</code> axis to rotate </li> </ul>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#function-identity","title":"function identity","text":"<p>identity unit quaternion <pre><code>static inline UnitQuaternion &lt; Type &gt; translotator::UnitQuaternion::identity () \n</code></pre></p> <p>static functions </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friends-documentation","title":"Friends Documentation","text":""},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-operator","title":"friend operator*","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::UnitQuaternion::operator* (\n    const Quaternion &lt; Type &gt; &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-operator_1","title":"friend operator*","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::UnitQuaternion::operator* (\n    const Type &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-operator_2","title":"friend operator*=","text":"<pre><code>inline void translotator::UnitQuaternion::operator*= (\n    Quaternion &lt; Type &gt; &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-operator_3","title":"friend operator/","text":"<pre><code>inline Quaternion &lt; Type &gt; translotator::UnitQuaternion::operator/ (\n    const Quaternion &lt; Type &gt; &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-operator_4","title":"friend operator/=","text":"<pre><code>inline void translotator::UnitQuaternion::operator/= (\n    Quaternion &lt; Type &gt; &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-quatnumdiveq-22","title":"friend quatNumDivEq [2/2]","text":"<p>alias for operator/= for readability <pre><code>inline void translotator::UnitQuaternion::quatNumDivEq (\n    Quaternion &lt; Type &gt; &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre></p> <p>alias for operator/= for readability </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-quatnummul-33","title":"friend quatNumMul [3/3]","text":"<p>alias for operator* for readability <pre><code>inline Quaternion &lt; Type &gt; translotator::UnitQuaternion::quatNumMul (\n    const Quaternion &lt; Type &gt; &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre></p> <p>alias for operator* for readability </p>"},{"location":"translotator/classtranslotator_1_1UnitQuaternion/#friend-quatnummuleq-22","title":"friend quatNumMulEq [2/2]","text":"<p>alias for operator*= for readability <pre><code>inline void translotator::UnitQuaternion::quatNumMulEq (\n    Quaternion &lt; Type &gt; &amp; lhs,\n    const UnitQuaternion &lt; Type &gt; &amp; rhs\n) \n</code></pre></p> <p>alias for operator*= for readability </p> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/UnitQuaternion.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1Vector/","title":"Class translotator::Vector","text":"<p>template &lt;size_t N, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; Vector</p> <p>Vector class.More...</p> <ul> <li><code>#include &lt;Vector.hpp&gt;</code></li> </ul> <p>Inherits the following classes: translotator::MatrixBase</p>"},{"location":"translotator/classtranslotator_1_1Vector/#public-types-inherited-from-translotatormatrixbase","title":"Public Types inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name typedef Type DATATYPE"},{"location":"translotator/classtranslotator_1_1Vector/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static ObjectType OBJECT_TYPE   = = ObjectType::VECTOR"},{"location":"translotator/classtranslotator_1_1Vector/#public-static-attributes-inherited-from-translotatormatrixbase","title":"Public Static Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name constexpr static size_t COLS   = = M constexpr static bool MATRIX_BASE   = = true constexpr static size_t ROWS   = = N"},{"location":"translotator/classtranslotator_1_1Vector/#public-functions","title":"Public Functions","text":"Type Name Vector&lt; 3, Type &gt; cross (const Vector&lt; 3, Type &gt; &amp; other) constcross product operation Type dot (const Vector&lt; N, Type &gt; &amp; other) constin-place normalize Type norm () const Type normSquared () constreturn norm of vector void normalize ()  Vector&lt; N, Type &gt; normalized () constreturn squared norm of vector Type &amp; operator[] (size_t i)  const Type &amp; operator[] (size_t i) const SquareMatrix&lt; 3, Type &gt; toCrossMatrix () constconvert to cross matrix SquareMatrix&lt; N, Type &gt; toDiagMatrix () constconvert to diagonal matrix"},{"location":"translotator/classtranslotator_1_1Vector/#public-functions-inherited-from-translotatormatrixbase","title":"Public Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name MatrixBase () = defaultReturns the number of columns. MatrixBase (const MatrixBase &amp; other) = default MatrixBase (const Type data)  MatrixBase (const Type data)  MatrixBase (const initializer_list&lt; N *M, Type &gt; &amp; list) Initializer list constructor. auto T () constTranspose. Matrix&lt; P, Q, Type &gt; block (size_t i, size_t j) constReturns a block of the matrix. Matrix&lt; P, Q, Type &gt; block () constReturns a block of the matrix. ComplexNum&lt; Type &gt; cast2ComplexNum () constCasts the object to a complex number by copying. ComplexNum&lt; Type &gt; &amp; cast2ComplexNumRef () Casts the object to a complex number reference without copying. DualNumber&lt; Type &gt; cast2DualNumber () constCasts the object to a dual number by copying. DualNumber&lt; Type &gt; &amp; cast2DualNumberRef () Casts the object to a dual number reference without copying. DualQuaternion&lt; Type &gt; cast2DualQuaternion () constCasts the object to a dual quaternion by copying. DualQuaternion&lt; Type &gt; &amp; cast2DualQuaternionRef () Casts the object to a dual quaternion reference without copying. Matrix&lt; N, M, Type &gt; cast2Matrix () constCasts the object to a different matrix type by copying. Matrix&lt; N, M, Type &gt; &amp; cast2MatrixRef () Casts the object to a matrix reference without copying. Quaternion&lt; Type &gt; cast2Quaternion () constCasts the object to a quaternion by copying. Quaternion&lt; Type &gt; &amp; cast2QuaternionRef () Casts the object to a quaternion reference without copying. SOGroup&lt; N, Type &gt; cast2SOGroup () constCasts the object to a special orthogonal group by copying. SOGroup&lt; N, Type &gt; &amp; cast2SOGroupRef () Casts the object to a special orthogonal group reference without copying. SquareMatrix&lt; N, Type &gt; cast2SquareMatrix () constCasts the object to a square matrix by copying. SquareMatrix&lt; N, Type &gt; &amp; cast2SquareMatrixRef () Casts the object to a square matrix reference without copying. UnitComplexNum&lt; Type &gt; cast2UnitComplexNum () constCasts the object to a unit complex number by copying. UnitComplexNum&lt; Type &gt; &amp; cast2UnitComplexNumRef () Casts the object to a unit complex number reference without copying. UnitDualQuaternion&lt; Type &gt; cast2UnitDualQuaternion () constCasts the object to a unit dual quaternion by copying. UnitDualQuaternion&lt; Type &gt; &amp; cast2UnitDualQuaternionRef () Casts the object to a unit dual quaternion reference without copying. UnitQuaternion&lt; Type &gt; cast2UnitQuaternion () constCasts the object to a unit quaternion by copying. UnitQuaternion&lt; Type &gt; &amp; cast2UnitQuaternionRef () Casts the object to a unit quaternion reference without copying. Vector&lt; N, Type &gt; cast2Vector () constCasts the object to a vector by copying. Vector&lt; N, Type &gt; &amp; cast2VectorRef () Casts the object to a vector reference without copying. NewContainer castContainer () constCasts the matrix to a different container type by copying. NewContainer &amp; castContainerRef () Casts the object to a different container reference without copying. NewDerived &amp; castContainerRef ()  auto castDataType () constReturns the Frobenius norm. Matrix&lt; N, 1, Type &gt; col (size_t j) constReturns the j-th column. void copyTo (Type * data) constReturns the raw data pointer. void fill (const Type &amp; v) Fills the matrix with a value. Type frobeniusNorm () const Type frobeniusNormSquared () constReturns the squared Frobenius norm. Type * getData () const const Type &amp; operator() (size_t i, size_t j) constAccesses the element at (i, j) Type &amp; operator() (size_t i, size_t j) Accesses the element at (i, j) auto operator* (const OtherDerived &amp; other) constMatrix multiplication. Derived operator* (const Type &amp; v) constMatrix multiplication by scalar. void operator*= (const OtherDerived &amp; other) Matrix multiplication by scalar. Derived operator+ (const OtherDerived &amp; other) constMultiplication by scalar. void operator+= (const OtherDerived &amp; other) Matrix division by scalar. Derived operator- (const OtherDerived &amp; other) constMatrix subtraction. Derived operator- () constMatrix multiplication by scalar. void operator-= (const OtherDerived &amp; other) Matrix subtraction by scalar. Derived operator/ (Type v) constDivision by scalar. void operator/= (Type v) Division by scalar. Derived &amp; operator= (const Derived &amp; other) Copies the data to the given pointer. void print () constPrints the matrix. Matrix&lt; 1, M, Type &gt; row (size_t i) constReturns the i-th row. Derived &amp; setBlock (size_t i, size_t j, const OtherDerived &amp; block) Sets the element at (i, j) Derived &amp; setBlock (const OtherDerived &amp; block) Sets the i-th row. Derived &amp; setCol (size_t j, const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setCol (const OtherDerived &amp; col) Sets the j-th column. Derived &amp; setRow (size_t i, const OtherDerived &amp; row) Sets the i-th row. Derived &amp; setRow (const OtherDerived &amp; row) Sets the i-th row. void swapCols (size_t j1, size_t j2) Swaps two columns. void swapRows (size_t i1, size_t i2) Swaps two rows. Type toScalar () constCasts the matrix to a scalar if it is a 1x1 matrix."},{"location":"translotator/classtranslotator_1_1Vector/#public-static-functions-inherited-from-translotatormatrixbase","title":"Public Static Functions inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Derived NaN () Returns a matrix filled with NaN. constexpr static size_t colSize () Returns the number of rows. Derived eye () Returns an identity matrix. Derived ones () Returns a matrix filled with ones. constexpr static size_t rowSize ()  Derived zeros () Returns a matrix filled with zeros."},{"location":"translotator/classtranslotator_1_1Vector/#protected-attributes-inherited-from-translotatormatrixbase","title":"Protected Attributes inherited from translotator::MatrixBase","text":"<p>See translotator::MatrixBase</p> Type Name Type data_"},{"location":"translotator/classtranslotator_1_1Vector/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>N</code> vector size </li> <li><code>Type</code> floating point type</li> </ul> <p>Vector class is a class that represents a vector. </p>"},{"location":"translotator/classtranslotator_1_1Vector/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/classtranslotator_1_1Vector/#variable-object_type","title":"variable OBJECT_TYPE","text":"<pre><code>constexpr static ObjectType translotator::Vector&lt; N, Type &gt;::OBJECT_TYPE;\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Vector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1Vector/#function-cross","title":"function cross","text":"<p>cross product operation <pre><code>template&lt;size_t Dim, typename&gt;\ninline Vector &lt; 3, Type &gt; translotator::Vector::cross (\n    const Vector &lt; 3, Type &gt; &amp; other\n) const\n</code></pre></p> <p>Note:</p> <p>only for 3D vector </p>"},{"location":"translotator/classtranslotator_1_1Vector/#function-dot","title":"function dot","text":"<p>in-place normalize <pre><code>inline Type translotator::Vector::dot (\n    const Vector &lt; N, Type &gt; &amp; other\n) const\n</code></pre></p> <p>Vector utils dot product </p>"},{"location":"translotator/classtranslotator_1_1Vector/#function-norm","title":"function norm","text":"<pre><code>inline Type translotator::Vector::norm () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Vector/#function-normsquared","title":"function normSquared","text":"<pre><code>inline Type translotator::Vector::normSquared () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Vector/#function-normalize","title":"function normalize","text":"<pre><code>inline void translotator::Vector::normalize () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1Vector/#function-normalized","title":"function normalized","text":"<p>return squared norm of vector <pre><code>inline Vector &lt; N, Type &gt; translotator::Vector::normalized () const\n</code></pre></p> <p>return normalized vector </p>"},{"location":"translotator/classtranslotator_1_1Vector/#function-operator","title":"function operator[]","text":"<pre><code>inline Type &amp; translotator::Vector::operator[] (\n    size_t i\n) \n</code></pre> <p>Vector Specialized Accessors </p>"},{"location":"translotator/classtranslotator_1_1Vector/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const Type &amp; translotator::Vector::operator[] (\n    size_t i\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1Vector/#function-tocrossmatrix","title":"function toCrossMatrix","text":"<p>convert to cross matrix <pre><code>template&lt;size_t Dim, typename&gt;\ninline SquareMatrix &lt; 3, Type &gt; translotator::Vector::toCrossMatrix () const\n</code></pre></p> <p>Note:</p> <p>only for 3D vector </p>"},{"location":"translotator/classtranslotator_1_1Vector/#function-todiagmatrix","title":"function toDiagMatrix","text":"<pre><code>inline SquareMatrix &lt; N, Type &gt; translotator::Vector::toDiagMatrix () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/Vector.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1all__same/","title":"Struct translotator::all_same","text":"<p>template &lt;typename T, typename... Args&gt;</p> <p>ClassList &gt; translotator &gt; all_same</p> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1all__same_3_01T_01_4/","title":"Struct translotator::all_same&lt; T &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; translotator &gt; all_same&lt; T &gt;</p>"},{"location":"translotator/structtranslotator_1_1all__same_3_01T_01_4/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr bool value   = = true"},{"location":"translotator/structtranslotator_1_1all__same_3_01T_01_4/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/structtranslotator_1_1all__same_3_01T_01_4/#variable-value","title":"variable value","text":"<pre><code>constexpr bool translotator::all_same&lt; T &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1all__same_3_01T_00_01First_00_01Rest_8_8_8_01_4/","title":"Struct translotator::all_same&lt; T, First, Rest... &gt;","text":"<p>template &lt;typename T, typename First, typename... Rest&gt;</p> <p>ClassList &gt; translotator &gt; all_same&lt; T, First, Rest... &gt;</p>"},{"location":"translotator/structtranslotator_1_1all__same_3_01T_00_01First_00_01Rest_8_8_8_01_4/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr bool value   = = is_same_v&lt;T, First&gt; &amp;&amp; all_same&lt;T, Rest...&gt;::value"},{"location":"translotator/structtranslotator_1_1all__same_3_01T_00_01First_00_01Rest_8_8_8_01_4/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/structtranslotator_1_1all__same_3_01T_00_01First_00_01Rest_8_8_8_01_4/#variable-value","title":"variable value","text":"<pre><code>constexpr bool translotator::all_same&lt; T, First, Rest... &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1conditional__if/","title":"Struct translotator::conditional_if","text":"<p>template &lt;bool B, typename T, typename F&gt;</p> <p>ClassList &gt; translotator &gt; conditional_if</p>"},{"location":"translotator/structtranslotator_1_1conditional__if/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"translotator/structtranslotator_1_1conditional__if/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1conditional__if/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::conditional_if&lt; B, T, F &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1conditional__if_3_01false_00_01T_00_01F_01_4/","title":"Struct translotator::conditional_if&lt; false, T, F &gt;","text":"<p>template &lt;typename T, typename F&gt;</p> <p>ClassList &gt; translotator &gt; conditional_if&lt; false, T, F &gt;</p>"},{"location":"translotator/structtranslotator_1_1conditional__if_3_01false_00_01T_00_01F_01_4/#public-types","title":"Public Types","text":"Type Name typedef F type"},{"location":"translotator/structtranslotator_1_1conditional__if_3_01false_00_01T_00_01F_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1conditional__if_3_01false_00_01T_00_01F_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::conditional_if&lt; false, T, F &gt;::type =  F;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1enable__if/","title":"Struct translotator::enable_if","text":"<p>template &lt;bool B, typename T&gt;</p> <p>ClassList &gt; translotator &gt; enable_if</p> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1enable__if_3_01true_00_01T_01_4/","title":"Struct translotator::enable_if&lt; true, T &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; translotator &gt; enable_if&lt; true, T &gt;</p>"},{"location":"translotator/structtranslotator_1_1enable__if_3_01true_00_01T_01_4/#public-types","title":"Public Types","text":"Type Name typedef T type"},{"location":"translotator/structtranslotator_1_1enable__if_3_01true_00_01T_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1enable__if_3_01true_00_01T_01_4/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::enable_if&lt; true, T &gt;::type =  T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1initializer__list/","title":"Struct translotator::initializer_list","text":"<p>template &lt;size_t N, typename Type&gt;</p> <p>ClassList &gt; translotator &gt; initializer_list</p> <p>initializer_list structMore...</p> <ul> <li><code>#include &lt;initializer_list.hpp&gt;</code></li> </ul>"},{"location":"translotator/structtranslotator_1_1initializer__list/#public-attributes","title":"Public Attributes","text":"Type Name Type data"},{"location":"translotator/structtranslotator_1_1initializer__list/#public-functions","title":"Public Functions","text":"Type Name initializer_list (Args... args)"},{"location":"translotator/structtranslotator_1_1initializer__list/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>N</code> size of the list </li> <li><code>Type</code> type of the list</li> </ul> <p>This struct is used to initialize the list with the same type and size. Usaully used for matrix-based object's initialization. </p>"},{"location":"translotator/structtranslotator_1_1initializer__list/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"translotator/structtranslotator_1_1initializer__list/#variable-data","title":"variable data","text":"<pre><code>Type translotator::initializer_list&lt; N, Type &gt;::data[N];\n</code></pre>"},{"location":"translotator/structtranslotator_1_1initializer__list/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/structtranslotator_1_1initializer__list/#function-initializer_list","title":"function initializer_list","text":"<pre><code>template&lt;typename... Args&gt;\ninline translotator::initializer_list::initializer_list (\n    Args... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/objects/initializer_list.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1integral__constant/","title":"Struct translotator::integral_constant","text":"<p>template &lt;typename T, T v&gt;</p> <p>ClassList &gt; translotator &gt; integral_constant</p> <p>Inherited by the following classes: translotator::is_float,  translotator::is_float&lt; double &gt;,  translotator::is_float&lt; float &gt;,  translotator::is_float&lt; long double &gt;,  translotator::is_matrix_base,  translotator::is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt;,  translotator::is_same,  translotator::is_same&lt; T, T &gt;</p>"},{"location":"translotator/structtranslotator_1_1integral__constant/#public-types","title":"Public Types","text":"Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1integral__constant/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1integral__constant/#public-functions","title":"Public Functions","text":"Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const"},{"location":"translotator/structtranslotator_1_1integral__constant/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1integral__constant/#typedef-type","title":"typedef type","text":"<pre><code>using translotator::integral_constant&lt; T, v &gt;::type =  integral_constant;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1integral__constant/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using translotator::integral_constant&lt; T, v &gt;::value_type =  T;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1integral__constant/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"translotator/structtranslotator_1_1integral__constant/#variable-value","title":"variable value","text":"<pre><code>constexpr T translotator::integral_constant&lt; T, v &gt;::value;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1integral__constant/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/structtranslotator_1_1integral__constant/#function-operator-value_type","title":"function operator value_type","text":"<pre><code>inline constexpr translotator::integral_constant::operator value_type () noexcept const\n</code></pre>"},{"location":"translotator/structtranslotator_1_1integral__constant/#function-operator","title":"function operator()","text":"<pre><code>inline constexpr value_type translotator::integral_constant::operator() () noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/namespacetranslotator_1_1interpolators/","title":"Namespace translotator::interpolators","text":"<p>Namespace List &gt; translotator &gt; interpolators</p>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#classes","title":"Classes","text":"Type Name class Lerper &lt;typename Container&gt;Linear interpolation class. class ScLerper &lt;typename Container&gt;Screw linear interpolation class. class SlerpLerper &lt;typename Container&gt;Slerp for rotation component, lerp for translation component class. class Slerper &lt;typename Container&gt;Slerp for rotation component interpolation class. class SlerperFast &lt;typename Container&gt;Slerp for rotation component interpolation class. Faster than Slerper for S1, S3 group."},{"location":"translotator/namespacetranslotator_1_1interpolators/#public-functions","title":"Public Functions","text":"Type Name Container LerpDiff (const Container &amp; start, const Container &amp; end) Linear interpolation. Container Lerping (const Container &amp; start, const Container &amp; end, typename Container::DATATYPE t) Linear interpolation. auto ScLerpDiff (const Container &amp; start, const Container &amp; end) Screw linear interpolation. auto ScLerping (const Container &amp; start, const Container &amp; end, Type t)  auto SlerpDiff (const Container &amp; start, const Container &amp; end)  auto SlerpLerpDiff (const Container &amp; start, const Container &amp; end) Slerp for rotation component, lerp for translation component between start and end. auto SlerpLerping (const Container &amp; start, const Container &amp; end, Type t) Slerp for rotation component, lerp for translation component interpolation. auto Slerping (const Container &amp; start, const Container &amp; end, Type t) Slerp for rotation component interpolation."},{"location":"translotator/namespacetranslotator_1_1interpolators/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-lerpdiff","title":"function LerpDiff","text":"<p>Linear interpolation. <pre><code>template&lt;typename Container&gt;\nContainer translotator::interpolators::LerpDiff (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Returns:</p> <p>Linear difference between start and end </p>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-lerping","title":"function Lerping","text":"<p>Linear interpolation. <pre><code>template&lt;typename Container&gt;\nContainer translotator::interpolators::Lerping (\n    const Container &amp; start,\n    const Container &amp; end,\n    typename Container::DATATYPE t\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Returns:</p> <p>Linear interpolation between start and end </p>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-sclerpdiff","title":"function ScLerpDiff","text":"<p>Screw linear interpolation. <pre><code>template&lt;typename Container&gt;\nauto translotator::interpolators::ScLerpDiff (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Returns:</p> <p>Screw linear difference between start and end </p>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-sclerping","title":"function ScLerping","text":"<pre><code>template&lt;typename Container, typename Type&gt;\nauto translotator::interpolators::ScLerping (\n    const Container &amp; start,\n    const Container &amp; end,\n    Type t\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-slerpdiff","title":"function SlerpDiff","text":"<pre><code>template&lt;typename Container&gt;\nauto translotator::interpolators::SlerpDiff (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-slerplerpdiff","title":"function SlerpLerpDiff","text":"<p>Slerp for rotation component, lerp for translation component between start and end. <pre><code>template&lt;typename Container&gt;\nauto translotator::interpolators::SlerpLerpDiff (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Returns:</p> <p>difference between start and end </p>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-slerplerping","title":"function SlerpLerping","text":"<p>Slerp for rotation component, lerp for translation component interpolation. <pre><code>template&lt;typename Container, typename Type&gt;\nauto translotator::interpolators::SlerpLerping (\n    const Container &amp; start,\n    const Container &amp; end,\n    Type t\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Returns:</p> <p>Slerp linear interpolation between start and end </p>"},{"location":"translotator/namespacetranslotator_1_1interpolators/#function-slerping","title":"function Slerping","text":"<p>Slerp for rotation component interpolation. <pre><code>template&lt;typename Container, typename Type&gt;\nauto translotator::interpolators::Slerping (\n    const Container &amp; start,\n    const Container &amp; end,\n    Type t\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Returns:</p> <p>Slerp linear interpolation between start and end </p> <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Lerp.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/","title":"Class translotator::interpolators::Lerper","text":"<p>template &lt;typename Container&gt;</p> <p>ClassList &gt; translotator &gt; interpolators &gt; Lerper</p> <p>Linear interpolation class. More...</p> <ul> <li><code>#include &lt;Lerp.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#public-functions","title":"Public Functions","text":"Type Name Lerper () = default Lerper (const Container &amp; start, const Container &amp; end)  const Container &amp; getDiff () const const Container &amp; getEnd () const const Container &amp; getStart () constUpdate difference between start and end. Container interpolate (ScalarType t) constLerp operation for Lerper . Container operator() (ScalarType t) constLerp operation for Lerper . void setDiff (const Container &amp; diff)  void setEnd (const Container &amp; end)  void setStart (const Container &amp; start)  void updateDiff ()  ~Lerper () = default"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-lerper-12","title":"function Lerper [1/2]","text":"<pre><code>translotator::interpolators::Lerper::Lerper () = default\n</code></pre> <p>constructor </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-lerper-22","title":"function Lerper [2/2]","text":"<pre><code>inline translotator::interpolators::Lerper::Lerper (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-getdiff","title":"function getDiff","text":"<pre><code>inline const Container &amp; translotator::interpolators::Lerper::getDiff () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-getend","title":"function getEnd","text":"<pre><code>inline const Container &amp; translotator::interpolators::Lerper::getEnd () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-getstart","title":"function getStart","text":"<p>Update difference between start and end. <pre><code>inline const Container &amp; translotator::interpolators::Lerper::getStart () const\n</code></pre></p> <p>getter &amp; setter </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-interpolate","title":"function interpolate","text":"<pre><code>inline Container translotator::interpolators::Lerper::interpolate (\n    ScalarType t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-operator","title":"function operator()","text":"<pre><code>inline Container translotator::interpolators::Lerper::operator() (\n    ScalarType t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-setdiff","title":"function setDiff","text":"<pre><code>inline void translotator::interpolators::Lerper::setDiff (\n    const Container &amp; diff\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-setend","title":"function setEnd","text":"<pre><code>inline void translotator::interpolators::Lerper::setEnd (\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-setstart","title":"function setStart","text":"<pre><code>inline void translotator::interpolators::Lerper::setStart (\n    const Container &amp; start\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-updatediff","title":"function updateDiff","text":"<pre><code>inline void translotator::interpolators::Lerper::updateDiff () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Lerper/#function-lerper","title":"function ~Lerper","text":"<pre><code>translotator::interpolators::Lerper::~Lerper () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Lerp.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/","title":"Class translotator::interpolators::ScLerper","text":"<p>template &lt;typename Container&gt;</p> <p>ClassList &gt; translotator &gt; interpolators &gt; ScLerper</p> <p>Screw linear interpolation class. More...</p> <ul> <li><code>#include &lt;ScLerp.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#public-functions","title":"Public Functions","text":"Type Name ScLerper () = default ScLerper (const Container &amp; start, const Container &amp; end)  Container getDiff () const Container getEnd () const Container getStart () constUpdate difference between start and end. Container interpolate (Type t) ScLerp operation for ScLerper . Container operator() (Type t) constScLerp operation for ScLerper . void setDiff (const Container &amp; diff)  void setEnd (const Container &amp; end)  void setStart (const Container &amp; start)  void updateDiff ()  ~ScLerper () = default"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-sclerper-12","title":"function ScLerper [1/2]","text":"<pre><code>translotator::interpolators::ScLerper::ScLerper () = default\n</code></pre> <p>constructor </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-sclerper-22","title":"function ScLerper [2/2]","text":"<pre><code>inline translotator::interpolators::ScLerper::ScLerper (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-getdiff","title":"function getDiff","text":"<pre><code>inline Container translotator::interpolators::ScLerper::getDiff () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-getend","title":"function getEnd","text":"<pre><code>inline Container translotator::interpolators::ScLerper::getEnd () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-getstart","title":"function getStart","text":"<p>Update difference between start and end. <pre><code>inline Container translotator::interpolators::ScLerper::getStart () const\n</code></pre></p> <p>getter and setter </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-interpolate","title":"function interpolate","text":"<pre><code>inline Container translotator::interpolators::ScLerper::interpolate (\n    Type t\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-operator","title":"function operator()","text":"<pre><code>inline Container translotator::interpolators::ScLerper::operator() (\n    Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-setdiff","title":"function setDiff","text":"<pre><code>inline void translotator::interpolators::ScLerper::setDiff (\n    const Container &amp; diff\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-setend","title":"function setEnd","text":"<pre><code>inline void translotator::interpolators::ScLerper::setEnd (\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-setstart","title":"function setStart","text":"<pre><code>inline void translotator::interpolators::ScLerper::setStart (\n    const Container &amp; start\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-updatediff","title":"function updateDiff","text":"<pre><code>inline void translotator::interpolators::ScLerper::updateDiff () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1ScLerper/#function-sclerper","title":"function ~ScLerper","text":"<pre><code>translotator::interpolators::ScLerper::~ScLerper () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/ScLerp.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/","title":"Class translotator::interpolators::SlerpLerper","text":"<p>template &lt;typename Container&gt;</p> <p>ClassList &gt; translotator &gt; interpolators &gt; SlerpLerper</p> <p>Slerp for rotation component, lerp for translation component class. More...</p> <ul> <li><code>#include &lt;Slerp_Lerp.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#public-functions","title":"Public Functions","text":"Type Name SlerpLerper () = default SlerpLerper (const Container &amp; start, const Container &amp; end)  const Container &amp; getDiff () const const Container &amp; getEnd () const const Container &amp; getStart () constUpdate difference between start and end. Container interpolate (Type t) constSlerpLerp operation for SlerpLerper . Container operator() (Type t) constSlerpLerp operation for SlerpLerper . void setDiff (const Container &amp; diff)  void setEnd (const Container &amp; end)  void setStart (const Container &amp; start)  void updateDiff ()  ~SlerpLerper () = default"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-slerplerper-12","title":"function SlerpLerper [1/2]","text":"<pre><code>translotator::interpolators::SlerpLerper::SlerpLerper () = default\n</code></pre> <p>constructor </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-slerplerper-22","title":"function SlerpLerper [2/2]","text":"<pre><code>inline translotator::interpolators::SlerpLerper::SlerpLerper (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-getdiff","title":"function getDiff","text":"<pre><code>inline const Container &amp; translotator::interpolators::SlerpLerper::getDiff () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-getend","title":"function getEnd","text":"<pre><code>inline const Container &amp; translotator::interpolators::SlerpLerper::getEnd () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-getstart","title":"function getStart","text":"<p>Update difference between start and end. <pre><code>inline const Container &amp; translotator::interpolators::SlerpLerper::getStart () const\n</code></pre></p> <p>getter &amp; setter </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-interpolate","title":"function interpolate","text":"<pre><code>inline Container translotator::interpolators::SlerpLerper::interpolate (\n    Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-operator","title":"function operator()","text":"<pre><code>inline Container translotator::interpolators::SlerpLerper::operator() (\n    Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-setdiff","title":"function setDiff","text":"<pre><code>inline void translotator::interpolators::SlerpLerper::setDiff (\n    const Container &amp; diff\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-setend","title":"function setEnd","text":"<pre><code>inline void translotator::interpolators::SlerpLerper::setEnd (\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-setstart","title":"function setStart","text":"<pre><code>inline void translotator::interpolators::SlerpLerper::setStart (\n    const Container &amp; start\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-updatediff","title":"function updateDiff","text":"<pre><code>inline void translotator::interpolators::SlerpLerper::updateDiff () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerpLerper/#function-slerplerper","title":"function ~SlerpLerper","text":"<pre><code>translotator::interpolators::SlerpLerper::~SlerpLerper () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Slerp_Lerp.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/","title":"Class translotator::interpolators::Slerper","text":"<p>template &lt;typename Container&gt;</p> <p>ClassList &gt; translotator &gt; interpolators &gt; Slerper</p> <p>Slerp for rotation component interpolation class. More...</p> <ul> <li><code>#include &lt;Slerp.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#public-functions","title":"Public Functions","text":"Type Name Slerper () = default Slerper (const Container &amp; start, const Container &amp; end)  const Container &amp; getDiff () const const Container &amp; getEnd () const const Container &amp; getStart () constUpdate difference between start and end. Container interpolate (Type t) constSlerp operation for Slerper . Container operator() (Type t) constSlerp operation for Slerper . void setDiff (const Container &amp; diff)  void setEnd (const Container &amp; end)  void setStart (const Container &amp; start)  void updateDiff ()  ~Slerper () = default"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Note:</p> <p>Implemented using Exp &amp; Log Lie Group opearation </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-slerper-12","title":"function Slerper [1/2]","text":"<pre><code>translotator::interpolators::Slerper::Slerper () = default\n</code></pre> <p>constructor </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-slerper-22","title":"function Slerper [2/2]","text":"<pre><code>inline translotator::interpolators::Slerper::Slerper (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-getdiff","title":"function getDiff","text":"<pre><code>inline const Container &amp; translotator::interpolators::Slerper::getDiff () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-getend","title":"function getEnd","text":"<pre><code>inline const Container &amp; translotator::interpolators::Slerper::getEnd () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-getstart","title":"function getStart","text":"<p>Update difference between start and end. <pre><code>inline const Container &amp; translotator::interpolators::Slerper::getStart () const\n</code></pre></p> <p>getter &amp; setter </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-interpolate","title":"function interpolate","text":"<pre><code>inline Container translotator::interpolators::Slerper::interpolate (\n    Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-operator","title":"function operator()","text":"<pre><code>inline Container translotator::interpolators::Slerper::operator() (\n    Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-setdiff","title":"function setDiff","text":"<pre><code>inline void translotator::interpolators::Slerper::setDiff (\n    const Container &amp; diff\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-setend","title":"function setEnd","text":"<pre><code>inline void translotator::interpolators::Slerper::setEnd (\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-setstart","title":"function setStart","text":"<pre><code>inline void translotator::interpolators::Slerper::setStart (\n    const Container &amp; start\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-updatediff","title":"function updateDiff","text":"<pre><code>inline void translotator::interpolators::Slerper::updateDiff () \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1Slerper/#function-slerper","title":"function ~Slerper","text":"<pre><code>translotator::interpolators::Slerper::~Slerper () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Slerp.hpp</code></p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/","title":"Class translotator::interpolators::SlerperFast","text":"<p>template &lt;typename Container&gt;</p> <p>ClassList &gt; translotator &gt; interpolators &gt; SlerperFast</p> <p>Slerp for rotation component interpolation class. Faster than Slerper for S1, S3 group.More...</p> <ul> <li><code>#include &lt;Slerp.hpp&gt;</code></li> </ul>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#public-functions","title":"Public Functions","text":"Type Name SlerperFast () = default SlerperFast (const Container &amp; start, const Container &amp; end)  const Container &amp; getEnd () const const Container &amp; getStart () const Container interpolate (Type t) constSlerp operation for SlerperFast . Container operator() (Type t) constSlerp operation for SlerperFast . void setEnd (const Container &amp; end)  void setStart (const Container &amp; start)  void update_theta () Update theta and shortest_path. ~SlerperFast () = default"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Container</code> Matrix base type </li> </ul> <p>Note:</p> <p>Implemented using Exp &amp; Log Lie Group opearation </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-slerperfast-12","title":"function SlerperFast [1/2]","text":"<pre><code>translotator::interpolators::SlerperFast::SlerperFast () = default\n</code></pre> <p>constructor </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-slerperfast-22","title":"function SlerperFast [2/2]","text":"<pre><code>inline translotator::interpolators::SlerperFast::SlerperFast (\n    const Container &amp; start,\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-getend","title":"function getEnd","text":"<pre><code>inline const Container &amp; translotator::interpolators::SlerperFast::getEnd () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-getstart","title":"function getStart","text":"<pre><code>inline const Container &amp; translotator::interpolators::SlerperFast::getStart () const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-interpolate","title":"function interpolate","text":"<pre><code>inline Container translotator::interpolators::SlerperFast::interpolate (\n    Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-operator","title":"function operator()","text":"<pre><code>inline Container translotator::interpolators::SlerperFast::operator() (\n    Type t\n) const\n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-setend","title":"function setEnd","text":"<pre><code>inline void translotator::interpolators::SlerperFast::setEnd (\n    const Container &amp; end\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-setstart","title":"function setStart","text":"<pre><code>inline void translotator::interpolators::SlerperFast::setStart (\n    const Container &amp; start\n) \n</code></pre>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-update_theta","title":"function update_theta","text":"<p>Update theta and shortest_path. <pre><code>inline void translotator::interpolators::SlerperFast::update_theta () \n</code></pre></p> <p>Note:</p> <p>Call this function after changing start or end </p>"},{"location":"translotator/classtranslotator_1_1interpolators_1_1SlerperFast/#function-slerperfast","title":"function ~SlerperFast","text":"<pre><code>translotator::interpolators::SlerperFast::~SlerperFast () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Slerp.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__float/","title":"Struct translotator::is_float","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; translotator &gt; is_float</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__float/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__float/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__float/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__float_3_01double_01_4/","title":"Struct translotator::is_float&lt; double &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; translotator &gt; is_float&lt; double &gt;</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__float_3_01double_01_4/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__float_3_01double_01_4/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__float_3_01double_01_4/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__float_3_01float_01_4/","title":"Struct translotator::is_float&lt; float &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; translotator &gt; is_float&lt; float &gt;</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__float_3_01float_01_4/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__float_3_01float_01_4/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__float_3_01float_01_4/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__float_3_01long_01double_01_4/","title":"Struct translotator::is_float&lt; long double &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; translotator &gt; is_float&lt; long double &gt;</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__float_3_01long_01double_01_4/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__float_3_01long_01double_01_4/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__float_3_01long_01double_01_4/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__matrix__base/","title":"Struct translotator::is_matrix_base","text":"<p>template &lt;typename T, typename&gt;</p> <p>ClassList &gt; translotator &gt; is_matrix_base</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__matrix__base/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__matrix__base/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__matrix__base/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__matrix__base_3_01T_00_01typename_01enable__if_3_01T_1_1MATRIX__BASE_01_4_1_1type_01_4/","title":"Struct translotator::is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; translotator &gt; is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt;</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__matrix__base_3_01T_00_01typename_01enable__if_3_01T_1_1MATRIX__BASE_01_4_1_1type_01_4/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__matrix__base_3_01T_00_01typename_01enable__if_3_01T_1_1MATRIX__BASE_01_4_1_1type_01_4/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__matrix__base_3_01T_00_01typename_01enable__if_3_01T_1_1MATRIX__BASE_01_4_1_1type_01_4/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__same/","title":"Struct translotator::is_same","text":"<p>template &lt;typename T, typename U&gt;</p> <p>ClassList &gt; translotator &gt; is_same</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__same/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__same/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__same/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1is__same_3_01T_00_01T_01_4/","title":"Struct translotator::is_same&lt; T, T &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; translotator &gt; is_same&lt; T, T &gt;</p> <p>Inherits the following classes: translotator::integral_constant</p>"},{"location":"translotator/structtranslotator_1_1is__same_3_01T_00_01T_01_4/#public-types-inherited-from-translotatorintegral_constant","title":"Public Types inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name typedef integral_constant type typedef T value_type"},{"location":"translotator/structtranslotator_1_1is__same_3_01T_00_01T_01_4/#public-static-attributes-inherited-from-translotatorintegral_constant","title":"Public Static Attributes inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr T value   = = v"},{"location":"translotator/structtranslotator_1_1is__same_3_01T_00_01T_01_4/#public-functions-inherited-from-translotatorintegral_constant","title":"Public Functions inherited from translotator::integral_constant","text":"<p>See translotator::integral_constant</p> Type Name constexpr operator value_type () noexcept const constexpr value_type operator() () noexcept const <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/namespacetranslotator_1_1lie/","title":"Namespace translotator::lie","text":"<p>Namespace List &gt; translotator &gt; lie</p> <p>Namespace for Lie Group and Algebra Operations. </p>"},{"location":"translotator/namespacetranslotator_1_1lie/#classes","title":"Classes","text":"Type Name struct LieOperator &lt;oType, typename dataType&gt;Lie Operator for Lie Group and Lie Algebra. struct LieOperator&lt; ObjectType::SE_GROUP, Type &gt; &lt;typename Type&gt;Lie Operator for SE. struct LieOperator&lt; ObjectType::SO_GROUP, Type &gt; &lt;typename Type&gt;Special Orthogonal Group. struct LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt; &lt;typename Type&gt;Lie Operator for S1. struct LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt; &lt;typename Type&gt;Lie Operator for S3."},{"location":"translotator/namespacetranslotator_1_1lie/#public-types","title":"Public Types","text":"Type Name typedef LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt; LieOperator_S1 typedef LieOperator_S1&lt; double &gt; LieOperator_S1d typedef LieOperator_S1&lt; float &gt; LieOperator_S1f typedef LieOperator_S1&lt; long double &gt; LieOperator_S1ld typedef LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt; LieOperator_S3 typedef LieOperator_S3&lt; double &gt; LieOperator_S3d typedef LieOperator_S3&lt; float &gt; LieOperator_S3f typedef LieOperator_S3&lt; long double &gt; LieOperator_S3ld typedef LieOperator&lt; ObjectType::SE_GROUP, Type &gt; LieOperator_SE typedef LieOperator_SE&lt; double &gt; LieOperator_SEd typedef LieOperator_SE&lt; float &gt; LieOperator_SEf typedef LieOperator_SE&lt; long double &gt; LieOperator_SEld typedef LieOperator&lt; ObjectType::SO_GROUP, Type &gt; LieOperator_SO typedef LieOperator_SO&lt; double &gt; LieOperator_SOd typedef LieOperator_SO&lt; float &gt; LieOperator_SOf typedef LieOperator_SO&lt; long double &gt; LieOperator_SOld"},{"location":"translotator/namespacetranslotator_1_1lie/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s1","title":"typedef LieOperator_S1","text":"<pre><code>using translotator::lie::LieOperator_S1 = typedef LieOperator&lt;ObjectType::UNIT_COMPLEX_NUM, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s1d","title":"typedef LieOperator_S1d","text":"<pre><code>using translotator::lie::LieOperator_S1d = typedef LieOperator_S1&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s1f","title":"typedef LieOperator_S1f","text":"<pre><code>using translotator::lie::LieOperator_S1f = typedef LieOperator_S1&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s1ld","title":"typedef LieOperator_S1ld","text":"<pre><code>using translotator::lie::LieOperator_S1ld = typedef LieOperator_S1&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s3","title":"typedef LieOperator_S3","text":"<pre><code>using translotator::lie::LieOperator_S3 = typedef LieOperator&lt;ObjectType::UNIT_QUATERNION, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s3d","title":"typedef LieOperator_S3d","text":"<pre><code>using translotator::lie::LieOperator_S3d = typedef LieOperator_S3&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s3f","title":"typedef LieOperator_S3f","text":"<pre><code>using translotator::lie::LieOperator_S3f = typedef LieOperator_S3&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_s3ld","title":"typedef LieOperator_S3ld","text":"<pre><code>using translotator::lie::LieOperator_S3ld = typedef LieOperator_S3&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_se","title":"typedef LieOperator_SE","text":"<pre><code>using translotator::lie::LieOperator_SE = typedef LieOperator&lt;ObjectType::SE_GROUP, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_sed","title":"typedef LieOperator_SEd","text":"<pre><code>using translotator::lie::LieOperator_SEd = typedef LieOperator_SE&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_sef","title":"typedef LieOperator_SEf","text":"<pre><code>using translotator::lie::LieOperator_SEf = typedef LieOperator_SE&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_seld","title":"typedef LieOperator_SEld","text":"<pre><code>using translotator::lie::LieOperator_SEld = typedef LieOperator_SE&lt;long double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_so","title":"typedef LieOperator_SO","text":"<pre><code>using translotator::lie::LieOperator_SO = typedef LieOperator&lt;ObjectType::SO_GROUP, Type&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_sod","title":"typedef LieOperator_SOd","text":"<pre><code>using translotator::lie::LieOperator_SOd = typedef LieOperator_SO&lt;double&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_sof","title":"typedef LieOperator_SOf","text":"<pre><code>using translotator::lie::LieOperator_SOf = typedef LieOperator_SO&lt;float&gt;;\n</code></pre>"},{"location":"translotator/namespacetranslotator_1_1lie/#typedef-lieoperator_sold","title":"typedef LieOperator_SOld","text":"<pre><code>using translotator::lie::LieOperator_SOld = typedef LieOperator_SO&lt;long double&gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/lie/LieOperator.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator/","title":"Struct translotator::lie::LieOperator","text":"<p>template &lt;ObjectType oType, typename dataType&gt;</p> <p>ClassList &gt; translotator &gt; lie &gt; LieOperator</p> <p>Lie Operator for Lie Group and Lie Algebra. More...</p> <ul> <li><code>#include &lt;LieOperator.hpp&gt;</code></li> </ul>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>oType</code> Object type </li> <li><code>dataType</code> Data type </li> </ul> <p>The documentation for this class was generated from the following file <code>include/translotator/lie/LieOperator.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/","title":"Struct translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; lie &gt; LieOperator&lt; ObjectType::SE_GROUP, Type &gt;</p> <p>Lie Operator for SE. More...</p> <ul> <li><code>#include &lt;SE.hpp&gt;</code></li> </ul>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#public-types","title":"Public Types","text":"Type Name typedef SquareMatrix&lt; N+1, Type &gt; LieAlgebraType typedef SEGroup&lt; N, Type &gt; LieGroupType typedef Vector&lt; N==2 ? 3 :6, Type &gt; VectorType"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name LieGroupType&lt; 2 &gt; Exp (const VectorType&lt; 2 &gt; &amp; isomorphicVec) Exponential map. LieGroupType&lt; 3 &gt; Exp (const VectorType&lt; 3 &gt; &amp; isomorphicVec) Exponential map. VectorType&lt; 2 &gt; LieAlgebra2Vector (const LieAlgebraType&lt; 2 &gt; &amp; lieAlgebra) Convert SE(2) Lie Algebra to Vector . VectorType&lt; 3 &gt; LieAlgebra2Vector (const LieAlgebraType&lt; 3 &gt; &amp; lieAlgebra) Convert SE(3) Lie Algebra to Vector . VectorType&lt; 2 &gt; Log (const LieGroupType&lt; 2 &gt; &amp; lieGroup) Logarithm map. VectorType&lt; 3 &gt; Log (const LieGroupType&lt; 3 &gt; &amp; lieGroup) Logarithm map. LieAlgebraType&lt; 2 &gt; Vector2LieAlgebra (const VectorType&lt; 2 &gt; &amp; isomorphicVec) Convert Vector to SE(2) Lie Algebra. LieAlgebraType&lt; 3 &gt; Vector2LieAlgebra (const VectorType&lt; 3 &gt; &amp; isomorphicVec) Convert Vector to SE(3) Lie Algebra. LieGroupType&lt; 2 &gt; exp (const LieAlgebraType&lt; 2 &gt; &amp; lieAlgebra) Exponential map. LieGroupType&lt; 3 &gt; exp (const LieAlgebraType&lt; 3 &gt; &amp; lieAlgebra) Exponential map. LieAlgebraType&lt; 2 &gt; log (const LieGroupType&lt; 2 &gt; &amp; lieGroup) Logarithm map. LieAlgebraType&lt; 3 &gt; log (const LieGroupType&lt; 3 &gt; &amp; lieGroup) Logarithm map."},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> Data type</li> </ul> <p>SE is a Special Euclidean Group </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#typedef-liealgebratype","title":"typedef LieAlgebraType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::LieAlgebraType =  SquareMatrix&lt;N + 1, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#typedef-liegrouptype","title":"typedef LieGroupType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::LieGroupType =  SEGroup&lt;N, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::VectorType =  Vector&lt;N == 2 ? 3 : 6, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-exp-12","title":"function Exp [1/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::Exp (\n    const VectorType &lt; 2 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [3x1], [theta, x, y] </li> </ul> <p>Returns:</p> <p>Lie Group SE(2) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-exp-22","title":"function Exp [2/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::Exp (\n    const VectorType &lt; 3 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [6x1], [theta_x, theta_y, theta_z, x, y, z] </li> </ul> <p>Returns:</p> <p>Lie Group SE(3) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-liealgebra2vector-12","title":"function LieAlgebra2Vector [1/2]","text":"<p>Convert SE(2) Lie Algebra to Vector . <pre><code>static inline VectorType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::LieAlgebra2Vector (\n    const LieAlgebraType &lt; 2 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [theta Vt; 0 0] </li> </ul> <p>Returns:</p> <p>Vector [3x1], [theta, x, y] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-liealgebra2vector-22","title":"function LieAlgebra2Vector [2/2]","text":"<p>Convert SE(3) Lie Algebra to Vector . <pre><code>static inline VectorType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::LieAlgebra2Vector (\n    const LieAlgebraType &lt; 3 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [theta Vt; 0 0] </li> </ul> <p>Returns:</p> <p>Vector [6x1], [theta_x, theta_y, theta_z, x, y, z] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-log-12","title":"function Log [1/2]","text":"<p>Logarithm map. <pre><code>static inline VectorType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::Log (\n    const LieGroupType &lt; 2 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SE(2) </li> </ul> <p>Returns:</p> <p>Vector [3x1], [theta, x, y] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-log-22","title":"function Log [2/2]","text":"<p>Logarithm map. <pre><code>static inline VectorType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::Log (\n    const LieGroupType &lt; 3 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SE(3) </li> </ul> <p>Returns:</p> <p>Vector [6x1], [theta_x, theta_y, theta_z, x, y, z] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-vector2liealgebra-12","title":"function Vector2LieAlgebra [1/2]","text":"<p>Convert Vector to SE(2) Lie Algebra. <pre><code>static inline LieAlgebraType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::Vector2LieAlgebra (\n    const VectorType &lt; 2 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [3x1], [theta, x, y] </li> </ul> <p>Returns:</p> <p>Lie Algebra [3x3] [theta Vt; 0 0] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-vector2liealgebra-22","title":"function Vector2LieAlgebra [2/2]","text":"<p>Convert Vector to SE(3) Lie Algebra. <pre><code>static inline LieAlgebraType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::Vector2LieAlgebra (\n    const VectorType &lt; 3 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [6x1], [theta_x, theta_y, theta_z, x, y, z] </li> </ul> <p>Returns:</p> <p>Lie Algebra [4x4] [theta Vt; 0 0] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-exp-12_1","title":"function exp [1/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::exp (\n    const LieAlgebraType &lt; 2 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [3x3] [theta Vt; 0 0] </li> </ul> <p>Returns:</p> <p>Lie Group SE(2) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-exp-22_1","title":"function exp [2/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::exp (\n    const LieAlgebraType &lt; 3 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [4x4] [theta Vt; 0 0] </li> </ul> <p>Returns:</p> <p>Lie Group SE(3) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-log-12_1","title":"function log [1/2]","text":"<p>Logarithm map. <pre><code>static inline LieAlgebraType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::log (\n    const LieGroupType &lt; 2 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SE(2) </li> </ul> <p>Returns:</p> <p>Lie Algebra [3x3] [theta Vt; 0 0] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SE__GROUP_00_01Type_01_4/#function-log-22_1","title":"function log [2/2]","text":"<p>Logarithm map. <pre><code>static inline LieAlgebraType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;::log (\n    const LieGroupType &lt; 3 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SE(3) </li> </ul> <p>Returns:</p> <p>Lie Algebra [4x4] [theta Vt; 0 0] </p> <p>The documentation for this class was generated from the following file <code>include/translotator/lie/SE.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/","title":"Struct translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; lie &gt; LieOperator&lt; ObjectType::SO_GROUP, Type &gt;</p> <p>Special Orthogonal Group. More...</p> <ul> <li><code>#include &lt;SO.hpp&gt;</code></li> </ul>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#public-types","title":"Public Types","text":"Type Name typedef SquareMatrix&lt; N, Type &gt; LieAlgebraType typedef SOGroup&lt; N, Type &gt; LieGroupType typedef Vector&lt; N==2 ? 1 :3, Type &gt; VectorType"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name LieGroupType&lt; 2 &gt; Exp (const VectorType&lt; 2 &gt; &amp; isomorphicVec) Exponential map. LieGroupType&lt; 3 &gt; Exp (const VectorType&lt; 3 &gt; &amp; isomorphicVec) Exponential map. VectorType&lt; 2 &gt; LieAlgebra2Vector (const LieAlgebraType&lt; 2 &gt; &amp; lieAlgebra) Convert Lie Algebra to Vector . VectorType&lt; 3 &gt; LieAlgebra2Vector (const LieAlgebraType&lt; 3 &gt; &amp; lieAlgebra) Convert Lie Algebra to Vector . VectorType&lt; 2 &gt; Log (const LieGroupType&lt; 2 &gt; &amp; lieGroup) Logarithm map. VectorType&lt; 3 &gt; Log (const LieGroupType&lt; 3 &gt; &amp; lieGroup) Logarithm map. LieAlgebraType&lt; 2 &gt; Vector2LieAlgebra (const VectorType&lt; 2 &gt; &amp; isomorphicVec) Convert Vector to Lie Algebra. LieAlgebraType&lt; 3 &gt; Vector2LieAlgebra (const VectorType&lt; 3 &gt; &amp; isomorphicVec) Convert Vector to Lie Algebra. LieGroupType&lt; 2 &gt; exp (const LieAlgebraType&lt; 2 &gt; &amp; lieAlgebra) Exponential map. LieGroupType&lt; 3 &gt; exp (const LieAlgebraType&lt; 3 &gt; &amp; lieAlgebra) Exponential map. LieAlgebraType&lt; 2 &gt; log (const LieGroupType&lt; 2 &gt; &amp; lieGroup) Logarithm map. LieAlgebraType&lt; 3 &gt; log (const LieGroupType&lt; 3 &gt; &amp; lieGroup) Logarithm map."},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>N</code> Dimension </li> <li><code>Type</code> Data type</li> </ul> <p>SO is a Special Orthogonal Group </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#typedef-liealgebratype","title":"typedef LieAlgebraType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::LieAlgebraType =  SquareMatrix&lt;N, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#typedef-liegrouptype","title":"typedef LieGroupType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::LieGroupType =  SOGroup&lt;N, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::VectorType =  Vector&lt;N == 2 ? 1 : 3, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-exp-12","title":"function Exp [1/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::Exp (\n    const VectorType &lt; 2 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [1x1], [theta] </li> </ul> <p>Returns:</p> <p>Lie Group SO(2) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-exp-22","title":"function Exp [2/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::Exp (\n    const VectorType &lt; 3 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [3x1], [x, y, z] </li> </ul> <p>Returns:</p> <p>Lie Group SO(3) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-liealgebra2vector-12","title":"function LieAlgebra2Vector [1/2]","text":"<p>Convert Lie Algebra to Vector . <pre><code>static inline VectorType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::LieAlgebra2Vector (\n    const LieAlgebraType &lt; 2 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [2x2] [0 -theta; theta 0] </li> </ul> <p>Returns:</p> <p>Vector [1x1], [theta] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-liealgebra2vector-22","title":"function LieAlgebra2Vector [2/2]","text":"<p>Convert Lie Algebra to Vector . <pre><code>static inline VectorType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::LieAlgebra2Vector (\n    const LieAlgebraType &lt; 3 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [3x3] [0 -z y; z 0 -x; -y x 0] </li> </ul> <p>Returns:</p> <p>Vector [3x1], [x, y, z] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-log-12","title":"function Log [1/2]","text":"<p>Logarithm map. <pre><code>static inline VectorType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::Log (\n    const LieGroupType &lt; 2 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SO(2) </li> </ul> <p>Returns:</p> <p>Vector [1x1], [theta] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-log-22","title":"function Log [2/2]","text":"<p>Logarithm map. <pre><code>static inline VectorType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::Log (\n    const LieGroupType &lt; 3 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SO(3) </li> </ul> <p>Returns:</p> <p>Vector [3x1], [x, y, z] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-vector2liealgebra-12","title":"function Vector2LieAlgebra [1/2]","text":"<p>Convert Vector to Lie Algebra. <pre><code>static inline LieAlgebraType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::Vector2LieAlgebra (\n    const VectorType &lt; 2 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [1x1], [theta] </li> </ul> <p>Returns:</p> <p>Lie Algebra [2x2] [0 -theta; theta 0] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-vector2liealgebra-22","title":"function Vector2LieAlgebra [2/2]","text":"<p>Convert Vector to Lie Algebra. <pre><code>static inline LieAlgebraType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::Vector2LieAlgebra (\n    const VectorType &lt; 3 &gt; &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [3x1], [x, y, z] </li> </ul> <p>Returns:</p> <p>Lie Algebra [3x3] [0 -z y; z 0 -x; -y x 0] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-exp-12_1","title":"function exp [1/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::exp (\n    const LieAlgebraType &lt; 2 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [2x2] [0 -theta; theta 0] </li> </ul> <p>Returns:</p> <p>Lie Group SO(2) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-exp-22_1","title":"function exp [2/2]","text":"<p>Exponential map. <pre><code>static inline LieGroupType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::exp (\n    const LieAlgebraType &lt; 3 &gt; &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [3x3] [0 -z y; z 0 -x; -y x 0] </li> </ul> <p>Returns:</p> <p>Lie Group SO(3) </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-log-12_1","title":"function log [1/2]","text":"<p>Logarithm map. <pre><code>static inline LieAlgebraType &lt; 2 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::log (\n    const LieGroupType &lt; 2 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SO(2) </li> </ul> <p>Returns:</p> <p>Lie Algebra [2x2] [0 -theta; theta 0] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1SO__GROUP_00_01Type_01_4/#function-log-22_1","title":"function log [2/2]","text":"<p>Logarithm map. <pre><code>static inline LieAlgebraType &lt; 3 &gt; translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;::log (\n    const LieGroupType &lt; 3 &gt; &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group SO(3) </li> </ul> <p>Returns:</p> <p>Lie Algebra [3x3] [0 -z y; z 0 -x; -y x 0] </p> <p>The documentation for this class was generated from the following file <code>include/translotator/lie/SO.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/","title":"Struct translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; lie &gt; LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;</p> <p>Lie Operator for S1. More...</p> <ul> <li><code>#include &lt;S1.hpp&gt;</code></li> </ul>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#public-types","title":"Public Types","text":"Type Name typedef ComplexNum&lt; Type &gt; LieAlgebraType typedef UnitComplexNum&lt; Type &gt; LieGroupType typedef Vector&lt; 1, Type &gt; VectorType"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name LieGroupType Exp (const VectorType &amp; vec) Exponential map. VectorType LieAlgebra2Vector (const LieAlgebraType &amp; lieAlgebra) Convert Lie Algebra to Vector . VectorType Log (const LieGroupType &amp; lieGroup) Logarithm map. LieAlgebraType Vector2LieAlgebra (const VectorType &amp; isomorphicVec) Convert Vector to Lie Algebra. LieGroupType exp (const LieAlgebraType &amp; lieAlgebra) Exponential map. LieAlgebraType log (const LieGroupType &amp; lieGroup) Logarithm map."},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> Data type</li> </ul> <p>S1 is a unit complex number </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#typedef-liealgebratype","title":"typedef LieAlgebraType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::LieAlgebraType =  ComplexNum&lt;Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#typedef-liegrouptype","title":"typedef LieGroupType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::LieGroupType =  UnitComplexNum&lt;Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::VectorType =  Vector&lt;1, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#function-exp","title":"function Exp","text":"<p>Exponential map. <pre><code>static inline LieGroupType translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::Exp (\n    const VectorType &amp; vec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>vec</code> Vector [1x1], [angle] </li> </ul> <p>Returns:</p> <p>Lie Group S1, Unit Complex Number </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#function-liealgebra2vector","title":"function LieAlgebra2Vector","text":"<p>Convert Lie Algebra to Vector . <pre><code>static inline VectorType translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::LieAlgebra2Vector (\n    const LieAlgebraType &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [2x1] 0+angle*i, pure imaginary number </li> </ul> <p>Returns:</p> <p>Vector [1x1], [angle] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#function-log","title":"function Log","text":"<p>Logarithm map. <pre><code>static inline VectorType translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::Log (\n    const LieGroupType &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group S1, Unit Complex Number </li> </ul> <p>Returns:</p> <p>Vector [1x1], [angle] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#function-vector2liealgebra","title":"function Vector2LieAlgebra","text":"<p>Convert Vector to Lie Algebra. <pre><code>static inline LieAlgebraType translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::Vector2LieAlgebra (\n    const VectorType &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [1x1], [angle] </li> </ul> <p>Returns:</p> <p>Lie Algebra [2x1] 0+angle*i, pure imaginary number </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#function-exp_1","title":"function exp","text":"<p>Exponential map. <pre><code>static inline LieGroupType translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::exp (\n    const LieAlgebraType &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [2x1] 0+angle*i, pure imaginary number </li> </ul> <p>Returns:</p> <p>Lie Group S1, Unit Complex Number </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__COMPLEX__NUM_00_01Type_01_4/#function-log_1","title":"function log","text":"<p>Logarithm map. <pre><code>static inline LieAlgebraType translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;::log (\n    const LieGroupType &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group S1, Unit Complex Number </li> </ul> <p>Returns:</p> <p>Lie Algebra [2x1] 0+angle*i, pure imaginary number </p> <p>The documentation for this class was generated from the following file <code>include/translotator/lie/S1.hpp</code></p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/","title":"Struct translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;","text":"<p>template &lt;typename Type&gt;</p> <p>ClassList &gt; translotator &gt; lie &gt; LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;</p> <p>Lie Operator for S3. More...</p> <ul> <li><code>#include &lt;S3.hpp&gt;</code></li> </ul>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#public-types","title":"Public Types","text":"Type Name typedef Quaternion&lt; Type &gt; LieAlgebraType typedef UnitQuaternion&lt; Type &gt; LieGroupType typedef Vector&lt; 3, Type &gt; VectorType"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name LieGroupType Exp (const VectorType &amp; isomorphicVec) Exponential map. VectorType LieAlgebra2Vector (const LieAlgebraType &amp; lieAlgebra) Convert Lie Algebra to Vector . VectorType Log (const LieGroupType &amp; lieGroup) Logarithm map. LieAlgebraType Vector2LieAlgebra (const VectorType &amp; isomorphicVec) Convert Vector to Lie Algebra. LieGroupType exp (const LieAlgebraType &amp; lieAlgebra) Exponential map. LieAlgebraType log (const LieGroupType &amp; lieGroup) Logarithm map."},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>Type</code> Data type</li> </ul> <p>S3 is a unit quaternion </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#typedef-liealgebratype","title":"typedef LieAlgebraType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::LieAlgebraType =  Quaternion&lt;Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#typedef-liegrouptype","title":"typedef LieGroupType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::LieGroupType =  UnitQuaternion&lt;Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#typedef-vectortype","title":"typedef VectorType","text":"<pre><code>using translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::VectorType =  Vector&lt;3, Type&gt;;\n</code></pre>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#function-exp","title":"function Exp","text":"<p>Exponential map. <pre><code>static inline LieGroupType translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::Exp (\n    const VectorType &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [3x1], [x, y, z] </li> </ul> <p>Returns:</p> <p>Lie Group [4x1] Unit Quaternion </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#function-liealgebra2vector","title":"function LieAlgebra2Vector","text":"<p>Convert Lie Algebra to Vector . <pre><code>static inline VectorType translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::LieAlgebra2Vector (\n    const LieAlgebraType &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [4x1] 0+x*i+y*j+z*k, pure imaginary number </li> </ul> <p>Returns:</p> <p>Vector [3x1], [x, y, z] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#function-log","title":"function Log","text":"<p>Logarithm map. <pre><code>static inline VectorType translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::Log (\n    const LieGroupType &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group [4x1] Unit Quaternion </li> </ul> <p>Returns:</p> <p>Vector [3x1], [x, y, z] </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#function-vector2liealgebra","title":"function Vector2LieAlgebra","text":"<p>Convert Vector to Lie Algebra. <pre><code>static inline LieAlgebraType translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::Vector2LieAlgebra (\n    const VectorType &amp; isomorphicVec\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>isomorphicVec</code> Vector [3x1], [x, y, z] </li> </ul> <p>Returns:</p> <p>Lie Algebra [4x1] 0+x*i+y*j+z*k, pure imaginary number </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#function-exp_1","title":"function exp","text":"<p>Exponential map. <pre><code>static inline LieGroupType translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::exp (\n    const LieAlgebraType &amp; lieAlgebra\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieAlgebra</code> Lie Algebra [4x1] 0+x*i+y*j+z*k, pure imaginary number </li> </ul> <p>Returns:</p> <p>Lie Group [4x1] Unit Quaternion </p>"},{"location":"translotator/structtranslotator_1_1lie_1_1LieOperator_3_01ObjectType_1_1UNIT__QUATERNION_00_01Type_01_4/#function-log_1","title":"function log","text":"<p>Logarithm map. <pre><code>static inline LieAlgebraType translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;::log (\n    const LieGroupType &amp; lieGroup\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>lieGroup</code> Lie Group [4x1] Unit Quaternion </li> </ul> <p>Returns:</p> <p>Lie Algebra [4x1] 0+x*i+y*j+z*k, pure imaginary number </p> <p>The documentation for this class was generated from the following file <code>include/translotator/lie/S3.hpp</code></p>"},{"location":"translotator/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir include","text":"<p>FileList &gt; include</p>"},{"location":"translotator/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Type Name dir translotator <p>The documentation for this class was generated from the following file <code>include/</code></p>"},{"location":"translotator/dir_ffa3503b73a46a1fbf73d754da62ba14/","title":"Dir include/translotator","text":"<p>FileList &gt; include &gt; translotator</p>"},{"location":"translotator/dir_ffa3503b73a46a1fbf73d754da62ba14/#files","title":"Files","text":"Type Name file config.hpp file translotator.hpp file version.hpp"},{"location":"translotator/dir_ffa3503b73a46a1fbf73d754da62ba14/#directories","title":"Directories","text":"Type Name dir interpolators dir lie dir objects dir utils <p>The documentation for this class was generated from the following file <code>include/translotator/</code></p>"},{"location":"translotator/config_8hpp/","title":"File config.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; config.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/config_8hpp/#macros","title":"Macros","text":"Type Name define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_128_EPSILON  16 define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32  1 define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32_EPSILON  4 define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_64_EPSILON  10"},{"location":"translotator/config_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"translotator/config_8hpp/#define-config_translotator_default_floating_point_precision_128_epsilon","title":"define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_128_EPSILON","text":"<pre><code>#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_128_EPSILON 16\n</code></pre>"},{"location":"translotator/config_8hpp/#define-config_translotator_default_floating_point_precision_32","title":"define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32","text":"<pre><code>#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32 1\n</code></pre>"},{"location":"translotator/config_8hpp/#define-config_translotator_default_floating_point_precision_32_epsilon","title":"define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32_EPSILON","text":"<pre><code>#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32_EPSILON 4\n</code></pre>"},{"location":"translotator/config_8hpp/#define-config_translotator_default_floating_point_precision_64_epsilon","title":"define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_64_EPSILON","text":"<pre><code>#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_64_EPSILON 10\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/config.hpp</code></p>"},{"location":"translotator/config_8hpp_source/","title":"File config.hpp","text":"<p>File List &gt; include &gt; translotator &gt; config.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32 1\n#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32_EPSILON 4\n#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_64_EPSILON 10\n#define CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_128_EPSILON 16\n</code></pre>"},{"location":"translotator/dir_b0f52d96602c2240130b99aee8b7fd2d/","title":"Dir include/translotator/interpolators","text":"<p>FileList &gt; include &gt; translotator &gt; interpolators</p>"},{"location":"translotator/dir_b0f52d96602c2240130b99aee8b7fd2d/#files","title":"Files","text":"Type Name file Lerp.hpp file ScLerp.hpp file Slerp.hpp file Slerp_Lerp.hpp <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/</code></p>"},{"location":"translotator/Lerp_8hpp/","title":"File Lerp.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; interpolators &gt; Lerp.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/Lerp_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace interpolators"},{"location":"translotator/Lerp_8hpp/#classes","title":"Classes","text":"Type Name class Lerper &lt;typename Container&gt;Linear interpolation class. <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Lerp.hpp</code></p>"},{"location":"translotator/Lerp_8hpp_source/","title":"File Lerp.hpp","text":"<p>File List &gt; include &gt; translotator &gt; interpolators &gt; Lerp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : Lerp.hpp\n */\n\n#pragma once\n\nnamespace translotator::interpolators\n{\n    template &lt;typename Container&gt;\n    Container LerpDiff(const Container &amp;start, const Container &amp;end)\n    {\n        static_assert(is_matrix_base_v&lt;Container&gt;, \"Invalid type for Lerp. Must have matrix base\");\n        return end - start;\n    }\n\n    template &lt;typename Container&gt;\n    Container Lerping(const Container &amp;start, const Container &amp;end, typename Container::DATATYPE t)\n    {\n        static_assert(is_matrix_base_v&lt;Container&gt;, \"Invalid type for Lerp. Must have matrix base\");\n        return start + LerpDiff(start, end) * t;\n    }\n\n    template &lt;typename Container&gt;\n    class Lerper\n    {\n        static_assert(is_matrix_base_v&lt;Container&gt;, \"Invalid type for Lerper. Must have matrix base\");\n\n    private:\n        Container start_;\n        Container end_;\n        Container diff_;\n\n        using ScalarType = typename Container::DATATYPE;\n\n    public:\n        Lerper() = default;\n        Lerper(const Container &amp;start, const Container &amp;end) : start_(start), end_(end), diff_(LerpDiff(start, end)) {}\n        ~Lerper() = default;\n\n        inline Container operator()(ScalarType t) const \n        {\n            return start_ + diff_ * t;\n        }\n        inline Container interpolate(ScalarType t) const \n        {\n            return start_ + diff_ * t;\n        }\n        inline void updateDiff() { diff_ = LerpDiff(start_, end_); } \n\n        inline const Container &amp;getStart() const { return start_; }\n        inline const Container &amp;getEnd() const { return end_; }\n        inline const Container &amp;getDiff() const { return diff_; }\n\n        inline void setStart(const Container &amp;start) { start_ = start; }\n        inline void setEnd(const Container &amp;end) { end_ = end; }\n        inline void setDiff(const Container &amp;diff) { diff_ = diff; }\n    };\n\n}\n</code></pre>"},{"location":"translotator/ScLerp_8hpp/","title":"File ScLerp.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; interpolators &gt; ScLerp.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/ScLerp_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace interpolators"},{"location":"translotator/ScLerp_8hpp/#classes","title":"Classes","text":"Type Name class ScLerper &lt;typename Container&gt;Screw linear interpolation class. <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/ScLerp.hpp</code></p>"},{"location":"translotator/ScLerp_8hpp_source/","title":"File ScLerp.hpp","text":"<p>File List &gt; include &gt; translotator &gt; interpolators &gt; ScLerp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : ScLerp.hpp\n */\n\n#pragma once\n\nnamespace translotator::interpolators\n{\n    template &lt;typename Container&gt;\n    auto ScLerpDiff(const Container &amp;start, const Container &amp;end)\n    {\n        using Type = typename Container::DATATYPE;\n        static_assert(is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for ScLerp. Must one of SE2, SE3\");\n\n        return start.inversed() * end;\n    }\n\n    /***\n     * @brief Screw linear interpolation\n     * @tparam Container Matrix base type\n     * @return Screw linear interpolation between start and end\n     */\n    template &lt;typename Container, typename Type&gt;\n    auto ScLerping(const Container &amp;start, const Container &amp;end, Type t)\n    {\n        static_assert(is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for ScLerp. Must one of SE2, SE3\");\n\n        const Container diff = ScLerpDiff(start, end);\n        return start * diff.pow(t);\n    }\n\n    template &lt;typename Container&gt;\n    class ScLerper\n    {\n        using Type = typename Container::DATATYPE;\n        static_assert(is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for ScLerper. Must one of SE2, SE3\");\n\n    private:\n        Container start_;\n        Container end_;\n        Container diff_;\n\n    public:\n        ScLerper() = default;\n        ScLerper(const Container &amp;start, const Container &amp;end) : start_(start), end_(end), diff_(ScLerpDiff(start, end)) {}\n        ~ScLerper() = default;\n\n        inline Container operator()(Type t) const \n        {\n            return start_ * diff_.pow(t);\n        }\n        inline Container interpolate(Type t) \n        {\n            return start_ * diff_.pow(t);\n        }\n        inline void updateDiff() { diff_ = ScLerpDiff(start_, end_); } \n\n        inline Container getStart() const { return start_; }\n        inline Container getEnd() const { return end_; }\n        inline Container getDiff() const { return diff_; }\n\n        inline void setStart(const Container &amp;start) { start_ = start; }\n        inline void setEnd(const Container &amp;end) { end_ = end; }\n        inline void setDiff(const Container &amp;diff) { diff_ = diff; }\n    };\n\n}\n</code></pre>"},{"location":"translotator/Slerp_8hpp/","title":"File Slerp.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; interpolators &gt; Slerp.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/Slerp_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace interpolators"},{"location":"translotator/Slerp_8hpp/#classes","title":"Classes","text":"Type Name class Slerper &lt;typename Container&gt;Slerp for rotation component interpolation class. class SlerperFast &lt;typename Container&gt;Slerp for rotation component interpolation class. Faster than Slerper for S1, S3 group. <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Slerp.hpp</code></p>"},{"location":"translotator/Slerp_8hpp_source/","title":"File Slerp.hpp","text":"<p>File List &gt; include &gt; translotator &gt; interpolators &gt; Slerp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : Slerp.hpp\n */\n\n#pragma once\n\nnamespace translotator::interpolators\n{\n    /***\n     * @brief Slerp for rotation component interpolation\n     * @tparam Container Matrix base type\n     * @return Slerp difference between start and end\n     */\n    template &lt;typename Container&gt;\n    auto SlerpDiff(const Container &amp;start, const Container &amp;end)\n    {\n        using Type = typename Container::DATATYPE;\n        static_assert(is_same_v&lt;Container, UnitComplexNum&lt;Type&gt;&gt; ||\n                          is_same_v&lt;Container, UnitQuaternion&lt;Type&gt;&gt; ||\n                          is_same_v&lt;Container, SOGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SOGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for Slerp. Must one of UnitComplexNum, UnitQuaternion, SO2, SO3\");\n\n        return start.inversed() * end;\n    }\n\n    template &lt;typename Container, typename Type&gt;\n    auto Slerping(const Container &amp;start, const Container &amp;end, Type t)\n    {\n        static_assert(is_same_v&lt;Container, UnitComplexNum&lt;Type&gt;&gt; ||\n                          is_same_v&lt;Container, UnitQuaternion&lt;Type&gt;&gt; ||\n                          is_same_v&lt;Container, SOGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SOGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for Slerp. Must one of UnitComplexNum, UnitQuaternion, SO2, SO3\");\n\n        if constexpr (is_same_v&lt;Container, UnitComplexNum&lt;Type&gt;&gt;)\n        {\n            return start * SlerpDiff(start, end).pow(t);\n        }\n        else if constexpr (is_same_v&lt;Container, UnitQuaternion&lt;Type&gt;&gt;)\n        {\n            const Type dot_product = start.w() * end.w() + start.x() * end.x() + start.y() * end.y() + start.z() * end.z();\n            const Type theta = translotator::acos(dot_product);\n            if (translotator::abs(theta) &lt; translotator::epsilon&lt;Type&gt;())\n            {\n                return start;\n            }\n            const Type shortest_path = dot_product &lt; static_cast&lt;Type&gt;(0) ? static_cast&lt;Type&gt;(-1) : static_cast&lt;Type&gt;(1);\n            const Type a = translotator::sin((1 - t) * theta) / translotator::sin(theta);\n            const Type b = translotator::sin(t * theta) * shortest_path / translotator::sin(theta);\n            return UnitQuaternion&lt;Type&gt;{a * start.w() + b * end.w(),\n                                        a * start.x() + b * end.x(),\n                                        a * start.y() + b * end.y(),\n                                        a * start.z() + b * end.z()};\n        }\n        else if constexpr (is_same_v&lt;Container, SOGroup&lt;2, Type&gt;&gt; ||\n                           is_same_v&lt;Container, SOGroup&lt;3, Type&gt;&gt;)\n        {\n            return start * SlerpDiff(start, end).pow(t);\n        }\n    }\n\n    template &lt;typename Container&gt;\n    class Slerper\n    {\n        using Type = typename Container::DATATYPE;\n        static_assert(is_same_v&lt;Container, UnitComplexNum&lt;Type&gt;&gt; ||\n                          is_same_v&lt;Container, UnitQuaternion&lt;Type&gt;&gt; ||\n                          is_same_v&lt;Container, SOGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SOGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for Slerper. Must one of UnitComplexNum, UnitQuaternion, SO2, SO3\");\n\n    private:\n        Container start_;\n        Container end_;\n        Container diff_;\n\n    public:\n        Slerper() = default;\n        Slerper(const Container &amp;start, const Container &amp;end) : start_(start), end_(end), diff_(SlerpDiff(start, end)) {}\n        ~Slerper() = default;\n\n        inline Container operator()(Type t) const \n        {\n            return start_ * diff_.pow(t);\n        }\n        inline Container interpolate(Type t) const \n        {\n            return start_ * diff_.pow(t);\n        }\n        inline void updateDiff() { diff_ = SlerpDiff(start_, end_); } \n\n        inline const Container &amp;getStart() const { return start_; }\n        inline const Container &amp;getEnd() const { return end_; }\n        inline const Container &amp;getDiff() const { return diff_; }\n\n        inline void setStart(const Container &amp;start) { start_ = start; }\n        inline void setEnd(const Container &amp;end) { end_ = end; }\n        inline void setDiff(const Container &amp;diff) { diff_ = diff; }\n    };\n\n    template &lt;typename Container&gt;\n    class SlerperFast\n    {\n        using Type = typename Container::DATATYPE;\n        static_assert(is_same_v&lt;Container, UnitComplexNum&lt;Type&gt;&gt; ||\n                          is_same_v&lt;Container, UnitQuaternion&lt;Type&gt;&gt;,\n                      \"Invalid type for SlerperFast. Must one of UnitComplexNum, UnitQuaternion\");\n\n    private:\n        Container start_;\n        Container end_;\n        Type theta_;\n        Type shortest_path_;\n\n    public:\n        SlerperFast() = default;\n        SlerperFast(const Container &amp;start, const Container &amp;end) : start_(start), end_(end)\n        {\n            update_theta();\n        }\n        ~SlerperFast() = default;\n\n        inline Container operator()(Type t) const \n        {\n            const Type a = translotator::sin((1 - t) * theta_) / translotator::sin(theta_);\n            const Type b = translotator::sin(t * theta_) / translotator::sin(theta_) * shortest_path_;\n            if constexpr (is_same_v&lt;Container, UnitComplexNum&lt;Type&gt;&gt;)\n            {\n                return Container{a * start_.Re() + b * end_.Re(),\n                                 a * start_.Im() + b * end_.Im()};\n            }\n            else if constexpr (is_same_v&lt;Container, UnitQuaternion&lt;Type&gt;&gt;)\n            {\n                return Container{a * start_.w() + b * end_.w(),\n                                 a * start_.x() + b * end_.x(),\n                                 a * start_.y() + b * end_.y(),\n                                 a * start_.z() + b * end_.z()};\n            }\n        }\n        inline Container interpolate(Type t) const \n        {\n            return operator()(t);\n        }\n\n        inline const Container &amp;getStart() const { return start_; }\n        inline const Container &amp;getEnd() const { return end_; }\n\n        inline void setStart(const Container &amp;start) { start_ = start; }\n        inline void setEnd(const Container &amp;end) { end_ = end; }\n\n        inline void update_theta()\n        {\n            Type dot;\n            if constexpr (is_same_v&lt;Container, UnitComplexNum&lt;Type&gt;&gt;)\n            {\n                dot = start_.Re() * end_.Re() + start_.Im() * end_.Im();\n            }\n            else if constexpr (is_same_v&lt;Container, UnitQuaternion&lt;Type&gt;&gt;)\n            {\n                dot = start_.w() * end_.w() + start_.x() * end_.x() + start_.y() * end_.y() + start_.z() * end_.z();\n            }\n            shortest_path_ = dot &lt; static_cast&lt;Type&gt;(0) ? static_cast&lt;Type&gt;(-1) : static_cast&lt;Type&gt;(1);\n            theta_ = translotator::acos(dot);\n        }\n    };\n}\n</code></pre>"},{"location":"translotator/Slerp__Lerp_8hpp/","title":"File Slerp_Lerp.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; interpolators &gt; Slerp_Lerp.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/Slerp__Lerp_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace interpolators"},{"location":"translotator/Slerp__Lerp_8hpp/#classes","title":"Classes","text":"Type Name class SlerpLerper &lt;typename Container&gt;Slerp for rotation component, lerp for translation component class. <p>The documentation for this class was generated from the following file <code>include/translotator/interpolators/Slerp_Lerp.hpp</code></p>"},{"location":"translotator/Slerp__Lerp_8hpp_source/","title":"File Slerp_Lerp.hpp","text":"<p>File List &gt; include &gt; translotator &gt; interpolators &gt; Slerp_Lerp.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : Slerp_Lerp.hpp\n */\n\n#pragma once\n\nnamespace translotator::interpolators\n{\n    template &lt;typename Container&gt;\n    auto SlerpLerpDiff(const Container &amp;start, const Container &amp;end)\n    {\n        using Type = typename Container::DATATYPE;\n        static_assert(is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for SlerpLerp. Must one of SE2, SE3\");\n\n        if constexpr (is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; || is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;)\n        {\n            return Container{SlerpDiff(start.rotation(), end.rotation()), LerpDiff(start.translation(), end.translation())};\n        }\n    }\n\n    template &lt;typename Container, typename Type&gt;\n    auto SlerpLerping(const Container &amp;start, const Container &amp;end, Type t)\n    {\n        static_assert(is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for SlerpLerp. Must one of SE2, SE3\");\n\n        if constexpr (is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; || is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;)\n        {\n            const Container diff = SlerpLerpDiff(start, end);\n            return Container{start.rotation() * diff.rotation().pow(t), start.translation() + diff.translation() * t};\n        }\n    }\n\n    template &lt;typename Container&gt;\n    class SlerpLerper\n    {\n        using Type = typename Container::DATATYPE;\n        static_assert(is_same_v&lt;Container, SEGroup&lt;2, Type&gt;&gt; ||\n                          is_same_v&lt;Container, SEGroup&lt;3, Type&gt;&gt;,\n                      \"Invalid type for SlerpLerper. Must one of SE2, SE3\");\n\n    private:\n        Container start_;\n        Container end_;\n        Container diff_;\n\n    public:\n        SlerpLerper() = default;\n        SlerpLerper(const Container &amp;start, const Container &amp;end) : start_(start), end_(end), diff_(SlerpLerpDiff(start, end)) {}\n        ~SlerpLerper() = default;\n\n        inline Container operator()(Type t) const \n        {\n            return interpolate(t);\n        }\n        inline Container interpolate(Type t) const \n        {\n            return Container{start_.rotation() * diff_.rotation().pow(t), start_.translation() + diff_.translation() * t};\n        }\n\n        inline void updateDiff() { diff_ = SlerpLerpDiff(start_, end_); } \n\n        inline const Container &amp;getStart() const { return start_; }\n        inline const Container &amp;getEnd() const { return end_; }\n        inline const Container &amp;getDiff() const { return diff_; }\n\n        inline void setStart(const Container &amp;start) { start_ = start; }\n        inline void setEnd(const Container &amp;end) { end_ = end; }\n        inline void setDiff(const Container &amp;diff) { diff_ = diff; }\n    };\n}\n</code></pre>"},{"location":"translotator/dir_8ed321f5373998308f124cc3f5af3597/","title":"Dir include/translotator/lie","text":"<p>FileList &gt; include &gt; translotator &gt; lie</p>"},{"location":"translotator/dir_8ed321f5373998308f124cc3f5af3597/#files","title":"Files","text":"Type Name file LieOperator.hpp file S1.hpp file S3.hpp file SE.hpp file SO.hpp <p>The documentation for this class was generated from the following file <code>include/translotator/lie/</code></p>"},{"location":"translotator/LieOperator_8hpp/","title":"File LieOperator.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; lie &gt; LieOperator.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"S1.hpp\"</code></li> <li><code>#include \"S3.hpp\"</code></li> <li><code>#include \"SO.hpp\"</code></li> <li><code>#include \"SE.hpp\"</code></li> </ul>"},{"location":"translotator/LieOperator_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace lie Namespace for Lie Group and Algebra Operations."},{"location":"translotator/LieOperator_8hpp/#classes","title":"Classes","text":"Type Name struct LieOperator &lt;oType, typename dataType&gt;Lie Operator for Lie Group and Lie Algebra. <p>The documentation for this class was generated from the following file <code>include/translotator/lie/LieOperator.hpp</code></p>"},{"location":"translotator/LieOperator_8hpp_source/","title":"File LieOperator.hpp","text":"<p>File List &gt; include &gt; translotator &gt; lie &gt; LieOperator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : LieOperator.hpp\n */\n\n#pragma once\n\nnamespace translotator::lie\n{\n    template &lt;ObjectType oType, typename dataType&gt;\n    struct LieOperator\n    {\n        static_assert(oType == ObjectType::UNIT_COMPLEX_NUM ||\n                          oType == ObjectType::UNIT_QUATERNION ||\n                          oType == ObjectType::SO_GROUP ||\n                          oType == ObjectType::SE_GROUP,\n                      \"Invalid type for LieOperator. Must have unit complex number, unit quaternion, SO group, or SE group\");\n\n        static_assert(is_float_v&lt;dataType&gt;, \"Invalid data type for LieOperator. Must be float\");\n    };\n\n}\n\n#include \"S1.hpp\"\n#include \"S3.hpp\"\n#include \"SO.hpp\"\n#include \"SE.hpp\"\n</code></pre>"},{"location":"translotator/S1_8hpp/","title":"File S1.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; lie &gt; S1.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/S1_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace lie Namespace for Lie Group and Algebra Operations."},{"location":"translotator/S1_8hpp/#classes","title":"Classes","text":"Type Name struct LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt; &lt;typename Type&gt;Lie Operator for S1. <p>The documentation for this class was generated from the following file <code>include/translotator/lie/S1.hpp</code></p>"},{"location":"translotator/S1_8hpp_source/","title":"File S1.hpp","text":"<p>File List &gt; include &gt; translotator &gt; lie &gt; S1.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : S1.hpp\n */\n\n#pragma once\n\nnamespace translotator::lie\n{\n    template &lt;typename Type&gt;\n    struct LieOperator&lt;ObjectType::UNIT_COMPLEX_NUM, Type&gt;\n    {\n        static_assert(is_float_v&lt;Type&gt;, \"Invalid data type for LieOperator. Must be float type\");\n\n        using LieGroupType = UnitComplexNum&lt;Type&gt;;\n        using LieAlgebraType = ComplexNum&lt;Type&gt;;\n        using VectorType = Vector&lt;1, Type&gt;;\n\n        static LieAlgebraType Vector2LieAlgebra(const VectorType &amp;isomorphicVec)\n        {\n            return LieAlgebraType{static_cast&lt;Type&gt;(0), isomorphicVec.toScalar()};\n        }\n\n        static VectorType LieAlgebra2Vector(const LieAlgebraType &amp;lieAlgebra)\n        {\n            return VectorType{lieAlgebra.Im()};\n        }\n\n        static LieGroupType Exp(const VectorType &amp;vec)\n        {\n            return LieGroupType{vec.toScalar()};\n        }\n\n        static VectorType Log(const LieGroupType &amp;lieGroup)\n        {\n            return VectorType{translotator::acos(lieGroup.Re())};\n        }\n\n        static LieGroupType exp(const LieAlgebraType &amp;lieAlgebra)\n        {\n            return Exp(LieAlgebra2Vector(lieAlgebra));\n        }\n\n        static LieAlgebraType log(const LieGroupType &amp;lieGroup)\n        {\n            return Vector2LieAlgebra(Log(lieGroup));\n        }\n    };\n\n    template &lt;typename Type&gt;\n    using LieOperator_S1 = LieOperator&lt;ObjectType::UNIT_COMPLEX_NUM, Type&gt;;\n    using LieOperator_S1f = LieOperator_S1&lt;float&gt;;\n    using LieOperator_S1d = LieOperator_S1&lt;double&gt;;\n    using LieOperator_S1ld = LieOperator_S1&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/S3_8hpp/","title":"File S3.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; lie &gt; S3.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/S3_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace lie Namespace for Lie Group and Algebra Operations."},{"location":"translotator/S3_8hpp/#classes","title":"Classes","text":"Type Name struct LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt; &lt;typename Type&gt;Lie Operator for S3. <p>The documentation for this class was generated from the following file <code>include/translotator/lie/S3.hpp</code></p>"},{"location":"translotator/S3_8hpp_source/","title":"File S3.hpp","text":"<p>File List &gt; include &gt; translotator &gt; lie &gt; S3.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : S3.hpp\n */\n\n#pragma once\n\nnamespace translotator::lie\n{\n    template &lt;typename Type&gt;\n    struct LieOperator&lt;ObjectType::UNIT_QUATERNION, Type&gt;\n    {\n        static_assert(is_float_v&lt;Type&gt;, \"Invalid data type for LieOperator. Must be float type\");\n        using LieGroupType = UnitQuaternion&lt;Type&gt;;\n        using LieAlgebraType = Quaternion&lt;Type&gt;;\n        using VectorType = Vector&lt;3, Type&gt;;\n\n        static LieAlgebraType Vector2LieAlgebra(const VectorType &amp;isomorphicVec)\n        {\n            return LieAlgebraType{static_cast&lt;Type&gt;(0), isomorphicVec};\n        }\n\n        static VectorType LieAlgebra2Vector(const LieAlgebraType &amp;lieAlgebra)\n        {\n            return lieAlgebra.Im();\n        }\n\n        static LieGroupType Exp(const VectorType &amp;isomorphicVec)\n        {\n            return LieGroupType{2 * isomorphicVec};\n        }\n\n        static VectorType Log(const LieGroupType &amp;lieGroup)\n        {\n            const Type w = lieGroup.Re();\n            if (translotator::abs(translotator::abs(w) - static_cast&lt;Type&gt;(1)) &lt; epsilon&lt;Type&gt;())\n            {\n                return VectorType::zeros();\n            }\n\n            const VectorType v = lieGroup.Im();\n\n            if (v.norm() &lt; epsilon&lt;Type&gt;())\n            {\n                return VectorType::zeros();\n            }\n\n            return v.normalized() * translotator::acos(w);\n        }\n\n        static LieGroupType exp(const LieAlgebraType &amp;lieAlgebra)\n        {\n            return Exp(LieAlgebra2Vector(lieAlgebra));\n        }\n\n        static LieAlgebraType log(const LieGroupType &amp;lieGroup)\n        {\n            return Vector2LieAlgebra(Log(lieGroup));\n        }\n    };\n\n    template &lt;typename Type&gt;\n    using LieOperator_S3 = LieOperator&lt;ObjectType::UNIT_QUATERNION, Type&gt;;\n    using LieOperator_S3f = LieOperator_S3&lt;float&gt;;\n    using LieOperator_S3d = LieOperator_S3&lt;double&gt;;\n    using LieOperator_S3ld = LieOperator_S3&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/SE_8hpp/","title":"File SE.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; lie &gt; SE.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/SE_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace lie Namespace for Lie Group and Algebra Operations."},{"location":"translotator/SE_8hpp/#classes","title":"Classes","text":"Type Name struct LieOperator&lt; ObjectType::SE_GROUP, Type &gt; &lt;typename Type&gt;Lie Operator for SE. <p>The documentation for this class was generated from the following file <code>include/translotator/lie/SE.hpp</code></p>"},{"location":"translotator/SE_8hpp_source/","title":"File SE.hpp","text":"<p>File List &gt; include &gt; translotator &gt; lie &gt; SE.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : SE.hpp\n */\n\n#pragma once\n\nnamespace translotator::lie\n{\n    template &lt;typename Type&gt;\n    struct LieOperator&lt;ObjectType::SE_GROUP, Type&gt;\n    {\n        template &lt;size_t N&gt;\n        using LieGroupType = SEGroup&lt;N, Type&gt;;\n        template &lt;size_t N&gt;\n        using LieAlgebraType = SquareMatrix&lt;N + 1, Type&gt;;\n        template &lt;size_t N&gt;\n        using VectorType = Vector&lt;N == 2 ? 3 : 6, Type&gt;;\n\n        static VectorType&lt;2&gt; LieAlgebra2Vector(const LieAlgebraType&lt;2&gt; &amp;lieAlgebra)\n        {\n            return VectorType&lt;2&gt;{{lieAlgebra(1, 0),\n                                  lieAlgebra(0, 2), lieAlgebra(1, 2)}};\n        }\n\n        static VectorType&lt;3&gt; LieAlgebra2Vector(const LieAlgebraType&lt;3&gt; &amp;lieAlgebra)\n        {\n            return VectorType&lt;3&gt;{{lieAlgebra(2, 1), lieAlgebra(0, 2), lieAlgebra(1, 0),\n                                  lieAlgebra(0, 3), lieAlgebra(1, 3), lieAlgebra(2, 3)}};\n        }\n\n        static LieAlgebraType&lt;2&gt; Vector2LieAlgebra(const VectorType&lt;2&gt; &amp;isomorphicVec) // [theta, x, y]\n        {\n            constexpr Type O = static_cast&lt;Type&gt;(0);\n            return LieAlgebraType&lt;2&gt;{{O, -isomorphicVec[0], isomorphicVec[1],\n                                      isomorphicVec[0], O, isomorphicVec[2],\n                                      O, O, O}};\n        }\n\n        static LieAlgebraType&lt;3&gt; Vector2LieAlgebra(const VectorType&lt;3&gt; &amp;isomorphicVec) // [theta_x, theta_y, theta_z, x, y, z]\n        {\n            constexpr Type O = static_cast&lt;Type&gt;(0);\n            return LieAlgebraType&lt;3&gt;{{O, -isomorphicVec[2], isomorphicVec[1], isomorphicVec[3],\n                                      isomorphicVec[2], O, -isomorphicVec[0], isomorphicVec[4],\n                                      -isomorphicVec[1], isomorphicVec[0], O, isomorphicVec[5],\n                                      O, O, O, O}};\n        }\n\n        static LieGroupType&lt;2&gt; Exp(const VectorType&lt;2&gt; &amp;isomorphicVec)\n        {\n            constexpr Type O = static_cast&lt;Type&gt;(0);\n            constexpr Type l = static_cast&lt;Type&gt;(1);\n            const Type &amp;theta = isomorphicVec[0];\n\n            if (translotator::abs(theta) &lt; epsilon&lt;Type&gt;())\n            {\n                return LieGroupType&lt;2&gt;{SOGroup&lt;2, Type&gt;::identity(), Vector&lt;2, Type&gt;{{isomorphicVec[1], isomorphicVec[2]}}};\n            }\n            const Type s_ = translotator::sin(theta) / theta;\n            const Type c_ = (l - translotator::cos(theta)) / (theta);\n            const SquareMatrix&lt;2, Type&gt; J{{s_, -c_,\n                                           c_, s_}};\n            return LieGroupType&lt;2&gt;{SO2Group&lt;Type&gt;{isomorphicVec[0]}, J * Vector&lt;2, Type&gt;{{isomorphicVec[1], isomorphicVec[2]}}};\n        }\n\n        static LieGroupType&lt;3&gt; Exp(const VectorType&lt;3&gt; &amp;isomorphicVec)\n        {\n            // TODO optimize this with sympy cse\n            constexpr Type O = static_cast&lt;Type&gt;(0);\n            constexpr Type l = static_cast&lt;Type&gt;(1);\n            const Vector&lt;3, Type&gt; thetaVec = isomorphicVec.template block&lt;0, 0, 3, 1&gt;().cast2Vector();\n            const Type theta = thetaVec.norm();\n            const Vector&lt;3, Type&gt; tVec = isomorphicVec.template block&lt;3, 0, 3, 1&gt;().cast2Vector();\n\n            if (translotator::abs(theta) &lt; epsilon&lt;Type&gt;())\n            {\n                return LieGroupType&lt;3&gt;{SOGroup&lt;3, Type&gt;::identity(), tVec};\n            }\n\n            const Type c_ = (l - translotator::cos(theta)) / (theta * theta);\n            const Type s_ = (theta - translotator::sin(theta)) / (theta * theta * theta);\n            const Vector&lt;3, Type&gt; omega_cross_tVec = thetaVec.cross(tVec);\n            const Vector&lt;3, Type&gt; omega_2cross_tVec = thetaVec.cross(omega_cross_tVec);\n\n            return LieGroupType&lt;3&gt;{SO3Group&lt;Type&gt;{thetaVec},\n                                   tVec + c_ * omega_cross_tVec + s_ * omega_2cross_tVec};\n        }\n\n        static VectorType&lt;2&gt; Log(const LieGroupType&lt;2&gt; &amp;lieGroup)\n        {\n            const Type theta = translotator::atan2(lieGroup.rotation()(1, 0), lieGroup.rotation()(0, 0));\n\n            if (translotator::abs(theta) &lt; epsilon&lt;Type&gt;())\n            {\n                return VectorType&lt;2&gt;{{static_cast&lt;Type&gt;(0), lieGroup.translation()[0], lieGroup.translation()[1]}};\n            }\n            const Type theta_2 = theta * static_cast&lt;Type&gt;(0.5);\n            const Type s_ = theta_2 * translotator::sin(theta) / (static_cast&lt;Type&gt;(1) - translotator::cos(theta));\n            const SquareMatrix&lt;2, Type&gt; J_inv{{s_, theta_2,\n                                               -theta_2, s_}};\n            const Vector&lt;2, Type&gt; tVec = J_inv * lieGroup.translation();\n\n            return VectorType&lt;2&gt;{{theta, tVec[0], tVec[1]}};\n        }\n\n        static VectorType&lt;3&gt; Log(const LieGroupType&lt;3&gt; &amp;lieGroup)\n        {\n            const Vector&lt;3, Type&gt; thetaVec = LieOperator_SO&lt;Type&gt;::Log(lieGroup.rotation());\n            const Type theta = thetaVec.norm();\n\n            if (translotator::abs(theta) &lt; epsilon&lt;Type&gt;())\n            {\n                return VectorType&lt;3&gt;{{static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0),\n                                      lieGroup.translation()[0], lieGroup.translation()[1], lieGroup.translation()[2]}};\n            }\n\n            const Type a = (static_cast&lt;Type&gt;(1) - (theta * translotator::sin(theta)) / (static_cast&lt;Type&gt;(2) * (static_cast&lt;Type&gt;(1) - translotator::cos(theta)))) / (theta * theta);\n            const Vector&lt;3, Type&gt; omega_cross_t = thetaVec.cross(lieGroup.translation());\n            const Vector&lt;3, Type&gt; tVec = lieGroup.translation() - static_cast&lt;Type&gt;(0.5) * omega_cross_t + a * thetaVec.cross(omega_cross_t);\n\n            return VectorType&lt;3&gt;{{thetaVec[0], thetaVec[1], thetaVec[2],\n                                  tVec[0], tVec[1], tVec[2]}};\n        }\n\n        static LieGroupType&lt;2&gt; exp(const LieAlgebraType&lt;2&gt; &amp;lieAlgebra)\n        {\n            return Exp(LieAlgebra2Vector(lieAlgebra));\n        }\n\n        static LieGroupType&lt;3&gt; exp(const LieAlgebraType&lt;3&gt; &amp;lieAlgebra)\n        {\n            return Exp(LieAlgebra2Vector(lieAlgebra));\n        }\n\n        static LieAlgebraType&lt;2&gt; log(const LieGroupType&lt;2&gt; &amp;lieGroup)\n        {\n            return Vector2LieAlgebra(Log(lieGroup));\n        }\n\n        static LieAlgebraType&lt;3&gt; log(const LieGroupType&lt;3&gt; &amp;lieGroup)\n        {\n            return Vector2LieAlgebra(Log(lieGroup));\n        }\n    };\n\n    template &lt;typename Type&gt;\n    using LieOperator_SE = LieOperator&lt;ObjectType::SE_GROUP, Type&gt;;\n    using LieOperator_SEf = LieOperator_SE&lt;float&gt;;\n    using LieOperator_SEd = LieOperator_SE&lt;double&gt;;\n    using LieOperator_SEld = LieOperator_SE&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/SO_8hpp/","title":"File SO.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; lie &gt; SO.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/SO_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace lie Namespace for Lie Group and Algebra Operations."},{"location":"translotator/SO_8hpp/#classes","title":"Classes","text":"Type Name struct LieOperator&lt; ObjectType::SO_GROUP, Type &gt; &lt;typename Type&gt;Special Orthogonal Group. <p>The documentation for this class was generated from the following file <code>include/translotator/lie/SO.hpp</code></p>"},{"location":"translotator/SO_8hpp_source/","title":"File SO.hpp","text":"<p>File List &gt; include &gt; translotator &gt; lie &gt; SO.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : SO.hpp\n */\n\n#pragma once\n\nnamespace translotator::lie\n{\n    template &lt;typename Type&gt;\n    struct LieOperator&lt;ObjectType::SO_GROUP, Type&gt;\n    {\n        template &lt;size_t N&gt;\n        using LieAlgebraType = SquareMatrix&lt;N, Type&gt;;\n        template &lt;size_t N&gt;\n        using LieGroupType = SOGroup&lt;N, Type&gt;;\n        template &lt;size_t N&gt;\n        using VectorType = Vector&lt;N == 2 ? 1 : 3, Type&gt;;\n\n        static LieAlgebraType&lt;2&gt; Vector2LieAlgebra(const VectorType&lt;2&gt; &amp;isomorphicVec)\n        {\n            constexpr Type O = static_cast&lt;Type&gt;(0);\n            return LieAlgebraType&lt;2&gt;{{O, -isomorphicVec.x(),\n                                      isomorphicVec.x(), O}};\n        }\n\n        static LieAlgebraType&lt;3&gt; Vector2LieAlgebra(const VectorType&lt;3&gt; &amp;isomorphicVec)\n        {\n            return isomorphicVec.toCrossMatrix();\n        }\n\n        static VectorType&lt;2&gt; LieAlgebra2Vector(const LieAlgebraType&lt;2&gt; &amp;lieAlgebra)\n        {\n            return VectorType&lt;2&gt;{{lieAlgebra(1, 0)}};\n        }\n\n        static VectorType&lt;3&gt; LieAlgebra2Vector(const LieAlgebraType&lt;3&gt; &amp;lieAlgebra)\n        {\n            return VectorType&lt;3&gt;{{lieAlgebra(2, 1), lieAlgebra(0, 2), lieAlgebra(1, 0)}}; // x, y, z\n        }\n\n        static LieGroupType&lt;2&gt; Exp(const VectorType&lt;2&gt; &amp;isomorphicVec)\n        {\n            if (isomorphicVec.normSquared() &lt;= epsilon&lt;Type&gt;())\n            {\n                return LieGroupType&lt;2&gt;::identity();\n            }\n            const Type s = translotator::sin(isomorphicVec.x());\n            const Type c = translotator::cos(isomorphicVec.x());\n            return LieGroupType&lt;2&gt;{{c, -s,\n                                    s, c}};\n        }\n\n        static LieGroupType&lt;3&gt; Exp(const VectorType&lt;3&gt; &amp;isomorphicVec)\n        {\n            return UnitQuaternion&lt;Type&gt;{isomorphicVec}.toRotMatrix3D();\n        }\n\n        static VectorType&lt;2&gt; Log(const LieGroupType&lt;2&gt; &amp;lieGroup)\n        {\n            return VectorType&lt;2&gt;{{translotator::atan2(lieGroup(1, 0), lieGroup(0, 0))}};\n        }\n\n        static VectorType&lt;3&gt; Log(const LieGroupType&lt;3&gt; &amp;lieGroup)\n        {\n            const Type trace = lieGroup.trace();\n            const Type t = translotator::acos((trace - static_cast&lt;Type&gt;(1)) / static_cast&lt;Type&gt;(2));\n            if (translotator::abs(t) &lt;= epsilon&lt;Type&gt;())\n            {\n                return VectorType&lt;3&gt;{{0.f, 0.f, 0.f}};\n            }\n            const Type k = t / (static_cast&lt;Type&gt;(2) * translotator::sin(t));\n\n            return k * VectorType&lt;3&gt;{{lieGroup(2, 1) - lieGroup(1, 2),\n                                      lieGroup(0, 2) - lieGroup(2, 0),\n                                      lieGroup(1, 0) - lieGroup(0, 1)}};\n        }\n\n        static LieGroupType&lt;2&gt; exp(const LieAlgebraType&lt;2&gt; &amp;lieAlgebra)\n        {\n            return Exp(LieAlgebra2Vector(lieAlgebra));\n        }\n\n        static LieGroupType&lt;3&gt; exp(const LieAlgebraType&lt;3&gt; &amp;lieAlgebra)\n        {\n            return Exp(LieAlgebra2Vector(lieAlgebra));\n        }\n\n        static LieAlgebraType&lt;2&gt; log(const LieGroupType&lt;2&gt; &amp;lieGroup)\n        {\n            return Vector2LieAlgebra(Log(lieGroup));\n        }\n\n        static LieAlgebraType&lt;3&gt; log(const LieGroupType&lt;3&gt; &amp;lieGroup)\n        {\n            return Vector2LieAlgebra(Log(lieGroup));\n        }\n    };\n\n    template &lt;typename Type&gt;\n    using LieOperator_SO = LieOperator&lt;ObjectType::SO_GROUP, Type&gt;;\n    using LieOperator_SOf = LieOperator_SO&lt;float&gt;;\n    using LieOperator_SOd = LieOperator_SO&lt;double&gt;;\n    using LieOperator_SOld = LieOperator_SO&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/dir_d5306d4012edd8106bd4452d9b4e4e98/","title":"Dir include/translotator/objects","text":"<p>FileList &gt; include &gt; translotator &gt; objects</p>"},{"location":"translotator/dir_d5306d4012edd8106bd4452d9b4e4e98/#files","title":"Files","text":"Type Name file AxisAngle.hpp file ComplexNum.hpp file DualNumber.hpp file DualQuaternion.hpp file EulerAngle.hpp file Matrix.hpp file MatrixBase.hpp file MatrixBaseInternal.hpp file Quaternion.hpp file SEGroup.hpp file SOGroup.hpp file SquareMatrix.hpp file UnitComplexNum.hpp file UnitDualQuaternion.hpp file UnitQuaternion.hpp file Vector.hpp file initializer_list.hpp file objectdefs.hpp file tail.hpp <p>The documentation for this class was generated from the following file <code>include/translotator/objects/</code></p>"},{"location":"translotator/AxisAngle_8hpp/","title":"File AxisAngle.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; AxisAngle.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/AxisAngle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/AxisAngle_8hpp/#classes","title":"Classes","text":"Type Name class AxisAngle &lt;typename Type&gt;Represents a rotation in 3D space by an angle around an axis. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/AxisAngle.hpp</code></p>"},{"location":"translotator/AxisAngle_8hpp_source/","title":"File AxisAngle.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; AxisAngle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : AxisAngle.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class AxisAngle\n    {\n    private:\n        Type angle_;\n        Vector&lt;3, Type&gt; axis_;\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::AXIS_ANGLE;\n        inline AxisAngle(const Type &amp;angle, const Type &amp;x, const Type &amp;y, const Type &amp;z) : angle_(angle), axis_({x, y, z}) {}\n        explicit inline AxisAngle(const Type &amp;angle, const Vector&lt;3, Type&gt; &amp;axis) : angle_(angle), axis_(axis.normalized()) {}\n        explicit inline AxisAngle(const Type &amp;angle) : angle_(angle), axis_(Vector&lt;3, Type&gt;::zAxis()) {}                              // for 2d rotation\n        explicit inline AxisAngle(const Vector&lt;3, Type&gt; &amp;angleVector) : angle_(static_cast&lt;Type&gt;(0)), axis_(Vector&lt;3, Type&gt;::zeros()) //\n        {\n            const Type normsq = angleVector.normSquared();\n            if (normsq &lt;= translotator::epsilon&lt;Type&gt;())\n            {\n                angle_ = static_cast&lt;Type&gt;(0);\n                axis_ = Vector&lt;3, Type&gt;::xAxis();\n            }\n            else\n            {\n                angle_ = translotator::sqrt(normsq);\n                axis_ = angleVector.normalized();\n            }\n        }\n\n        static inline AxisAngle&lt;Type&gt; identity() { return AxisAngle&lt;Type&gt;(static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(1), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)); }\n\n        inline Type angle() const { return angle_; }\n        inline Type &amp;angle() { return angle_; }\n        inline const Vector&lt;3, Type&gt; &amp;axis() const { return axis_; }\n        inline Vector&lt;3, Type&gt; &amp;axis() { return axis_; }\n        inline Type x() const { return axis_.x(); }\n        inline Type y() const { return axis_.y(); }\n        inline Type z() const { return axis_.z(); }\n        inline Type &amp;x() { return axis_.x(); }\n        inline Type &amp;y() { return axis_.y(); }\n        inline Type &amp;z() { return axis_.z(); }\n\n        inline void axisNormalize() { axis_.normalize(); } \n\n        inline AxisAngle axisNormalized() const { return AxisAngle&lt;Type&gt;(angle_, axis_.normalized()); } \n\n        inline void inverse() { angle_ = -angle_; } \n\n        inline AxisAngle inversed() const { return AxisAngle&lt;Type&gt;(-angle_, axis_); } \n\n        inline Vector&lt;3, Type&gt; rotateVector3D(const Vector&lt;3, Type&gt; &amp;v) const \n        {\n            return (*this).toUnitQuaternion().rotateVector3D(v);\n        }\n        inline Vector&lt;2, Type&gt; rotateVector2D(const Vector&lt;2, Type&gt; &amp;v) const \n        {\n            const Type c = translotator::cos(angle_);\n            const Type s = translotator::sin(angle_);\n            return SquareMatrix&lt;2, Type&gt;{{c * v.x() - s * v.y(),\n                                          s * v.x() + c * v.y()}};\n        }\n        template &lt;AXIS Axis&gt;\n        inline AxisAngle&lt;Type&gt; axisRotation(const Type &amp;angle) const \n        {\n            if constexpr (Axis == AXIS::X)\n                return AxisAngle&lt;Type&gt;(angle, Vector&lt;3, Type&gt;::xAxis());\n            else if constexpr (Axis == AXIS::Y)\n                return AxisAngle&lt;Type&gt;(angle, Vector&lt;3, Type&gt;::yAxis());\n            else if constexpr (Axis == AXIS::Z)\n                return AxisAngle&lt;Type&gt;(angle, Vector&lt;3, Type&gt;::zAxis());\n            else\n                static_assert(Axis == AXIS::X || Axis == AXIS::Y || Axis == AXIS::Z, \"Invalid Axis\");\n        }\n\n        inline UnitQuaternion&lt;Type&gt; toUnitQuaternion() const \n        {\n            const Type half_angle = angle_ / static_cast&lt;Type&gt;(2);\n            const Vector&lt;3, Type&gt; axis_normalized = axis_.normalized();\n            return UnitQuaternion&lt;Type&gt;(translotator::cos(half_angle),\n                                        translotator::sin(half_angle) * axis_normalized)\n                .canonicalized();\n        }\n        inline UnitComplexNum&lt;Type&gt; toUnitComplexNum() const \n        {\n            return UnitComplexNum{translotator::cos(angle_), translotator::sin(angle_)};\n        }\n        inline SOGroup&lt;3, Type&gt; toRotMatrix3D() const \n        {\n            return toUnitQuaternion().toRotMatrix3D();\n        }\n        inline SOGroup&lt;2, Type&gt; toRotMatrix2D() const \n        {\n            const Type c = translotator::cos(angle_);\n            const Type s = translotator::sin(angle_);\n            return SOGroup&lt;2, Type&gt;{{+c, -s,\n                                     +s, +c}};\n        }\n        inline Vector&lt;3, Type&gt; toAngleVector() const \n        {\n            return axis_ * angle_;\n        }\n        template &lt;EULER_ORDER AxisOrder&gt;\n        inline EulerAngle&lt;Type, AxisOrder&gt; toEulerAngle2D() const \n        {\n            return toRotMatrix2D().template toEulerAngle&lt;AxisOrder&gt;();\n        }\n        template &lt;EULER_ORDER AxisOrder&gt;\n        inline EulerAngle&lt;Type, AxisOrder&gt; toEulerAngle3D() const \n        {\n            return toRotMatrix3D().template toEulerAngle&lt;AxisOrder&gt;();\n        }\n        template &lt;typename NewType&gt;\n        inline AxisAngle&lt;NewType&gt; castDataType() const \n        {\n            static_assert(is_float_v&lt;NewType&gt;, \"NewType must be float, double or long double type\");\n            return AxisAngle&lt;NewType&gt;(static_cast&lt;NewType&gt;(angle_), axis_.template castDataType&lt;NewType&gt;());\n        }\n\n    private:\n    };\n\n    using AxisAnglef = AxisAngle&lt;float&gt;;\n    using AxisAngled = AxisAngle&lt;double&gt;;\n    using AxisAngleld = AxisAngle&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/ComplexNum_8hpp/","title":"File ComplexNum.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; ComplexNum.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/ComplexNum_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/ComplexNum_8hpp/#classes","title":"Classes","text":"Type Name class ComplexNum &lt;typename Type&gt;Represents a complex number with real and imaginary parts. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/ComplexNum.hpp</code></p>"},{"location":"translotator/ComplexNum_8hpp_source/","title":"File ComplexNum.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; ComplexNum.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : ComplexNum.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class ComplexNum : public MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;\n    {\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::COMPLEX_NUM;\n        using MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;::MatrixBase;\n\n        inline ComplexNum() : MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;({static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)}) {}\n        explicit inline ComplexNum(Type real, Type imag) : MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;({real, imag}) {}\n\n        inline Type Re() const { return this-&gt;data_[0]; }\n        inline Type Im() const { return this-&gt;data_[1]; }\n        inline Type &amp;Re() { return this-&gt;data_[0]; }\n        inline Type &amp;Im() { return this-&gt;data_[1]; }\n\n        inline Type operator[](size_t i) const { return this-&gt;data_[i]; }\n        inline Type &amp;operator[](size_t i) { return this-&gt;data_[i]; }\n\n        inline ComplexNum&lt;Type&gt; operator*(const ComplexNum&lt;Type&gt; &amp;c) const \n        {\n            return ComplexNum&lt;Type&gt;(Re() * c.Re() - Im() * c.Im(),\n                                    Re() * c.Im() + Im() * c.Re());\n        }\n        inline ComplexNum&lt;Type&gt; operator/(const ComplexNum&lt;Type&gt; &amp;c) const \n        {\n            const Type den = c.normSquared();\n            return ComplexNum&lt;Type&gt;((Re() * c.Re() + Im() * c.Im()) / den,\n                                    (Im() * c.Re() - Re() * c.Im()) / den);\n        }\n        inline void operator*=(const ComplexNum&lt;Type&gt; &amp;c) { *this = *this * c; } \n\n        inline void operator/=(const ComplexNum&lt;Type&gt; &amp;c) { *this = *this / c; } \n\n        inline ComplexNum&lt;Type&gt; complexNumMul(const ComplexNum&lt;Type&gt; &amp;c) const { return *this * c; } \n\n        inline void complexNumMulEq(const ComplexNum&lt;Type&gt; &amp;c) { *this *= c; } \n\n        inline ComplexNum&lt;Type&gt; complexNumDiv(const ComplexNum&lt;Type&gt; &amp;c) const { return *this / c; } \n\n        inline void complexNumDivEq(const ComplexNum&lt;Type&gt; &amp;c) { *this /= c; } \n\n        using MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;::operator*;\n        using MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;::operator/;\n        using MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;::operator*=;\n        using MatrixBase&lt;2, 1, Type, ComplexNum&lt;Type&gt;&gt;::operator/=;\n\n        inline Type normSquared() const { return this-&gt;frobeniusNormSquared(); } \n\n        inline Type norm() const { return this-&gt;frobeniusNorm(); } \n\n        inline ComplexNum&lt;Type&gt; normalized() const { return *this / norm(); } \n\n        inline void normalize() { *this = normalized(); } \n\n        inline ComplexNum&lt;Type&gt; conjugated() const { return ComplexNum&lt;Type&gt;(Re(), -Im()); } \n\n        inline void conjugate() { *this = conjugated(); } \n\n        inline ComplexNum&lt;Type&gt; inversed() const { return conjugated() / normSquared(); } \n\n        inline void inverse() { *this = inversed(); } \n\n        inline SquareMatrix&lt;2, Type&gt; toMulMatrix() const \n        {\n            return SquareMatrix&lt;2, Type&gt;{{Re(), -Im(),\n                                          Im(), Re()}};\n        }\n    };\n\n    using ComplexNumf = ComplexNum&lt;float&gt;;\n    using ComplexNumd = ComplexNum&lt;double&gt;;\n    using ComplexNumld = ComplexNum&lt;long double&gt;;\n\n}\n</code></pre>"},{"location":"translotator/DualNumber_8hpp/","title":"File DualNumber.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; DualNumber.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/DualNumber_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/DualNumber_8hpp/#classes","title":"Classes","text":"Type Name class DualNumber &lt;typename Type&gt;Represents a dual number. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/DualNumber.hpp</code></p>"},{"location":"translotator/DualNumber_8hpp_source/","title":"File DualNumber.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; DualNumber.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : DualNumber.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;typename Type&gt;\n    class DualNumber : public MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;\n    {\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::DUAL_NUMBER;\n        using MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;::MatrixBase;\n        DualNumber() : MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;({static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)}) {}\n        DualNumber(const Type &amp;r, const Type &amp;d) : MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;({r, d}) {}\n        inline Type Re() const { return this-&gt;data_[0]; }\n        inline Type Du() const { return this-&gt;data_[1]; }\n        inline Type &amp;Re() { return this-&gt;data_[0]; }\n        inline Type &amp;Du() { return this-&gt;data_[1]; }\n        inline Type operator[](size_t i) const { return this-&gt;data_[i]; }\n        inline Type &amp;operator[](size_t i) { return this-&gt;data_[i]; }\n\n        inline SquareMatrix&lt;2, Type&gt; toMulMatrix() const \n        {\n            return SquareMatrix&lt;2, Type&gt;{{Re(), static_cast&lt;Type&gt;(0),\n                                          Du(), Re()}};\n        }\n\n        using MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;::operator*;\n        using MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;::operator/;\n        using MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;::operator*=;\n        using MatrixBase&lt;2, 1, Type, DualNumber&lt;Type&gt;&gt;::operator/=;\n\n        inline DualNumber&lt;Type&gt; operator*(const DualNumber&lt;Type&gt; &amp;other) const \n        {\n            return DualNumber&lt;Type&gt;{Re() * other.Re(),\n                                    Re() * other.Du() + Du() * other.Re()};\n        }\n        inline DualNumber&lt;Type&gt; operator/(const DualNumber&lt;Type&gt; &amp;other) const \n        {\n            return DualNumber&lt;Type&gt;{Re() / other.Re(),\n                                    (Du() * other.Re() - Re() * other.Du()) / (other.Re() * other.Re())};\n        }\n        inline void operator*=(const DualNumber&lt;Type&gt; &amp;other) { *this = *this * other; } \n\n        inline void operator/=(const DualNumber&lt;Type&gt; &amp;other) { *this = *this / other; } \n\n        inline DualNumber&lt;Type&gt; dualNumMul(const DualNumber&lt;Type&gt; &amp;other) const { return *this * other; } \n\n        inline void dualNumMulEq(const DualNumber&lt;Type&gt; &amp;other) { *this *= other; } \n\n        inline DualNumber&lt;Type&gt; dualNumDiv(const DualNumber&lt;Type&gt; &amp;other) const { return *this / other; } \n\n        inline void dualNumDivEq(const DualNumber&lt;Type&gt; &amp;other) { *this /= other; } \n\n        static inline DualNumber&lt;Type&gt; sqrt(const DualNumber&lt;Type&gt; &amp;dn) \n        {\n            const Type root = translotator::sqrt(dn.Re());\n            return DualNumber&lt;Type&gt;{root, dn.Du() / (static_cast&lt;Type&gt;(2) * root)};\n        }\n        inline DualNumber&lt;Type&gt; conjugated() const { return DualNumber&lt;Type&gt;{Re(), -Du()}; } \n\n        inline void conjugate() { Du() = -Du(); } \n\n        inline Type normSquared() const { return Re() * Re(); } \n\n        inline Type norm() const { return translotator::abs(Re()); } \n\n        inline DualNumber&lt;Type&gt; normalized() const { return DualNumber&lt;Type&gt;{static_cast&lt;Type&gt;(1), Du() / Re()}; } \n\n        inline void normalize() { *this = normalized(); } \n\n        inline DualNumber&lt;Type&gt; inversed() const { return DualNumber&lt;Type&gt;{static_cast&lt;Type&gt;(1) / Re(), -Du() / (Re() * Re())}; } \n    };\n\n    using DualNumberf = DualNumber&lt;float&gt;;\n    using DualNumberd = DualNumber&lt;double&gt;;\n    using DualNumberld = DualNumber&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/DualQuaternion_8hpp/","title":"File DualQuaternion.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; DualQuaternion.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/DualQuaternion_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/DualQuaternion_8hpp/#classes","title":"Classes","text":"Type Name class DualQuaternion &lt;typename Type&gt;Represents a dual quaternion. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/DualQuaternion.hpp</code></p>"},{"location":"translotator/DualQuaternion_8hpp_source/","title":"File DualQuaternion.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; DualQuaternion.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : DualQuaternion.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    // https://faculty.sites.iastate.edu/jia/files/inline-files/dual-quaternion.pdf\n\n    template &lt;typename Type&gt;\n    class DualQuaternion : public MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;\n    {\n    private:\n        using MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;::data_;\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::DUAL_QUATERNION;\n\n        using MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;::MatrixBase;\n        DualQuaternion() = default;\n        DualQuaternion(const Type &amp;rw, const Type &amp;rx, const Type &amp;ry, const Type &amp;rz,\n                       const Type &amp;dw, const Type &amp;dx, const Type &amp;dy, const Type &amp;dz)\n            : MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;({rw, rx, ry, rz, dw, dx, dy, dz}) {}\n        DualQuaternion(const Quaternion&lt;Type&gt; &amp;r, const Quaternion&lt;Type&gt; &amp;d)\n            : MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;{{r.w(), r.x(), r.y(), r.z(), d.w(), d.x(), d.y(), d.z()}} {}\n        DualQuaternion(const DualNumber&lt;Type&gt; &amp;dn)\n            : MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;{{dn[0], static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0),\n                                                            dn[1], static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)}} {}\n        ~DualQuaternion() = default;\n\n        inline const Quaternion&lt;Type&gt; &amp;Re() const { return reinterpret_cast&lt;const Quaternion&lt;Type&gt; &amp;&gt;(data_[0]); }\n        inline const Quaternion&lt;Type&gt; &amp;Du() const { return reinterpret_cast&lt;const Quaternion&lt;Type&gt; &amp;&gt;(data_[4]); }\n        inline Quaternion&lt;Type&gt; &amp;Re() { return reinterpret_cast&lt;Quaternion&lt;Type&gt; &amp;&gt;(data_[0]); }\n        inline Quaternion&lt;Type&gt; &amp;Du() { return reinterpret_cast&lt;Quaternion&lt;Type&gt; &amp;&gt;(data_[4]); }\n        inline const Type &amp;rw() const { return data_[0]; }\n        inline const Type &amp;rx() const { return data_[1]; }\n        inline const Type &amp;ry() const { return data_[2]; }\n        inline const Type &amp;rz() const { return data_[3]; }\n        inline const Type &amp;dw() const { return data_[4]; }\n        inline const Type &amp;dx() const { return data_[5]; }\n        inline const Type &amp;dy() const { return data_[6]; }\n        inline const Type &amp;dz() const { return data_[7]; }\n        inline Type &amp;rw() { return data_[0]; }\n        inline Type &amp;rx() { return data_[1]; }\n        inline Type &amp;ry() { return data_[2]; }\n        inline Type &amp;rz() { return data_[3]; }\n        inline Type &amp;dw() { return data_[4]; }\n        inline Type &amp;dx() { return data_[5]; }\n        inline Type &amp;dy() { return data_[6]; }\n        inline Type &amp;dz() { return data_[7]; }\n        inline const Type &amp;operator[](const size_t &amp;idx) const { return data_[idx]; }\n        inline Type &amp;operator[](const size_t &amp;idx) { return data_[idx]; }\n\n        using MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;::operator*;\n        using MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;::operator/;\n        using MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;::operator*=;\n        using MatrixBase&lt;8, 1, Type, DualQuaternion&lt;Type&gt;&gt;::operator/=;\n        inline DualQuaternion&lt;Type&gt; operator*(const DualQuaternion&lt;Type&gt; &amp;other) const \n        {\n            return DualQuaternion&lt;Type&gt;(Re() * other.Re(), Re() * other.Du() + Du() * other.Re());\n        }\n        inline DualQuaternion&lt;Type&gt; operator/(const DualQuaternion&lt;Type&gt; &amp;other) const { return *this * other.inversed(); } \n\n        inline void operator*=(const DualQuaternion&lt;Type&gt; &amp;q) { *this = *this * q; } \n\n        inline void operator/=(const DualQuaternion&lt;Type&gt; &amp;q) { *this = *this / q; } \n\n        inline DualQuaternion&lt;Type&gt; dualQuatMul(const DualQuaternion&lt;Type&gt; &amp;dq) const { return *this * dq; } \n\n        inline void dualQuatMulEq(const DualQuaternion&lt;Type&gt; &amp;dq) { *this *= dq; } \n\n        inline DualQuaternion&lt;Type&gt; dualQuatDiv(const DualQuaternion&lt;Type&gt; &amp;dq) const { return *this / dq; } \n\n        inline void dualQuatDivEq(const DualQuaternion&lt;Type&gt; &amp;dq) { *this /= dq; } \n\n        // /**\n        //  * utils\n        //  */\n\n        inline DualQuaternion&lt;Type&gt; conjugatedPrimary() const \n        {\n            return DualQuaternion&lt;Type&gt;{Re().conjugated(), Du().conjugated()};\n        }\n        inline void conjugatePrimary() { *this = conjugatedPrimary(); } \n\n        inline DualQuaternion&lt;Type&gt; conjugatedDual() const \n        {\n            return DualQuaternion&lt;Type&gt;{Re(), -Du()};\n        }\n        inline void conjugateDual() { *this = conjugatedDual(); } \n\n        inline DualQuaternion&lt;Type&gt; conjugatedFull() const \n        {\n            return DualQuaternion&lt;Type&gt;{Re().conjugated(), Quaternion&lt;Type&gt;{-Du().w(), Du().x(), Du().y(), Du().z()}};\n        }\n        inline void conjugateFull() { *this = conjugatedFull(); } \n\n        inline DualNumber&lt;Type&gt; normDualNum() const // original dual quaternion norm with primary conjugate\n        {\n            const Type re_norm = Re().norm();\n            const Type du_dot = Re().w() * Du().w() + Re().x() * Du().x() + Re().y() * Du().y() + Re().z() * Du().z();\n            return DualNumber&lt;Type&gt;{re_norm, du_dot / re_norm};\n        }\n        inline DualNumber&lt;Type&gt; normDualNumSquared() const \n        {\n            const Type du_dot = Re().w() * Du().w() + Re().x() * Du().x() + Re().y() * Du().y() + Re().z() * Du().z();\n            return DualNumber&lt;Type&gt;{Re().normSquared(), 2 * du_dot};\n        }\n        inline Type normScalar() const // dual quaternion norm, dual number norm again\n        {\n            return Re().norm();\n        }\n        inline Type normScalarSquared() const \n        {\n            return Re().normSquared();\n        }\n        inline DualQuaternion&lt;Type&gt; inversed() const \n        {\n            const Type re_normsq = Re().normSquared();\n            const Type du_dot = Re().w() * Du().w() + Re().x() * Du().x() + Re().y() * Du().y() + Re().z() * Du().z();\n            return DualQuaternion&lt;Type&gt;{Re().conjugated() / re_normsq,\n                                        Du().conjugated() / re_normsq - Re().conjugated() * (2 * du_dot / (re_normsq * re_normsq))};\n        }\n        inline void inverse() { *this = inversed(); } \n\n        inline DualQuaternion&lt;Type&gt; normalized() const\n        {\n            const Quaternion&lt;Type&gt; re_normed = Re().normalized();\n            const Type du_dot = re_normed.w() * Du().w() + re_normed.x() * Du().x() + re_normed.y() * Du().y() + re_normed.z() * Du().z();\n            const Quaternion&lt;Type&gt; du_normed = Re().norm() * (Du() - du_dot * re_normed);\n            return DualQuaternion&lt;Type&gt;{re_normed, du_normed};\n        }\n        inline void normalize() const { *this = normalized(); } \n\n        static DualQuaternion&lt;Type&gt; zeros() { return DualQuaternion&lt;Type&gt;(Quaternion&lt;Type&gt;::zeros(), Quaternion&lt;Type&gt;::zeros()); }\n\n        inline SquareMatrix&lt;8, Type&gt; toMulMatrix() const\n        {\n\n            const Type zero_ = static_cast&lt;Type&gt;(0);\n            // | [r]_x    0  |\n            // | [d]_x [r]_x |\n            return SquareMatrix&lt;8, Type&gt;{{rw(), -rx(), -ry(), -rz(), zero_, zero_, zero_, zero_,\n                                          rx(), +rw(), -rz(), +ry(), zero_, zero_, zero_, zero_,\n                                          ry(), +rz(), +rw(), -rx(), zero_, zero_, zero_, zero_,\n                                          rz(), -ry(), +rx(), +rw(), zero_, zero_, zero_, zero_,\n                                          dw(), -dx(), -dy(), -dz(), +rw(), -rx(), -ry(), -rz(),\n                                          dx(), +dw(), -dz(), +dy(), +rx(), +rw(), -rz(), +ry(),\n                                          dy(), +dz(), +dw(), -dx(), +ry(), +rz(), +rw(), -rx(),\n                                          dz(), -dy(), +dx(), +dw(), +rz(), -ry(), +rx(), +rw()}};\n        }\n        inline SquareMatrix&lt;8, Type&gt; toRightMulMatrix() const \n        {\n            const Type zero_ = static_cast&lt;Type&gt;(0);\n            // | [r]_xr    0   |\n            // | [d]_xr [r]_xr |\n            return SquareMatrix&lt;8, Type&gt;{{rw(), -rx(), -ry(), -rz(), zero_, zero_, zero_, zero_,\n                                          rx(), +rw(), +rz(), -ry(), zero_, zero_, zero_, zero_,\n                                          ry(), -rz(), +rw(), +rx(), zero_, zero_, zero_, zero_,\n                                          rz(), +ry(), -rx(), +rw(), zero_, zero_, zero_, zero_,\n                                          dw(), -dx(), -dy(), -dz(), +rw(), -rx(), -ry(), -rz(),\n                                          dx(), +dw(), +dz(), -dy(), +rx(), +rw(), +rz(), -ry(),\n                                          dy(), -dz(), +dw(), +dx(), +ry(), -rz(), +rw(), +rx(),\n                                          dz(), +dy(), -dx(), +dw(), +rz(), +ry(), -rx(), +rw()}};\n        }\n    };\n\n    using DualQuaternionf = DualQuaternion&lt;float&gt;;\n    using DualQuaterniond = DualQuaternion&lt;double&gt;;\n    using DualQuaternionld = DualQuaternion&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/EulerAngle_8hpp/","title":"File EulerAngle.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; EulerAngle.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/EulerAngle_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/EulerAngle_8hpp/#classes","title":"Classes","text":"Type Name class EulerAngle &lt;typename Type, AxisOrder&gt;Represents Euler angle 3D rotation. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/EulerAngle.hpp</code></p>"},{"location":"translotator/EulerAngle_8hpp_source/","title":"File EulerAngle.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; EulerAngle.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : EulerAngle.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n\n    template &lt;typename Type, EULER_ORDER AxisOrder = EULER_ORDER::ZYX&gt;\n    class EulerAngle\n    {\n    private:\n        Type angles_[3];\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::EULER_ANGLE;\n        EulerAngle() : angles_{0, 0, 0} {}\n        explicit EulerAngle(const Type &amp;angle) : angles_{0, 0, angle} {}\n        EulerAngle(const Type &amp;x, const Type &amp;y, const Type &amp;z) : angles_{x, y, z} {};\n        explicit EulerAngle(const Vector&lt;3, Type&gt; &amp;angles) : angles_{angles[0], angles[1], angles[2]} {};\n\n        inline Type x() const { return angles_[0]; }\n        inline Type y() const { return angles_[1]; }\n        inline Type z() const { return angles_[2]; }\n        inline Type &amp;x() { return angles_[0]; }\n        inline Type &amp;y() { return angles_[1]; }\n        inline Type &amp;z() { return angles_[2]; }\n\n        inline Type operator[](size_t idx) const { return angles_[idx]; }\n        inline Type &amp;operator[](size_t idx) { return angles_[idx]; }\n\n        inline Type roll() const { return x(); }\n        inline Type pitch() const { return y(); }\n        inline Type yaw() const { return z(); }\n        inline Type &amp;roll() { return x(); }\n        inline Type &amp;pitch() { return y(); }\n        inline Type &amp;yaw() { return z(); }\n\n        template &lt;size_t N&gt;\n        inline Type getAngleInOrder() const { return angles_[EULER_CONSTEXPR::AXIS_IDX_AT&lt;N, AxisOrder&gt;()]; }\n\n        template &lt;size_t N&gt;\n        inline Type &amp;getAngleInOrder() { return angles_[EULER_CONSTEXPR::AXIS_IDX_AT&lt;N, AxisOrder&gt;()]; }\n\n        template &lt;size_t N&gt;\n        constexpr inline AXIS getAxisInOrder() const { return EULER_CONSTEXPR::AXIS_AT&lt;N, AxisOrder&gt;(); }\n\n        inline Vector&lt;2, Type&gt; rotateVec2D(const Vector&lt;2, Type&gt; &amp;vec) const \n        {\n            return toUnitComplexNum().rotateVector2D(vec);\n        }\n        inline Vector&lt;3, Type&gt; rotateVec3D(const Vector&lt;3, Type&gt; &amp;vec) const \n        {\n            return toUnitQuaternion().rotateVector3D(vec);\n        }\n\n        template &lt;AXIS Axis&gt;\n        inline static EulerAngle&lt;Type, AxisOrder&gt; axisRotation(const Type &amp;angle) \n        {\n            if constexpr (Axis == AXIS::X)\n            {\n                return EulerAngle&lt;Type, AxisOrder&gt;{angle, static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)};\n            }\n            else if constexpr (Axis == AXIS::Y)\n            {\n                return EulerAngle&lt;Type, AxisOrder&gt;{static_cast&lt;Type&gt;(0), angle, static_cast&lt;Type&gt;(0)};\n            }\n            else if constexpr (Axis == AXIS::Z)\n            {\n                return EulerAngle&lt;Type, AxisOrder&gt;{static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), angle};\n            }\n            else\n            {\n                return EulerAngle&lt;Type, AxisOrder&gt;{};\n            }\n        }\n\n        inline UnitQuaternion&lt;Type&gt; toUnitQuaternion() const \n        {\n            constexpr AXIS AXIS1 = EULER_CONSTEXPR::AXIS_AT&lt;0, AxisOrder&gt;();\n            constexpr AXIS AXIS2 = EULER_CONSTEXPR::AXIS_AT&lt;1, AxisOrder&gt;();\n            constexpr AXIS AXIS3 = EULER_CONSTEXPR::AXIS_AT&lt;2, AxisOrder&gt;();\n\n            const Type angle1 = getAngleInOrder&lt;0&gt;();\n            const Type angle2 = getAngleInOrder&lt;1&gt;();\n            const Type angle3 = getAngleInOrder&lt;2&gt;();\n\n            const UnitQuaternion&lt;Type&gt; q1 = UnitQuaternion&lt;Type&gt;::template axisRotation&lt;AXIS1&gt;(angle1);\n            const UnitQuaternion&lt;Type&gt; q2 = UnitQuaternion&lt;Type&gt;::template axisRotation&lt;AXIS2&gt;(angle2);\n            const UnitQuaternion&lt;Type&gt; q3 = UnitQuaternion&lt;Type&gt;::template axisRotation&lt;AXIS3&gt;(angle3);\n\n            return (q1 * q2 * q3).canonicalized();\n        }\n        inline UnitComplexNum&lt;Type&gt; toUnitComplexNum() const \n        {\n            return UnitComplexNum&lt;Type&gt;{z()};\n        }\n        inline AxisAngle&lt;Type&gt; toAxisAngle() const \n        {\n            return toUnitQuaternion().toAxisAngle();\n        }\n        inline SOGroup&lt;3, Type&gt; toSO3Group() const \n        {\n            return toUnitQuaternion().toRotMatrix3D();\n        }\n        inline SOGroup&lt;2, Type&gt; toSO2Group() const \n        {\n            return SOGroup&lt;2, Type&gt;{z()};\n        }\n        inline Vector&lt;3, Type&gt; toVector() const \n        {\n            return Vector&lt;3, Type&gt;{{x(), y(), z()}};\n        }\n\n        template &lt;typename NewType&gt;\n        inline EulerAngle&lt;NewType, AxisOrder&gt; castDataType() const\n        {\n            static_assert(is_float_v&lt;NewType&gt;, \"NewType must be float, double or long double\");\n            return EulerAngle&lt;NewType, AxisOrder&gt;{static_cast&lt;NewType&gt;(x()), static_cast&lt;NewType&gt;(y()), static_cast&lt;NewType&gt;(z())};\n        }\n\n        template &lt;EULER_ORDER NewAxisOrder&gt;\n        inline EulerAngle&lt;Type, NewAxisOrder&gt; castAxisOrder() const \n        {\n            if constexpr (NewAxisOrder == AxisOrder)\n            {\n                return *this;\n            }\n            else\n            {\n                return toUnitQuaternion().template toEulerAngle3D&lt;NewAxisOrder&gt;();\n            }\n        }\n\n    private:\n    };\n\n    template &lt;EULER_ORDER AxisOrder = EULER_ORDER::ZYX&gt;\n    using EulerAnglef = EulerAngle&lt;float, AxisOrder&gt;;\n    template &lt;EULER_ORDER AxisOrder = EULER_ORDER::ZYX&gt;\n    using EulerAngled = EulerAngle&lt;double, AxisOrder&gt;;\n    template &lt;EULER_ORDER AxisOrder = EULER_ORDER::ZYX&gt;\n    using EulerAngleld = EulerAngle&lt;long double, AxisOrder&gt;;\n\n    template &lt;typename Type&gt;\n    using EulerAngleXYZ = EulerAngle&lt;Type, EULER_ORDER::XYZ&gt;;\n    template &lt;typename Type&gt;\n    using EulerAngleZYX = EulerAngle&lt;Type, EULER_ORDER::ZYX&gt;;\n\n    using EulerAngleXYZf = EulerAngleXYZ&lt;float&gt;;\n    using EulerAngleXYZd = EulerAngleXYZ&lt;double&gt;;\n    using EulerAngleXYZld = EulerAngleXYZ&lt;long double&gt;;\n    using EulerAngleZYXf = EulerAngleZYX&lt;float&gt;;\n    using EulerAngleZYXd = EulerAngleZYX&lt;double&gt;;\n    using EulerAngleZYXld = EulerAngleZYX&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/Matrix_8hpp/","title":"File Matrix.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; Matrix.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/Matrix_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/Matrix_8hpp/#classes","title":"Classes","text":"Type Name class Matrix &lt;N, M, typename Type&gt;Matrix class. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/Matrix.hpp</code></p>"},{"location":"translotator/Matrix_8hpp_source/","title":"File Matrix.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; Matrix.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : Matrix.hpp\n */\n\n#pragma once\n\n// #include \"MatrixBase.hpp\"\n\nnamespace translotator\n{\n    template &lt;size_t N, size_t M, typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class Matrix : public MatrixBase&lt;N, M, Type, Matrix&lt;N, M, Type&gt;&gt;\n    {\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::MATRIX;\n        using MatrixBase&lt;N, M, Type, Matrix&lt;N, M, Type&gt;&gt;::MatrixBase;\n    };\n\n    template &lt;size_t N, size_t M&gt;\n    using Matrixf = Matrix&lt;N, M, float&gt;;\n    template &lt;size_t N, size_t M&gt;\n    using Matrixd = Matrix&lt;N, M, double&gt;;\n    template &lt;size_t N, size_t M&gt;\n    using Matrixld = Matrix&lt;N, M, long double&gt;;\n}\n</code></pre>"},{"location":"translotator/MatrixBase_8hpp/","title":"File MatrixBase.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; MatrixBase.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/MatrixBase_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/MatrixBase_8hpp/#classes","title":"Classes","text":"Type Name class MatrixBase &lt;N, M, typename Type, typename Derived&gt;Base class for all matrix objects. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBase.hpp</code></p>"},{"location":"translotator/MatrixBase_8hpp_source/","title":"File MatrixBase.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; MatrixBase.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : MatrixBase.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n\n    template &lt;size_t N, size_t M, typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE, typename Derived&gt;\n    class MatrixBase\n    {\n    protected:\n        Type data_[N * M];\n\n    public:\n        constexpr static size_t ROWS = N;\n        constexpr static size_t COLS = M;\n        using DATATYPE = Type;\n        constexpr static bool MATRIX_BASE = true;\n\n        constexpr static size_t rowSize() { return N; } \n\n        constexpr static size_t colSize() { return M; } \n\n        MatrixBase() = default;\n        explicit MatrixBase(const MatrixBase &amp;other) = default;\n        explicit MatrixBase(const Type data[N * M])\n        {\n            memcpy(data_, data, N * M * sizeof(Type));\n        }\n        explicit MatrixBase(const Type data[N][M])\n        {\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    data_[i * M + j] = data[i][j];\n        }\n        explicit MatrixBase(const initializer_list&lt;N * M, Type&gt; &amp;list) \n        {\n            memcpy(data_, list.data, N * M * sizeof(Type));\n        }\n\n        static Derived eye() \n        {\n            Derived result;\n            result.fill(static_cast&lt;Type&gt;(0));\n            const size_t smaller = N &lt; M ? N : M;\n            for (size_t i = 0; i &lt; smaller; i++)\n                result(i, i) = 1;\n            return result;\n        }\n\n        static Derived zeros() \n        {\n            Derived result;\n            result.fill(static_cast&lt;Type&gt;(0));\n            return result;\n        }\n\n        static Derived ones() \n        {\n            Derived result;\n            result.fill(static_cast&lt;Type&gt;(1));\n            return result;\n        }\n\n        static Derived NaN() \n        {\n            Derived result;\n            result.fill(static_cast&lt;Type&gt;(NAN));\n            return result;\n        }\n\n        inline const Type &amp;operator()(size_t i, size_t j) const \n        {\n            return data_[i * M + j];\n        }\n        inline Type &amp;operator()(size_t i, size_t j) \n        {\n            return data_[i * M + j];\n        }\n        inline Matrix&lt;N, 1, Type&gt; col(size_t j) const \n        {\n            assert(j &lt; M);\n            Matrix&lt;N, 1, Type&gt; result;\n            for (size_t i = 0; i &lt; N; i++)\n                result(i, 0) = data_[i * M + j];\n            return result;\n        }\n        inline Matrix&lt;1, M, Type&gt; row(size_t i) const \n        {\n            assert(i &lt; N);\n            Matrix&lt;1, M, Type&gt; result;\n            for (size_t j = 0; j &lt; M; j++)\n                result(0, j) = data_[i * M + j];\n            return result;\n        }\n\n        template &lt;size_t P, size_t Q&gt;\n        inline Matrix&lt;P, Q, Type&gt; block(size_t i, size_t j) const\n        {\n            static_assert(P &lt;= N, \"Block out of bounds, Row\");\n            static_assert(Q &lt;= M, \"Block out of bounds, Col\");\n            assert(i + P &lt;= N);\n            assert(j + Q &lt;= M);\n            Matrix&lt;P, Q, Type&gt; result;\n            for (size_t ii = 0; ii &lt; P; ii++)\n                for (size_t jj = 0; jj &lt; Q; jj++)\n                    result(ii, jj) = data_[(i + ii) * M + j + jj];\n            return result;\n        }\n\n        template &lt;size_t i, size_t j, size_t P, size_t Q&gt;\n        inline Matrix&lt;P, Q, Type&gt; block() const\n        {\n            static_assert(i + P &lt;= N, \"Block out of bounds, Row\");\n            static_assert(j + Q &lt;= M, \"Block out of bounds, Col\");\n            return block&lt;P, Q&gt;(i, j);\n        }\n\n        inline Type *getData() const { return data_; } \n\n        inline void copyTo(Type *data) const { memcpy(data, data_, N * M * sizeof(Type)); } \n\n        inline Derived &amp;operator=(const Derived &amp;other) \n        {\n            memcpy(data_, other.data_, N * M * sizeof(Type));\n            return static_cast&lt;Derived &amp;&gt;(*this);\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline Derived &amp;setBlock(size_t i, size_t j, const OtherDerived &amp;block)\n        {\n            constexpr size_t P = OtherDerived::ROWS;\n            constexpr size_t Q = OtherDerived::COLS;\n            static_assert(is_same_v&lt;typename OtherDerived::DATATYPE, Type&gt;, \"Matrix data types must be the same\");\n            static_assert(P &lt;= N, \"Block out of bounds, Row\");\n            static_assert(Q &lt;= M, \"Block out of bounds, Col\");\n            assert(i + P &lt;= N);\n            assert(j + Q &lt;= M);\n            for (size_t ii = 0; ii &lt; P; ii++)\n                for (size_t jj = 0; jj &lt; Q; jj++)\n                    data_[(i + ii) * M + j + jj] = block(ii, jj);\n            return static_cast&lt;Derived &amp;&gt;(*this);\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline Derived &amp;setRow(size_t i, const OtherDerived &amp;row)\n        {\n            assert(i &lt; N);\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, Type&gt;, \"Matrix data types must be the same\");\n            static_assert(row.COLS == M, \"Matrix Col dimension must be the same\");\n            static_assert(row.ROWS == 1, \"Matrix Row dimension must be 1\");\n            for (size_t j = 0; j &lt; M; j++)\n                data_[i * M + j] = row(0, j);\n            return static_cast&lt;Derived &amp;&gt;(*this);\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline Derived &amp;setCol(size_t j, const OtherDerived &amp;col)\n        {\n            assert(j &lt; M);\n            static_assert(is_same_v&lt;typename OtherDerived::DATATYPE, Type&gt;, \"Matrix data types must be the same\");\n            static_assert(OtherDerived::ROWS == N, \"Matrix Row dimension must be same\");\n            static_assert(OtherDerived::COLS == 1, \"Matrix Col dimension must be 1\");\n            for (size_t i = 0; i &lt; N; i++)\n                data_[i * M + j] = col(i, 0);\n            return static_cast&lt;Derived &amp;&gt;(*this);\n        }\n\n        template &lt;size_t i, size_t j, typename OtherDerived&gt;\n        inline Derived &amp;setBlock(const OtherDerived &amp;block)\n        {\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, Type&gt;, \"Matrix data types must be the same\");\n            static_assert(i + OtherDerived::ROWS &lt;= N, \"Block out of bounds, Row\");\n            static_assert(j + OtherDerived::COLS &lt;= M, \"Block out of bounds, Col\");\n            return setBlock(i, j, block);\n        }\n\n        template &lt;size_t i, typename OtherDerived&gt;\n        inline Derived &amp;setRow(const OtherDerived &amp;row)\n        {\n            static_assert(i &lt; N, \"Row out of bounds\");\n            return setRow(i, row);\n        }\n\n        template &lt;size_t j, typename OtherDerived&gt;\n        inline Derived &amp;setCol(const OtherDerived &amp;col)\n        {\n            static_assert(j &lt; M, \"Col out of bounds\");\n            return setCol(j, col);\n        }\n\n        inline Derived operator/(Type v) const \n        {\n            Derived result;\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    result(i, j) = data_[i * M + j] / v;\n            return result;\n        }\n        inline void operator/=(Type v) \n        {\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    data_[i * M + j] /= v;\n        }\n        inline friend Derived operator*(Type lhs, const Derived &amp;rhs) { return rhs * lhs; } \n\n        template &lt;typename OtherDerived&gt;\n        inline Derived operator+(const OtherDerived &amp;other) const\n        {\n            static_assert(Derived::ROWS == OtherDerived::ROWS &amp;&amp; Derived::COLS == OtherDerived::COLS, \"Matrix dimensions must be the same\");\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, typename OtherDerived::DATATYPE&gt;, \"Matrix data types must be the same\");\n\n            Derived result;\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    result(i, j) = data_[i * M + j] + other(i, j);\n            return result;\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline Derived operator-(const OtherDerived &amp;other) const\n        {\n            static_assert(Derived::ROWS == OtherDerived::ROWS &amp;&amp; Derived::COLS == OtherDerived::COLS, \"Matrix dimensions must be the same\");\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, typename OtherDerived::DATATYPE&gt;, \"Matrix data types must be the same\");\n\n            Derived result;\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    result(i, j) = data_[i * M + j] - other(i, j);\n            return result;\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline auto operator*(const OtherDerived &amp;other) const\n        {\n            static_assert(Derived::COLS == OtherDerived::ROWS, \"Matrix dimensions must be the same\");\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, typename OtherDerived::DATATYPE&gt;, \"Matrix data types must be the same\");\n\n            typename MatrixBaseInternal::operator_mul_typemapper&lt;Derived, OtherDerived&gt;::type result;\n            if constexpr (is_matrix_base_v&lt;decltype(result)&gt;)\n            {\n                result.fill(static_cast&lt;Type&gt;(0));\n                for (size_t i = 0; i &lt; N; i++)\n                    for (size_t j = 0; j &lt; OtherDerived::COLS; j++)\n                        for (size_t k = 0; k &lt; M; k++)\n                            result(i, j) += (*this)(i, k) * other(k, j);\n                return result;\n            }\n            else if constexpr (is_same_v&lt;decltype(result), Type&gt;)\n            {\n                result = static_cast&lt;Type&gt;(0);\n                for (size_t i = 0; i &lt; N; i++)\n                    for (size_t j = 0; j &lt; OtherDerived::COLS; j++)\n                        for (size_t k = 0; k &lt; M; k++)\n                            result += (*this)(i, k) * other(k, j);\n                return result;\n            }\n            else\n            {\n                static_assert(is_matrix_base_v&lt;decltype(result)&gt; || is_same_v&lt;decltype(result), Type&gt;,\n                              \"Invalid type for operator*\");\n                return static_cast&lt;Type&gt;(0);\n            }\n        }\n\n        inline Derived operator*(const Type &amp;v) const\n        {\n            Derived result;\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    result(i, j) = data_[i * M + j] * v;\n            return result;\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline void operator+=(const OtherDerived &amp;other)\n        {\n            static_assert(Derived::ROWS == OtherDerived::ROWS &amp;&amp; Derived::COLS == OtherDerived::COLS, \"Matrix dimensions must be the same\");\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, typename OtherDerived::DATATYPE&gt;, \"Matrix data types must be the same\");\n\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    data_[i * M + j] += other(i, j);\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline void operator-=(const OtherDerived &amp;other)\n        {\n            static_assert(Derived::ROWS == OtherDerived::ROWS &amp;&amp; Derived::COLS == OtherDerived::COLS, \"Matrix dimensions must be the same\");\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, typename OtherDerived::DATATYPE&gt;, \"Matrix data types must be the same\");\n\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    data_[i * M + j] -= other(i, j);\n        }\n\n        template &lt;typename OtherDerived&gt;\n        inline void operator*=(const OtherDerived &amp;other)\n        {\n            *this = *this * other;\n        }\n\n        inline Derived operator-() const\n        {\n            static_assert(Derived::ROWS &gt; 0 &amp;&amp; Derived::COLS &gt; 0, \"Matrix dimensions must be exist\");\n            static_assert(is_same_v&lt;typename Derived::DATATYPE, Type&gt;, \"Matrix data types must be the same\");\n            Derived result;\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    result(i, j) = -data_[i * M + j];\n            return result;\n        }\n\n        inline auto T() const \n        {\n            if constexpr (N == 1)\n            {\n                Vector&lt;M, Type&gt; result;\n                for (size_t i = 0; i &lt; M; i++)\n                    result(i, 0) = data_[i];\n                return result;\n            }\n            else if constexpr (N == M)\n            {\n                SquareMatrix&lt;M, Type&gt; result;\n                for (size_t i = 0; i &lt; N; i++)\n                    for (size_t j = 0; j &lt; N; j++)\n                        result(j, i) = data_[i * M + j];\n                return result;\n            }\n            else\n            {\n                Matrix&lt;M, N, Type&gt; result;\n                for (size_t i = 0; i &lt; N; i++)\n                    for (size_t j = 0; j &lt; M; j++)\n                        result(j, i) = data_[i * M + j];\n                return result;\n            }\n        }\n\n        inline void fill(const Type &amp;v) \n        {\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    data_[i * M + j] = v;\n        }\n\n        inline void print() const \n        {\n            for (size_t i = 0; i &lt; N; i++)\n            {\n                for (size_t j = 0; j &lt; M; j++)\n                {\n                    printf(\"%f \", static_cast&lt;double&gt;(data_[i * M + j]));\n                }\n                printf(\"\\n\");\n            }\n        }\n\n        inline void swapRows(size_t i1, size_t i2) \n        {\n            for (size_t j = 0; j &lt; M; j++)\n            {\n                Type temp = data_[i1 * M + j];\n                data_[i1 * M + j] = data_[i2 * M + j];\n                data_[i2 * M + j] = temp;\n            }\n        }\n\n        inline void swapCols(size_t j1, size_t j2) \n        {\n            for (size_t i = 0; i &lt; N; i++)\n            {\n                Type temp = data_[i * M + j1];\n                data_[i * M + j1] = data_[i * M + j2];\n                data_[i * M + j2] = temp;\n            }\n        }\n\n        inline Type frobeniusNormSquared() const \n        {\n            Type result = static_cast&lt;Type&gt;(0);\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    result += data_[i * M + j] * data_[i * M + j];\n            return result;\n        }\n        inline Type frobeniusNorm() const { return translotator::sqrt(frobeniusNormSquared()); } \n\n        template &lt;typename NewType&gt;\n        inline auto castDataType() const\n        {\n            static_assert(!is_same_v&lt;Type, NewType&gt;, \"NewType must be different from current type\");\n            static_assert(is_float_v&lt;NewType&gt;, \"NewType must be a floating point type\");\n\n            typename MatrixBaseInternal::operator_cast_typemapper&lt;Derived, NewType&gt;::type result;\n            for (size_t i = 0; i &lt; N; i++)\n                for (size_t j = 0; j &lt; M; j++)\n                    result(i, j) = static_cast&lt;NewType&gt;(data_[i * M + j]);\n            return result;\n        }\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 1 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline Type toScalar() const { return data_[0]; }\n\n        template &lt;typename NewContainer&gt;\n        inline NewContainer castContainer() const;\n\n        inline Matrix&lt;N, M, Type&gt; cast2Matrix() const;\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == M_, true_type&gt;&gt;\n\n        inline SquareMatrix&lt;N, Type&gt; cast2SquareMatrix() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;M_ == 1, true_type&gt;&gt;\n        inline Vector&lt;N, Type&gt; cast2Vector() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 2 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline ComplexNum&lt;Type&gt; cast2ComplexNum() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 2 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline UnitComplexNum&lt;Type&gt; cast2UnitComplexNum() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 4 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline Quaternion&lt;Type&gt; cast2Quaternion() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 4 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline UnitQuaternion&lt;Type&gt; cast2UnitQuaternion() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;(N_ == 2 &amp;&amp; M_ == 2) || (N_ == 3 &amp;&amp; M_ == 3), true_type&gt;&gt;\n        inline SOGroup&lt;N, Type&gt; cast2SOGroup() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 2 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline DualNumber&lt;Type&gt; cast2DualNumber() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 8 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline DualQuaternion&lt;Type&gt; cast2DualQuaternion() const;\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 8 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline UnitDualQuaternion&lt;Type&gt; cast2UnitDualQuaternion() const;\n\n        template &lt;typename NewContainer&gt;\n        inline NewContainer &amp;castContainerRef();\n\n        inline Matrix&lt;N, M, Type&gt; &amp;cast2MatrixRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;M_ == N_, true_type&gt;&gt;\n        inline SquareMatrix&lt;N, Type&gt; &amp;cast2SquareMatrixRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;M_ == 1, true_type&gt;&gt;\n        inline Vector&lt;N, Type&gt; &amp;cast2VectorRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 2 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline ComplexNum&lt;Type&gt; &amp;cast2ComplexNumRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 2 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline UnitComplexNum&lt;Type&gt; &amp;cast2UnitComplexNumRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 4 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline Quaternion&lt;Type&gt; &amp;cast2QuaternionRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 4 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline UnitQuaternion&lt;Type&gt; &amp;cast2UnitQuaternionRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;(N_ == 2 &amp;&amp; M_ == 2) || (N_ == 3 &amp;&amp; M_ == 3), true_type&gt;&gt;\n        inline SOGroup&lt;N, Type&gt; &amp;cast2SOGroupRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 2 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline DualNumber&lt;Type&gt; &amp;cast2DualNumberRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 8 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline DualQuaternion&lt;Type&gt; &amp;cast2DualQuaternionRef();\n\n        template &lt;size_t N_ = N, size_t M_ = M, typename = enable_if_t&lt;N_ == 8 &amp;&amp; M_ == 1, true_type&gt;&gt;\n        inline UnitDualQuaternion&lt;Type&gt; &amp;cast2UnitDualQuaternionRef();\n    };\n\n}\n</code></pre>"},{"location":"translotator/MatrixBaseInternal_8hpp/","title":"File MatrixBaseInternal.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; MatrixBaseInternal.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/MatrixBaseInternal_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace MatrixBaseInternal Internal namespace for MatrixBase implementation."},{"location":"translotator/MatrixBaseInternal_8hpp/#classes","title":"Classes","text":"Type Name struct operator_cast_typemapper &lt;typename Derived, typename NewType&gt; struct operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt; &lt;typename NewType, N, M, typename Type&gt; struct operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt; &lt;typename NewType, N, typename Type&gt; struct operator_mul_typemapper &lt;typename Derived, typename OtherDerived, typename Enable&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt; struct operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; &lt;typename Derived, typename OtherDerived&gt; <p>The documentation for this class was generated from the following file <code>include/translotator/objects/MatrixBaseInternal.hpp</code></p>"},{"location":"translotator/MatrixBaseInternal_8hpp_source/","title":"File MatrixBaseInternal.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; MatrixBaseInternal.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : MatrixBaseInternal.hpp\n */\n\n#pragma once\n\nnamespace translotator::MatrixBaseInternal\n{\n    template &lt;typename Derived, typename OtherDerived, typename Enable = void&gt;\n    struct operator_mul_typemapper\n    {\n    };\n\n    template &lt;typename Derived, typename OtherDerived&gt;\n    struct operator_mul_typemapper&lt;Derived, OtherDerived,\n                                   enable_if_t&lt;Derived::ROWS != OtherDerived::COLS &amp;&amp; OtherDerived::COLS != 1, void&gt;&gt;\n    {\n        using type = Matrix&lt;Derived::ROWS, OtherDerived::COLS, typename Derived::DATATYPE&gt;;\n    };\n\n    template &lt;typename Derived, typename OtherDerived&gt;\n    struct operator_mul_typemapper&lt;Derived, OtherDerived,\n                                   enable_if_t&lt;Derived::ROWS == OtherDerived::COLS &amp;&amp; OtherDerived::COLS != 1, void&gt;&gt;\n    {\n        using type = SquareMatrix&lt;Derived::ROWS, typename Derived::DATATYPE&gt;;\n    };\n\n    template &lt;typename Derived, typename OtherDerived&gt;\n    struct operator_mul_typemapper&lt;Derived, OtherDerived,\n                                   enable_if_t&lt;Derived::ROWS == 1 &amp;&amp; OtherDerived::COLS == 1, void&gt;&gt;\n    {\n        using type = typename Derived::DATATYPE;\n    };\n\n    template &lt;typename Derived, typename OtherDerived&gt;\n    struct operator_mul_typemapper&lt;Derived, OtherDerived,\n                                   enable_if_t&lt;Derived::ROWS != 1 &amp;&amp; OtherDerived::COLS == 1, void&gt;&gt;\n    {\n        using type = Vector&lt;Derived::ROWS, typename Derived::DATATYPE&gt;;\n    };\n\n    // template &lt;typename Derived, typename OtherDerived&gt;\n    //     struct operator_mul_typemapper &lt; Derived,\n    //     OtherDerived, enable_if_t &lt; Derived::ROWS == 1 &amp;&amp; OtherDerived::COL\n\n    // template &lt;size_t N, typename Type&gt;\n    // struct operator_mul_typemapper&lt;SquareMatrix&lt;N, Type&gt;, SquareMatrix&lt;N, Type&gt;&gt;\n    // {\n    //     using type = SquareMatrix&lt;N, Type&gt;;\n    // };\n\n    template &lt;typename Derived, typename NewType&gt;\n    struct operator_cast_typemapper\n    {\n    };\n\n    template &lt;typename NewType, size_t N, size_t M, typename Type&gt;\n    struct operator_cast_typemapper&lt;Matrix&lt;N, M, Type&gt;, NewType&gt;\n    {\n        using type = Matrix&lt;N, M, NewType&gt;;\n    };\n\n    template &lt;typename NewType, size_t N, typename Type&gt;\n    struct operator_cast_typemapper&lt;Vector&lt;N, Type&gt;, NewType&gt;\n    {\n        using type = Vector&lt;N, NewType&gt;;\n    };\n\n}\n</code></pre>"},{"location":"translotator/Quaternion_8hpp/","title":"File Quaternion.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; Quaternion.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/Quaternion_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/Quaternion_8hpp/#classes","title":"Classes","text":"Type Name class Quaternion &lt;typename Type&gt;Representing a quaternion. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/Quaternion.hpp</code></p>"},{"location":"translotator/Quaternion_8hpp_source/","title":"File Quaternion.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; Quaternion.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : Quaternion.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class Quaternion : public MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;\n    {\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::QUATERNION;\n        using MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;::MatrixBase;\n\n        inline Quaternion() : MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;({static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)}) {}\n        explicit inline Quaternion(Type w, Type x, Type y, Type z) : MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;({w, x, y, z}) {}\n        explicit inline Quaternion(Type w, const Vector&lt;3, Type&gt; &amp;v) : MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;({w, v[0], v[1], v[2]}) {}\n        explicit inline Quaternion(const ComplexNum&lt;Type&gt; &amp;cplx) : MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;({cplx.Re(), cplx.Im(), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)}) {}\n\n        inline Type w() const { return this-&gt;data_[0]; }\n        inline Type x() const { return this-&gt;data_[1]; }\n        inline Type y() const { return this-&gt;data_[2]; }\n        inline Type z() const { return this-&gt;data_[3]; }\n        inline const Type Re() const { return w(); }\n        inline const Vector&lt;3, Type&gt; Im() const { return Vector&lt;3, Type&gt;({this-&gt;data_[1], this-&gt;data_[2], this-&gt;data_[3]}); }\n        inline Type &amp;w() { return this-&gt;data_[0]; }\n        inline Type &amp;x() { return this-&gt;data_[1]; }\n        inline Type &amp;y() { return this-&gt;data_[2]; }\n        inline Type &amp;z() { return this-&gt;data_[3]; }\n        inline Type &amp;Re() { return w(); }\n        inline Vector&lt;3, Type&gt; &amp;Im() { return reinterpret_cast&lt;Vector&lt;3, Type&gt; &amp;&gt;(this-&gt;data_[1]); }\n\n        inline Type operator[](size_t i) const { return this-&gt;data_[i]; }\n        inline Type &amp;operator[](size_t i) { return this-&gt;data_[i]; }\n\n        inline SquareMatrix&lt;4, Type&gt; toMulMatrix() const \n        {\n            return SquareMatrix&lt;4, Type&gt;{{w(), -x(), -y(), -z(),\n                                          x(), w(), -z(), y(),\n                                          y(), z(), w(), -x(),\n                                          z(), -y(), x(), w()}};\n        }\n        inline SquareMatrix&lt;4, Type&gt; toRightMulMatrix() const \n        {\n            return SquareMatrix&lt;4, Type&gt;{{w(), -x(), -y(), -z(),\n                                          x(), w(), z(), -y(),\n                                          y(), -z(), w(), x(),\n                                          z(), y(), -x(), w()}};\n        }\n\n        using MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;::operator*;\n        using MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;::operator/;\n        using MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;::operator*=;\n        using MatrixBase&lt;4, 1, Type, Quaternion&lt;Type&gt;&gt;::operator/=;\n\n        inline Quaternion&lt;Type&gt; operator*(const Quaternion&lt;Type&gt; &amp;q) const \n        {\n            return Quaternion&lt;Type&gt;(w() * q.w() - x() * q.x() - y() * q.y() - z() * q.z(),\n                                    x() * q.w() + w() * q.x() - z() * q.y() + y() * q.z(),\n                                    y() * q.w() + z() * q.x() + w() * q.y() - x() * q.z(),\n                                    z() * q.w() - y() * q.x() + x() * q.y() + w() * q.z());\n        }\n        inline Quaternion&lt;Type&gt; operator/(const Quaternion&lt;Type&gt; &amp;q) const { return *this * q.inversed(); } \n\n        inline void operator*=(const Quaternion&lt;Type&gt; &amp;q) { *this = *this * q; } \n\n        inline void operator/=(const Quaternion&lt;Type&gt; &amp;q) { *this = *this / q; } \n\n        inline Quaternion&lt;Type&gt; quatNumMul(const Quaternion&lt;Type&gt; &amp;q) const { return *this * q; } // alias for operator* for readability\n\n        inline void quatNumMulEq(const Quaternion&lt;Type&gt; &amp;q) { *this *= q; } // alias for operator*= for readability\n\n        inline Quaternion&lt;Type&gt; quatNumDiv(const Quaternion&lt;Type&gt; &amp;q) const { return *this / q; } // alias for operator/ for readability\n\n        inline void quatNumDivEq(const Quaternion&lt;Type&gt; &amp;q) { *this /= q; } // alias for operator/= for readability\n\n        inline Type normSquared() const { return this-&gt;frobeniusNormSquared(); } \n\n        inline Type norm() const { return this-&gt;frobeniusNorm(); } \n\n        inline Quaternion&lt;Type&gt; normalized() const { return *this / norm(); } \n\n        inline void normalize() { *this = normalized(); } \n\n        inline Quaternion&lt;Type&gt; canonicalized() const \n        {\n            if (w() &lt; static_cast&lt;Type&gt;(0))\n            {\n                return -(*this);\n            }\n            return *this;\n        }\n\n        inline void canonicalize() { *this = canonicalized(); } \n\n        inline Quaternion&lt;Type&gt; conjugated() const { return Quaternion&lt;Type&gt;(w(), -x(), -y(), -z()); } \n\n        inline void conjugate() { *this = conjugated(); } \n\n        inline Quaternion&lt;Type&gt; inversed() const { return conjugated() / normSquared(); } \n\n        inline void inverse() { *this = inversed(); } \n    };\n\n    using Quaternionf = Quaternion&lt;float&gt;;\n    using Quaterniond = Quaternion&lt;double&gt;;\n    using Quaternionld = Quaternion&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/SEGroup_8hpp/","title":"File SEGroup.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; SEGroup.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/SEGroup_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/SEGroup_8hpp/#classes","title":"Classes","text":"Type Name class SEGroup &lt;N, typename Type&gt;Special Euclidean Group. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/SEGroup.hpp</code></p>"},{"location":"translotator/SEGroup_8hpp_source/","title":"File SEGroup.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; SEGroup.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : SEGroup.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;size_t N, typename Type&gt;\n    class SEGroup\n    {\n\n    private:\n        SOGroup&lt;N, Type&gt; R_; // rotation\n        Vector&lt;N, Type&gt; t_;  // translation\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::SE_GROUP;\n        using DATATYPE = Type;\n\n        SEGroup() = default;\n        SEGroup(const SOGroup&lt;N, Type&gt; &amp;rotation, const Vector&lt;N, Type&gt; &amp;translation) : R_(rotation), t_(translation) {}\n        SEGroup(const SquareMatrix&lt;N + 1, Type&gt; &amp;matrix) : SEGroup(\n                                                               matrix.template block&lt;0, 0, N, N&gt;().template castContainer&lt;SOGroup&lt;N, Type&gt;&gt;(),\n                                                               matrix.template block&lt;0, N, N, 1&gt;().cast2Vector()) {}\n        ~SEGroup() = default;\n\n        inline SOGroup&lt;N, Type&gt; rotation() const { return R_; }\n        inline Vector&lt;N, Type&gt; translation() const { return t_; }\n        inline SOGroup&lt;N, Type&gt; &amp;rotation() { return R_; }\n        inline Vector&lt;N, Type&gt; &amp;translation() { return t_; }\n\n        inline SEGroup&lt;N, Type&gt; operator*(const SEGroup&lt;N, Type&gt; &amp;other) const \n        {\n            return SEGroup&lt;N, Type&gt;(R_ * other.R_, R_ * other.t_ + t_);\n        }\n\n        inline SEGroup&lt;N, Type&gt; operator/(const SEGroup&lt;N, Type&gt; &amp;other) const \n        {\n            const SOGroup&lt;N, Type&gt; other_r_inv = other.R_.inversed();\n            return SEGroup&lt;N, Type&gt;(R_ * other_r_inv, -R_ * other_r_inv * other.t_ + t_);\n        }\n\n        inline SEGroup&lt;N, Type&gt; inversed() const \n        {\n            const SOGroup&lt;N, Type&gt; R_inv = R_.inversed();\n            return SEGroup&lt;N, Type&gt;{R_inv, -R_inv * t_};\n        }\n        inline Vector&lt;N, Type&gt; actOnVector(const Vector&lt;N, Type&gt; &amp;vec) const \n        {\n            return R_ * vec + t_;\n        }\n        inline void print() const \n        {\n            R_.print();\n            t_.print();\n        }\n        inline SEGroup&lt;N, Type&gt; pow(const Type &amp;t) const \n        {\n            using LieOp = lie::LieOperator&lt;ObjectType::SE_GROUP, Type&gt;;\n            return LieOp::Exp(LieOp::Log(*this) * t);\n        }\n\n        static inline SEGroup&lt;N, Type&gt; identity() \n        {\n            return SEGroup&lt;N, Type&gt;{SOGroup&lt;N, Type&gt;::identity(), Vector&lt;N, Type&gt;::zeros()};\n        }\n\n        inline SquareMatrix&lt;N + 1, Type&gt; toSquareMatrix() const \n        {\n            SquareMatrix&lt;N + 1, Type&gt; mat = SquareMatrix&lt;N + 1, Type&gt;::zeros();\n            mat.template setBlock&lt;0, 0&gt;(R_);\n            mat.template setBlock&lt;0, N&gt;(t_);\n            mat(N, N) = static_cast&lt;Type&gt;(1);\n            return mat;\n        }\n    };\n\n    template &lt;size_t N&gt;\n    using SEGroupf = SEGroup&lt;N, float&gt;;\n    template &lt;size_t N&gt;\n    using SEGroupd = SEGroup&lt;N, double&gt;;\n    template &lt;size_t N&gt;\n    using SEGroupld = SEGroup&lt;N, long double&gt;;\n\n    template &lt;typename Type&gt;\n    using SE2Group = SEGroup&lt;2, Type&gt;;\n    template &lt;typename Type&gt;\n    using SE3Group = SEGroup&lt;3, Type&gt;;\n\n    using SE2Groupf = SE2Group&lt;float&gt;;\n    using SE2Groupd = SE2Group&lt;double&gt;;\n    using SE2Groupld = SE2Group&lt;long double&gt;;\n    using SE3Groupf = SE3Group&lt;float&gt;;\n    using SE3Groupd = SE3Group&lt;double&gt;;\n    using SE3Groupld = SE3Group&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/SOGroup_8hpp/","title":"File SOGroup.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; SOGroup.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/SOGroup_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/SOGroup_8hpp/#classes","title":"Classes","text":"Type Name class SOGroup &lt;N, typename Type&gt;Special Orthogonal Group. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/SOGroup.hpp</code></p>"},{"location":"translotator/SOGroup_8hpp_source/","title":"File SOGroup.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; SOGroup.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : SOGroup.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;size_t N, typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class SOGroup : public SquareMatrix&lt;N, Type&gt;\n    {\n        static_assert(N == 2 || N == 3, \"Supports only SO(2) &amp; SO(3) Groups\");\n\n    private:\n        inline Type &amp;Data_(size_t i, size_t j) { return SquareMatrix&lt;N, Type&gt;::operator()(i, j); }\n        inline const Type &amp;Data_(size_t i, size_t j) const { return SquareMatrix&lt;N, Type&gt;::operator()(i, j); }\n\n        explicit SOGroup(const SquareMatrix&lt;N, Type&gt; &amp;mat) : SquareMatrix&lt;N, Type&gt;(mat) {}\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::SO_GROUP;\n        using SquareMatrix&lt;N, Type&gt;::SquareMatrix;\n\n        template &lt;size_t N_ = N, typename = enable_if_t&lt;N_ == 2, true_type&gt;&gt;\n        SOGroup(const Vector&lt;N, Type&gt; &amp;vec1, const Vector&lt;N, Type&gt; &amp;vec2, bool col = true)\n        {\n            if (col)\n            {\n                this-&gt;setCol(0, vec1);\n                this-&gt;setCol(1, vec2);\n            }\n            else\n            {\n                this-&gt;setRow(0, vec1.T());\n                this-&gt;setRow(1, vec2.T());\n            }\n        }\n\n        template &lt;size_t N_ = N, typename = enable_if_t&lt;N_ == 3, true_type&gt;&gt;\n        SOGroup(const Vector&lt;N, Type&gt; &amp;vec1, const Vector&lt;N, Type&gt; &amp;vec2, const Vector&lt;N, Type&gt; &amp;vec3,\n                bool col = true)\n        {\n            if (col)\n            {\n                this-&gt;setCol(0, vec1);\n                this-&gt;setCol(1, vec2);\n                this-&gt;setCol(2, vec3);\n            }\n            else\n            {\n                this-&gt;setRow(0, vec1.T());\n                this-&gt;setRow(1, vec2.T());\n                this-&gt;setRow(2, vec3.T());\n            }\n        }\n\n        template &lt;size_t N_ = N, typename = enable_if_t&lt;N_ == 2, true_type&gt;&gt;\n        explicit SOGroup(const Type &amp;theta)\n        {\n            Data_(0, 0) = cos(theta);\n            Data_(0, 1) = -sin(theta);\n            Data_(1, 0) = sin(theta);\n            Data_(1, 1) = cos(theta);\n        }\n\n        template &lt;size_t N_ = N, typename = enable_if_t&lt;N_ == 3, true_type&gt;&gt;\n        explicit SOGroup(const Vector&lt;N, Type&gt; &amp;angleVector)\n        {\n            if (angleVector.normSquared() &lt;= translotator::epsilon&lt;Type&gt;())\n            {\n                (*this) = SOGroup&lt;N, Type&gt;{SquareMatrix&lt;N, Type&gt;::eye()};\n            }\n            else\n            {\n                (*this) = AxisAngle&lt;Type&gt;{angleVector}.toRotMatrix3D();\n            }\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline SquareMatrix&lt;N, Type&gt; operator+(const OtherContainer &amp;other) const\n        {\n            static_assert(is_matrix_base_v&lt;OtherContainer&gt;, \"Invalid type for operator+. Must have matrix base\");\n            return SquareMatrix&lt;N, Type&gt;::operator+(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline SquareMatrix&lt;N, Type&gt; operator-(const OtherContainer &amp;other) const \n        {\n            static_assert(is_matrix_base_v&lt;OtherContainer&gt;, \"Invalid type for operator-. Must have matrix base\");\n            return SquareMatrix&lt;N, Type&gt;::operator-(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator*(const OtherContainer &amp;other) const \n        {\n            if constexpr (is_same_v&lt;OtherContainer, SOGroup&lt;N, Type&gt;&gt;)\n            {\n                const SquareMatrix&lt;N, Type&gt; &amp;other_ = const_cast&lt;SOGroup&lt;N, Type&gt; *&gt;(&amp;other)-&gt;cast2SquareMatrixRef();\n                return SOGroup&lt;N, Type&gt;{SquareMatrix&lt;N, Type&gt;::operator*(other_)};\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, SquareMatrix&lt;N, Type&gt;&gt;)\n            {\n                return SquareMatrix&lt;N, Type&gt;::operator*(other);\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Type&gt;)\n            {\n                return SquareMatrix&lt;N, Type&gt;::operator*(other);\n            }\n            else\n            {\n                return SquareMatrix&lt;N, Type&gt;::operator*(other);\n            }\n        }\n        inline void operator*=(const SOGroup&lt;N, Type&gt; &amp;other) \n        {\n            *this = *this * other;\n        }\n        inline friend SquareMatrix&lt;N, Type&gt; operator*(const Type &amp;lhs, const SOGroup &amp;rhs) \n        {\n            SquareMatrix&lt;N, Type&gt; &amp;rhs_ = const_cast&lt;SOGroup *&gt;(&amp;rhs)-&gt;cast2SquareMatrixRef();\n            return rhs_ * lhs;\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator/(const OtherContainer &amp;other) const\n        {\n            if constexpr (is_same_v&lt;OtherContainer, SOGroup&lt;N, Type&gt;&gt;)\n            {\n                return (*this) * other.inversed();\n            }\n            else\n            {\n                return SquareMatrix&lt;N, Type&gt;::operator/(other);\n            }\n        }\n\n        inline SOGroup&lt;N, Type&gt; operator-() const \n        {\n            return SOGroup&lt;N, Type&gt;{SquareMatrix&lt;N, Type&gt;::operator-()};\n        }\n\n        inline SOGroup&lt;N, Type&gt; normalized() const\n        {\n            if constexpr (N == 2)\n            {\n                return this-&gt;toUnitComplexNum().toRotMatrix2D();\n            }\n            else if constexpr (N == 3)\n            {\n                return this-&gt;toUnitQuaternion().toRotMatrix3D();\n            }\n            else\n            {\n                static_assert(N == 2 || N == 3, \"Supports only SO(2) &amp; SO(3) Groups\");\n                return SOGroup&lt;N, Type&gt;();\n            }\n        }\n\n        inline void normalize() \n        {\n            (*this) = this-&gt;normalized();\n        }\n\n        inline SOGroup&lt;N, Type&gt; inversed() const \n        {\n            return SOGroup&lt;N, Type&gt;{SquareMatrix&lt;N, Type&gt;::T()};\n        }\n\n        inline void inverse() \n        {\n            (*this) = this-&gt;inversed();\n        }\n\n        inline SOGroup&lt;N, Type&gt; T() const \n        {\n            return SOGroup&lt;N, Type&gt;{SquareMatrix&lt;N, Type&gt;::T()};\n        }\n\n        inline SOGroup&lt;N, Type&gt; pow(const Type &amp;t) const \n        {\n            using LieOp = lie::LieOperator&lt;ObjectType::SO_GROUP, Type&gt;;\n            return LieOp::Exp(LieOp::Log(*this) * t);\n        }\n\n        static inline SOGroup&lt;N, Type&gt; identity() \n        {\n            static_assert(N == 2 || N == 3, \"Supports only SO(2) &amp; SO(3) Groups\");\n            return SOGroup&lt;N, Type&gt;{SquareMatrix&lt;N, Type&gt;::eye()};\n        }\n\n        template &lt;AXIS Axis&gt;\n        static SOGroup&lt;N, Type&gt; axisRotation(const Type &amp;angle)\n        {\n            // TODO add testcode for this\n            static_assert(N == 3, \"Supports only SO(3) Groups\");\n            const Type c = translotator::cos(angle);\n            const Type s = translotator::sin(angle);\n            const Type o = static_cast&lt;Type&gt;(0);\n            const Type l = static_cast&lt;Type&gt;(1);\n            if constexpr (Axis == AXIS::X)\n            {\n                return SOGroup&lt;N, Type&gt;{{l, o, o,\n                                         o, c, -s,\n                                         o, s, c}};\n            }\n            else if constexpr (Axis == AXIS::Y)\n            {\n                return SOGroup&lt;N, Type&gt;{{c, o, s,\n                                         o, l, o,\n                                         -s, o, c}};\n            }\n            else if constexpr (Axis == AXIS::Z)\n            {\n                return SOGroup&lt;N, Type&gt;{{c, -s, o,\n                                         s, c, o,\n                                         o, o, l}};\n            }\n            else\n            {\n                static_assert(Axis == AXIS::X || Axis == AXIS::Y || Axis == AXIS::Z, \"Invalid Axis\");\n            }\n        }\n\n        inline UnitComplexNum&lt;Type&gt; toUnitComplexNum() const \n        {\n            static_assert(N == 2, \"Supports only SO(2) Groups\");\n            return UnitComplexNum&lt;Type&gt;{Data_(0, 0), Data_(1, 0)};\n        }\n\n        inline UnitQuaternion&lt;Type&gt; toUnitQuaternion() const \n        {\n            if constexpr (N == 2)\n            {\n                Type cos_theta = Data_(0, 0) &lt; static_cast&lt;Type&gt;(-1) ? static_cast&lt;Type&gt;(-1) : Data_(0, 0);\n                cos_theta = cos_theta &gt; static_cast&lt;Type&gt;(1) ? static_cast&lt;Type&gt;(1) : cos_theta;\n                const Type angle = translotator::acos(cos_theta);\n                return UnitQuaternion&lt;Type&gt;{translotator::cos(angle / 2), 0, 0, translotator::sin(angle / 2)}.canonicalized();\n            }\n            else if constexpr (N == 3)\n            {\n                UnitQuaternion&lt;Type&gt; q;\n                const Type tr = this-&gt;trace();\n                if (tr &gt; 0)\n                {\n                    Type S = translotator::sqrt(tr + 1) * static_cast&lt;Type&gt;(2); // S=4*qw\n                    q.w() = static_cast&lt;Type&gt;(0.25) * S;\n                    q.x() = (Data_(2, 1) - Data_(1, 2)) / S;\n                    q.y() = (Data_(0, 2) - Data_(2, 0)) / S;\n                    q.z() = (Data_(1, 0) - Data_(0, 1)) / S;\n                }\n                else if ((Data_(0, 0) &gt; Data_(1, 1)) &amp;&amp; (Data_(0, 0) &gt; Data_(2, 2)))\n                {\n                    Type S = translotator::sqrt(static_cast&lt;Type&gt;(1.0) + Data_(0, 0) - Data_(1, 1) - Data_(2, 2)) * static_cast&lt;Type&gt;(2); // S=4*qx\n                    q.w() = (Data_(2, 1) - Data_(1, 2)) / S;\n                    q.x() = static_cast&lt;Type&gt;(0.25) * S;\n                    q.y() = (Data_(0, 1) + Data_(1, 0)) / S;\n                    q.z() = (Data_(0, 2) + Data_(2, 0)) / S;\n                }\n                else if (Data_(1, 1) &gt; Data_(2, 2))\n                {\n                    Type S = translotator::sqrt(static_cast&lt;Type&gt;(1.0) + Data_(1, 1) - Data_(0, 0) - Data_(2, 2)) * static_cast&lt;Type&gt;(2); // S=4*qy\n                    q.w() = (Data_(0, 2) - Data_(2, 0)) / S;\n                    q.x() = (Data_(0, 1) + Data_(1, 0)) / S;\n                    q.y() = static_cast&lt;Type&gt;(0.25) * S;\n                    q.z() = (Data_(1, 2) + Data_(2, 1)) / S;\n                }\n                else\n                {\n                    Type S = translotator::sqrt(static_cast&lt;Type&gt;(1.0) + Data_(2, 2) - Data_(0, 0) - Data_(1, 1)) * static_cast&lt;Type&gt;(2); // S=4*qz\n                    q.w() = (Data_(1, 0) - Data_(0, 1)) / S;\n                    q.x() = (Data_(0, 2) + Data_(2, 0)) / S;\n                    q.y() = (Data_(1, 2) + Data_(2, 1)) / S;\n                    q.z() = static_cast&lt;Type&gt;(0.25) * S;\n                }\n                q.normalize();\n                q.canonicalize();\n                return q;\n            }\n            else\n                static_assert(N == 2 || N == 3, \"Supports only SO(2) &amp; SO(3) Groups\");\n        }\n\n        inline AxisAngle&lt;Type&gt; toAxisAngle() const \n        {\n            if constexpr (N == 2)\n            {\n                const Type angle = translotator::acos(Data_(0, 0));\n                return AxisAngle&lt;Type&gt;{angle};\n            }\n            else if constexpr (N == 3)\n            {\n                return toUnitQuaternion().toAxisAngle();\n            }\n            else\n                static_assert(N == 2 || N == 3, \"Supports only SO(2) &amp; SO(3) Groups\");\n        }\n\n        template &lt;EULER_ORDER NewOrder&gt;\n        EulerAngle&lt;Type, NewOrder&gt; toEulerAngle() const\n        {\n            if constexpr (N == 2)\n            {\n                const Type angle = translotator::acos(Data_(0, 0));\n                return EulerAngle&lt;Type, NewOrder&gt;{static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), angle};\n            }\n            else if constexpr (N == 3)\n            {\n                EulerAngle&lt;Type, NewOrder&gt; euler;\n                constexpr size_t AXIS_FIRST = EULER_CONSTEXPR::AXIS_IDX_AT&lt;0, NewOrder&gt;();\n                constexpr size_t AXIS_SECOND = EULER_CONSTEXPR::AXIS_IDX_AT&lt;1, NewOrder&gt;();\n                constexpr size_t AXIS_THIRD = EULER_CONSTEXPR::AXIS_IDX_AT&lt;2, NewOrder&gt;();\n                constexpr Type SIGN = (((AXIS_SECOND - AXIS_FIRST) == 1) ||\n                                       ((static_cast&lt;int&gt;(AXIS_SECOND) - static_cast&lt;int&gt;(AXIS_FIRST)) == -2))\n                                          ? Type(1)\n                                          : Type(-1);\n\n                // Tait-Bryan angles\n                euler.template getAngleInOrder&lt;0&gt;() = translotator::atan2(-SIGN * Data_(AXIS_SECOND, AXIS_THIRD), Data_(AXIS_THIRD, AXIS_THIRD));\n                euler.template getAngleInOrder&lt;1&gt;() = SIGN * translotator::asin(Data_(AXIS_FIRST, AXIS_THIRD));\n                euler.template getAngleInOrder&lt;2&gt;() = translotator::atan2(-SIGN * Data_(AXIS_FIRST, AXIS_SECOND), Data_(AXIS_FIRST, AXIS_FIRST));\n\n                // Tait-Bryan angles\n                if (translotator::abs(euler.y() - Type(M_PI_2)) &lt; epsilon&lt;Type&gt;())\n                {\n                    euler.template getAngleInOrder&lt;0&gt;() = Type(0);\n                    euler.template getAngleInOrder&lt;2&gt;() = translotator::atan2(Data_(AXIS_THIRD, AXIS_SECOND), -SIGN * Data_(AXIS_THIRD, AXIS_FIRST));\n                }\n                else if (translotator::abs(euler.y() + Type(M_PI_2)) &lt; epsilon&lt;Type&gt;())\n                {\n                    euler.template getAngleInOrder&lt;0&gt;() = Type(0);\n                    euler.template getAngleInOrder&lt;2&gt;() = translotator::atan2(-Data_(AXIS_THIRD, AXIS_SECOND), SIGN * Data_(AXIS_THIRD, AXIS_FIRST));\n                }\n\n                return euler;\n            }\n            else\n                static_assert(N == 2 || N == 3, \"Supports only SO(2) &amp; SO(3) Groups\");\n        }\n    };\n\n    template &lt;size_t N&gt;\n    using SOGroupf = SOGroup&lt;N, float&gt;;\n    template &lt;size_t N&gt;\n    using SOGroupd = SOGroup&lt;N, double&gt;;\n    template &lt;size_t N&gt;\n    using SOGroupld = SOGroup&lt;N, long double&gt;;\n\n    template &lt;typename Type&gt;\n    using SO2Group = SOGroup&lt;2, Type&gt;;\n    template &lt;typename Type&gt;\n    using SO3Group = SOGroup&lt;3, Type&gt;;\n\n    using SO3Groupf = SO3Group&lt;float&gt;;\n    using SO3Groupd = SO3Group&lt;double&gt;;\n    using SO3Groupld = SO3Group&lt;long double&gt;;\n\n    using SO2Groupf = SO2Group&lt;float&gt;;\n    using SO2Groupd = SO2Group&lt;double&gt;;\n    using SO2Groupld = SO2Group&lt;long double&gt;;\n\n    template &lt;size_t N&gt;\n    using RotationMatrixf = SOGroupf&lt;N&gt;;\n    template &lt;size_t N&gt;\n    using RotationMatrixd = SOGroupd&lt;N&gt;;\n    template &lt;size_t N&gt;\n    using RotationMatrixld = SOGroupld&lt;N&gt;;\n\n    template &lt;typename Type&gt;\n    using RotationMatrix2D = SO2Group&lt;Type&gt;;\n    template &lt;typename Type&gt;\n    using RotationMatrix3D = SO3Group&lt;Type&gt;;\n\n    using RotationMatrix2Df = SO2Groupf;\n    using RotationMatrix2Dd = SO2Groupd;\n    using RotationMatrix2Dld = SO2Groupld;\n\n    using RotationMatrix3Df = SO3Groupf;\n    using RotationMatrix3Dd = SO3Groupd;\n    using RotationMatrix3Dld = SO3Groupld;\n}\n</code></pre>"},{"location":"translotator/SquareMatrix_8hpp/","title":"File SquareMatrix.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; SquareMatrix.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/SquareMatrix_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/SquareMatrix_8hpp/#classes","title":"Classes","text":"Type Name class SquareMatrix &lt;N, typename Type&gt; <p>The documentation for this class was generated from the following file <code>include/translotator/objects/SquareMatrix.hpp</code></p>"},{"location":"translotator/SquareMatrix_8hpp_source/","title":"File SquareMatrix.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; SquareMatrix.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : SquareMatrix.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n\n    template &lt;size_t N, typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class SquareMatrix : public MatrixBase&lt;N, N, Type, SquareMatrix&lt;N, Type&gt;&gt;\n    {\n    private:\n        inline Type &amp;Data_(size_t i, size_t j) { return (*this)(i, j); }\n        inline Type Data_(size_t i, size_t j) const { return (*this)(i, j); }\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::SQUARE_MATRIX;\n        using MatrixBase&lt;N, N, Type, SquareMatrix&lt;N, Type&gt;&gt;::MatrixBase;\n\n        inline Type determinant() const \n        {\n            static_assert(N == 2 || N == 3, \"Only 2x2, 3x3 matrices are supported\");\n            if constexpr (N == 2)\n            {\n                return Data_(0, 0) * Data_(1, 1) - Data_(0, 1) * Data_(1, 0);\n            }\n            else if constexpr (N == 3)\n            {\n                return Data_(0, 0) * (Data_(1, 1) * Data_(2, 2) - Data_(1, 2) * Data_(2, 1)) -\n                       Data_(0, 1) * (Data_(1, 0) * Data_(2, 2) - Data_(1, 2) * Data_(2, 0)) +\n                       Data_(0, 2) * (Data_(1, 0) * Data_(2, 1) - Data_(1, 1) * Data_(2, 0));\n            }\n\n            return 0;\n        }\n\n        inline Type trace() const \n        {\n            Type result = 0;\n            for (size_t i = 0; i &lt; N; i++)\n                result += Data_(i, i);\n            return result;\n        }\n\n        SquareMatrix&lt;N, Type&gt; inversed(bool &amp;result) const\n        {\n\n            if constexpr (N == 1) // special case for 1x1 matrix\n            {\n                if (translotator::abs(Data_(0, 0)) &lt; translotator::epsilon&lt;Type&gt;())\n                {\n                    result = false;\n                    return SquareMatrix&lt;N, Type&gt;::zero();\n                }\n\n                result = true;\n                return SquareMatrix&lt;N, Type&gt;{{1.0f / Data_(0, 0)}};\n            }\n            else if constexpr (N == 2) // special case for 2x2 matrix\n            {\n                const Type det = determinant();\n                if (translotator::abs(det) &lt; translotator::epsilon&lt;Type&gt;())\n                {\n                    result = false;\n                    return SquareMatrix&lt;N, Type&gt;::zeros();\n                }\n\n                result = true;\n                return SquareMatrix&lt;N, Type&gt;{{Data_(1, 1) / det, -Data_(0, 1) / det,\n                                              -Data_(1, 0) / det, Data_(0, 0) / det}};\n            }\n            else if constexpr (N == 3) // special case for 3x3 matrix\n            {\n                const Type det = determinant();\n                if (translotator::abs(det) &lt; translotator::epsilon&lt;Type&gt;())\n                {\n                    result = false;\n                    return SquareMatrix&lt;N, Type&gt;::zeros();\n                }\n\n                result = true;\n                return SquareMatrix&lt;N, Type&gt;{{(Data_(1, 1) * Data_(2, 2) - Data_(1, 2) * Data_(2, 1)) / det,\n                                              (Data_(0, 2) * Data_(2, 1) - Data_(0, 1) * Data_(2, 2)) / det,\n                                              (Data_(0, 1) * Data_(1, 2) - Data_(0, 2) * Data_(1, 1)) / det,\n                                              (Data_(1, 2) * Data_(2, 0) - Data_(1, 0) * Data_(2, 2)) / det,\n                                              (Data_(0, 0) * Data_(2, 2) - Data_(0, 2) * Data_(2, 0)) / det,\n                                              (Data_(0, 2) * Data_(1, 0) - Data_(0, 0) * Data_(1, 2)) / det,\n                                              (Data_(1, 0) * Data_(2, 1) - Data_(1, 1) * Data_(2, 0)) / det,\n                                              (Data_(0, 1) * Data_(2, 0) - Data_(0, 0) * Data_(2, 1)) / det,\n                                              (Data_(0, 0) * Data_(1, 1) - Data_(0, 1) * Data_(1, 0)) / det}};\n            }\n\n            constexpr size_t RANK = N;\n\n            SquareMatrix&lt;N, Type&gt; L{SquareMatrix&lt;N, Type&gt;::eye()};\n            SquareMatrix&lt;N, Type&gt; U = (*this);\n            SquareMatrix&lt;N, Type&gt; P{SquareMatrix&lt;N, Type&gt;::eye()};\n\n            // for all diagonal elements\n            for (size_t n = 0; n &lt; RANK; n++)\n            {\n                // if diagonal is zero, swap with row below\n                if (translotator::abs(U(n, n)) &lt; translotator::epsilon&lt;Type&gt;())\n                {\n                    // printf(\"trying pivot for row %d\\n\",n);\n                    for (size_t i = n + 1; i &lt; RANK; i++)\n                    {\n\n                        // printf(\"\\ttrying row %d\\n\",i);\n                        if (translotator::abs(U(i, n)) &gt; translotator::epsilon&lt;Type&gt;())\n                        {\n                            // printf(\"swapped %d\\n\",i);\n                            U.swapRows(i, n);\n                            P.swapRows(i, n);\n                            L.swapRows(i, n);\n                            L.swapCols(i, n);\n                            break;\n                        }\n                    }\n                }\n\n                // failsafe, return zero matrix\n                if (translotator::abs(U(n, n)) &lt; translotator::epsilon&lt;Type&gt;())\n                {\n                    result = false;\n                    return P;\n                }\n\n                // for all rows below diagonal\n                for (size_t i = (n + 1); i &lt; RANK; i++)\n                {\n                    L(i, n) = U(i, n) / U(n, n);\n\n                    // add i-th row and n-th row\n                    // multiplied by: -a(i,n)/a(n,n)\n                    for (size_t k = n; k &lt; RANK; k++)\n                    {\n                        U(i, k) -= L(i, n) * U(n, k);\n                    }\n                }\n            }\n\n            // solve LY=P*I for Y by forward subst\n            // SquareMatrix&lt;Type, M&gt; Y = P;\n\n            // for all columns of Y\n            for (size_t c = 0; c &lt; RANK; c++)\n            {\n                // for all rows of L\n                for (size_t i = 0; i &lt; RANK; i++)\n                {\n                    // for all columns of L\n                    for (size_t j = 0; j &lt; i; j++)\n                    {\n                        // for all existing y\n                        // subtract the component they\n                        // contribute to the solution\n                        P(i, c) -= (L(i, j) * P(j, c));\n                    }\n\n                    // divide by the factor\n                    // on current\n                    // term to be solved\n                    // Y(i,c) /= L(i,i);\n                    // but L(i,i) = 1.0\n                }\n            }\n\n            // solve Ux=y for x by back subst\n            // SquareMatrix&lt;Type, M&gt; X = Y;\n\n            // for all columns of X\n            for (size_t c = 0; c &lt; RANK; c++)\n            {\n                // for all rows of U\n                for (size_t k = 0; k &lt; RANK; k++)\n                {\n                    // have to go in reverse order\n                    size_t i = RANK - 1 - k;\n\n                    // for all columns of U\n                    for (size_t j = i + 1; j &lt; RANK; j++)\n                    {\n                        // for all existing x\n                        // subtract the component they\n                        // contribute to the solution\n                        P(i, c) -= (U(i, j) * P(j, c));\n                    }\n\n                    // divide by the factor\n                    // on current\n                    // term to be solved\n                    //\n                    // we know that U(i, i) != 0 from above\n                    P(i, c) /= U(i, i);\n                }\n            }\n\n            // check sanity of results\n            for (size_t i = 0; i &lt; RANK; i++)\n            {\n                for (size_t j = 0; j &lt; RANK; j++)\n                {\n                    if (!__builtin_isfinite(P(i, j)))\n                    {\n                        result = false;\n                        return P;\n                    }\n                }\n            }\n            // printf(\"X:\\n\"); X.print();\n            result = true;\n            return P;\n        }\n\n        inline void inverse() { *this = inversed(); } \n    };\n\n    template &lt;size_t N&gt;\n    using SquareMatrixf = SquareMatrix&lt;N, float&gt;;\n    template &lt;size_t N&gt;\n    using SquareMatrixd = SquareMatrix&lt;N, double&gt;;\n    template &lt;size_t N&gt;\n    using SquareMatrixld = SquareMatrix&lt;N, long double&gt;;\n}\n</code></pre>"},{"location":"translotator/UnitComplexNum_8hpp/","title":"File UnitComplexNum.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; UnitComplexNum.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/UnitComplexNum_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/UnitComplexNum_8hpp/#classes","title":"Classes","text":"Type Name class UnitComplexNum &lt;typename Type&gt; <p>The documentation for this class was generated from the following file <code>include/translotator/objects/UnitComplexNum.hpp</code></p>"},{"location":"translotator/UnitComplexNum_8hpp_source/","title":"File UnitComplexNum.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; UnitComplexNum.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : UnitComplexNum.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    /***\n     * @brief UnitComplexNum class\n     * @tparam Type floating point type\n     * @details UnitComplexNum is a class that represents a unit complex number.\n     * It is a subclass of ComplexNum and has a unit length. It is used to represent a rotation in 2D space.\n     */\n    template &lt;typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class UnitComplexNum : public ComplexNum&lt;Type&gt;\n    {\n    private:\n        explicit UnitComplexNum(const ComplexNum&lt;Type&gt; &amp;cplx) : ComplexNum&lt;Type&gt;(cplx) {}\n\n    public:\n        constexpr static ObjectType objType = ObjectType::UNIT_COMPLEX_NUM;\n        using ComplexNum&lt;Type&gt;::ComplexNum;\n        inline UnitComplexNum() : ComplexNum&lt;Type&gt;(static_cast&lt;Type&gt;(1), static_cast&lt;Type&gt;(0)) {}\n        explicit UnitComplexNum(const Type &amp;angle) : ComplexNum&lt;Type&gt;(translotator::cos(angle), translotator::sin(angle)) {}\n\n        using ComplexNum&lt;Type&gt;::Re;\n        using ComplexNum&lt;Type&gt;::Im;\n\n        template &lt;typename OtherContainer&gt;\n        inline ComplexNum&lt;Type&gt; operator+(const OtherContainer &amp;other) const\n        {\n            static_assert(is_matrix_base_v&lt;OtherContainer&gt;, \"Invalid type for operator+. Must have matrix base\");\n            return ComplexNum&lt;Type&gt;::operator+(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator-(const OtherContainer &amp;other) const\n        {\n            static_assert(is_matrix_base_v&lt;OtherContainer&gt;, \"Invalid type for operator-. Must have matrix base\");\n            return ComplexNum&lt;Type&gt;::operator-(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator*(const OtherContainer &amp;other) const\n        {\n            if constexpr (is_same_v&lt;OtherContainer, UnitComplexNum&lt;Type&gt;&gt;)\n            {\n                const ComplexNum&lt;Type&gt; &amp;other_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;other)-&gt;cast2ComplexNumRef();\n                return UnitComplexNum&lt;Type&gt;{ComplexNum&lt;Type&gt;::operator*(other_)};\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, ComplexNum&lt;Type&gt;&gt;)\n            {\n                return ComplexNum&lt;Type&gt;::operator*(other);\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Type&gt;)\n            {\n                return ComplexNum&lt;Type&gt;::operator*(other);\n            }\n            else\n            {\n                return ComplexNum&lt;Type&gt;::operator*(other);\n            }\n        }\n        inline friend ComplexNum&lt;Type&gt; operator*(const ComplexNum&lt;Type&gt; &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            const ComplexNum&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2ComplexNumRef();\n            return lhs * rhs_;\n        }\n        inline friend ComplexNum&lt;Type&gt; operator*(const Type &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            const ComplexNum&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2ComplexNumRef();\n            return lhs * rhs_;\n        }\n        inline void operator*=(const UnitComplexNum&lt;Type&gt; &amp;other) \n        {\n            *this = *this * other;\n        }\n        inline friend void operator*=(ComplexNum&lt;Type&gt; &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            const ComplexNum&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2ComplexNumRef();\n            lhs = lhs * rhs_;\n        }\n\n        inline UnitComplexNum&lt;Type&gt; complexNumMul(const UnitComplexNum&lt;Type&gt; &amp;other) const { return *this * other; } // alias for operator* for readability\n\n        inline ComplexNum&lt;Type&gt; complexNumMul(const ComplexNum&lt;Type&gt; &amp;other) const { return *this * other; } \n\n        inline friend ComplexNum&lt;Type&gt; complexNumMul(const ComplexNum&lt;Type&gt; &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            const ComplexNum&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2ComplexNumRef();\n            return lhs * rhs_;\n        }\n        inline void complexNumMulEq(const UnitComplexNum&lt;Type&gt; &amp;other) { *this *= other; } // alias for operator*= for readability\n\n        inline friend void complexNumMulEq(ComplexNum&lt;Type&gt; &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            lhs *= rhs.cast2ComplexNumRef();\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator/(const OtherContainer &amp;other) const\n        {\n            if constexpr (is_same_v&lt;OtherContainer, UnitComplexNum&lt;Type&gt;&gt;)\n            {\n                return (*this) * other.conjugated();\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, ComplexNum&lt;Type&gt;&gt;)\n            {\n                return ComplexNum&lt;Type&gt;::operator/(other);\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Type&gt;)\n            {\n                return ComplexNum&lt;Type&gt;::operator/(other);\n            }\n            else\n            {\n                static_assert(is_same_v&lt;OtherContainer, UnitComplexNum&lt;Type&gt;&gt; ||\n                                  is_same_v&lt;OtherContainer, ComplexNum&lt;Type&gt;&gt; ||\n                                  is_same_v&lt;OtherContainer, Type&gt;,\n                              \"Invalid type for operator/ must be UnitComplexNum, ComplexNum or Type\");\n                return Matrix&lt;2, 1, Type&gt;();\n            }\n        }\n        inline friend ComplexNum&lt;Type&gt; operator/(const ComplexNum&lt;Type&gt; &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            const ComplexNum&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2ComplexNumRef();\n            return lhs * rhs_.conjugated();\n        }\n        inline void operator/=(const UnitComplexNum&lt;Type&gt; &amp;other) \n        {\n            *this = *this / other;\n        }\n        inline friend void operator/=(ComplexNum&lt;Type&gt; &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            const ComplexNum&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2ComplexNumRef();\n            lhs *= rhs_.conjugated();\n        }\n        inline UnitComplexNum&lt;Type&gt; complexNumDiv(const UnitComplexNum&lt;Type&gt; &amp;other) const { return *this / other; } // alias for operator/ for readability\n\n        inline ComplexNum&lt;Type&gt; complexNumDiv(const ComplexNum&lt;Type&gt; &amp;other) const { return *this / other; } \n\n        inline void complexNumDivEq(const UnitComplexNum&lt;Type&gt; &amp;other) { *this /= other; } // alias for operator/= for readability\n\n        inline friend void complexNumDivEq(ComplexNum&lt;Type&gt; &amp;lhs, const UnitComplexNum&lt;Type&gt; &amp;rhs) \n        {\n            const ComplexNum&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitComplexNum&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2ComplexNumRef();\n            lhs *= rhs_.conjugated();\n        }\n        inline UnitComplexNum&lt;Type&gt; normalized() const \n        {\n            return UnitComplexNum&lt;Type&gt;{ComplexNum&lt;Type&gt;::normalized()};\n        }\n        inline UnitComplexNum&lt;Type&gt; conjugated() const \n        {\n            return UnitComplexNum&lt;Type&gt;{ComplexNum&lt;Type&gt;::conjugated()};\n        }\n        inline UnitComplexNum&lt;Type&gt; inversed() const \n        {\n            return conjugated();\n        }\n        inline void inverse() { *this = inversed(); } \n\n        inline Vector&lt;2, Type&gt; rotateVector2D(const Vector&lt;2, Type&gt; &amp;v) const \n        {\n            return Vector&lt;2, Type&gt;{{Re() * v.x() - Im() * v.y(),\n                                    Im() * v.x() + Re() * v.y()}};\n        }\n        inline UnitComplexNum&lt;Type&gt; pow(const Type t) const \n        {\n            using LieOp = lie::LieOperator&lt;ObjectType::UNIT_COMPLEX_NUM, Type&gt;;\n            return LieOp::Exp(LieOp::Log(*this) * t);\n        }\n\n        static inline UnitComplexNum&lt;Type&gt; identity() { return UnitComplexNum&lt;Type&gt;(static_cast&lt;Type&gt;(1), static_cast&lt;Type&gt;(0)); } \n\n        inline SOGroup&lt;2, Type&gt; toRotMatrix2D() const \n        {\n            return SOGroup&lt;2, Type&gt;{{Re(), -Im(),\n                                     Im(), Re()}};\n        }\n        inline AxisAngle&lt;Type&gt; toAxisAngle() const \n        {\n            const Type angle = translotator::acos(Re());\n            return AxisAngle&lt;Type&gt;{angle};\n        }\n        template &lt;EULER_ORDER AxisOrder&gt;\n        inline EulerAngle&lt;Type, AxisOrder&gt; toEulerAngle2D() const \n        {\n            const Type angle = translotator::acos(Re());\n            return EulerAngle&lt;Type, AxisOrder&gt;{angle};\n        }\n    };\n\n    using UnitComplexNumf = UnitComplexNum&lt;float&gt;;\n    using UnitComplexNumd = UnitComplexNum&lt;double&gt;;\n    using UnitComplexNumld = UnitComplexNum&lt;long double&gt;;\n\n    using S1f = UnitComplexNumf;\n    using S1d = UnitComplexNumd;\n    using S1ld = UnitComplexNumld;\n}\n</code></pre>"},{"location":"translotator/UnitDualQuaternion_8hpp/","title":"File UnitDualQuaternion.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; UnitDualQuaternion.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/UnitDualQuaternion_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/UnitDualQuaternion_8hpp/#classes","title":"Classes","text":"Type Name class UnitDualQuaternion &lt;typename Type&gt;Represents a unit dual quaternion. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/UnitDualQuaternion.hpp</code></p>"},{"location":"translotator/UnitDualQuaternion_8hpp_source/","title":"File UnitDualQuaternion.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; UnitDualQuaternion.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : UnitDualQuaternion.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;typename Type&gt;\n    class UnitDualQuaternion : public DualQuaternion&lt;Type&gt;\n    {\n    private:\n        explicit UnitDualQuaternion(const DualQuaternion&lt;Type&gt; &amp;dq)\n            : DualQuaternion&lt;Type&gt;(dq) {}\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::UNIT_DUAL_QUATERNION;\n        using DualQuaternion&lt;Type&gt;::DualQuaternion;\n\n        inline UnitDualQuaternion() : DualQuaternion&lt;Type&gt;(static_cast&lt;Type&gt;(1),\n                                                           static_cast&lt;Type&gt;(0),\n                                                           static_cast&lt;Type&gt;(0),\n                                                           static_cast&lt;Type&gt;(0),\n                                                           static_cast&lt;Type&gt;(0),\n                                                           static_cast&lt;Type&gt;(0),\n                                                           static_cast&lt;Type&gt;(0),\n                                                           static_cast&lt;Type&gt;(0)) {}\n        inline UnitDualQuaternion(const UnitQuaternion&lt;Type&gt; &amp;re, const Quaternion&lt;Type&gt; &amp;du)\n            : DualQuaternion&lt;Type&gt;(re, du) {}\n        inline UnitDualQuaternion(const UnitQuaternion&lt;Type&gt; &amp;rot, const Vector&lt;3, Type&gt; &amp;t)\n            : DualQuaternion&lt;Type&gt;(rot, Quaternion&lt;Type&gt;{static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0.5) * t} * rot) {}\n        inline const UnitQuaternion&lt;Type&gt; &amp;Re() const \n        {\n            return reinterpret_cast&lt;const UnitQuaternion&lt;Type&gt; &amp;&gt;(DualQuaternion&lt;Type&gt;::Re());\n        }\n        inline UnitQuaternion&lt;Type&gt; &amp;Re() { return reinterpret_cast&lt;UnitQuaternion&lt;Type&gt; &amp;&gt;(DualQuaternion&lt;Type&gt;::Re()); }\n        using DualQuaternion&lt;Type&gt;::Du;\n        using DualQuaternion&lt;Type&gt;::rw;\n        using DualQuaternion&lt;Type&gt;::rx;\n        using DualQuaternion&lt;Type&gt;::ry;\n        using DualQuaternion&lt;Type&gt;::rz;\n        using DualQuaternion&lt;Type&gt;::dw;\n        using DualQuaternion&lt;Type&gt;::dx;\n        using DualQuaternion&lt;Type&gt;::dy;\n        using DualQuaternion&lt;Type&gt;::dz;\n\n        template &lt;typename OtherContainer&gt;\n        inline DualQuaternion&lt;Type&gt; operator+(const OtherContainer &amp;other) const\n        {\n            return DualQuaternion&lt;Type&gt;::operator+(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline DualQuaternion&lt;Type&gt; operator-(const OtherContainer &amp;other) const\n        {\n            return DualQuaternion&lt;Type&gt;::operator-(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator*(const OtherContainer &amp;other) const\n        {\n            if constexpr (is_same_v&lt;OtherContainer, UnitDualQuaternion&lt;Type&gt;&gt;)\n            {\n                const DualQuaternion&lt;Type&gt; &amp;other_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;other)-&gt;cast2DualQuaternionRef();\n                return UnitDualQuaternion&lt;Type&gt;{DualQuaternion&lt;Type&gt;::operator*(other_)};\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, DualQuaternion&lt;Type&gt;&gt;)\n            {\n                return DualQuaternion&lt;Type&gt;::operator*(other);\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Type&gt;)\n            {\n                return DualQuaternion&lt;Type&gt;::operator*(other);\n            }\n            else\n            {\n                return Matrix&lt;8, 1, Type&gt;();\n            }\n        }\n        inline friend DualQuaternion&lt;Type&gt; operator*(const DualQuaternion&lt;Type&gt; &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const DualQuaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2DualQuaternionRef();\n            return lhs * rhs_;\n        }\n        inline friend DualQuaternion&lt;Type&gt; operator*(const Type &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const DualQuaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2DualQuaternionRef();\n            return lhs * rhs_;\n        }\n        inline void operator*=(const UnitDualQuaternion&lt;Type&gt; &amp;other) \n        {\n            *this = *this * other;\n        }\n        inline friend void operator*=(DualQuaternion&lt;Type&gt; &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const DualQuaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2DualQuaternionRef();\n            lhs *= rhs_;\n        }\n        inline UnitDualQuaternion&lt;Type&gt; dualQuatMul(const UnitDualQuaternion&lt;Type&gt; &amp;other) const { return (*this) * other; } // alias for operator* for readability\n\n        inline DualQuaternion&lt;Type&gt; dualQuatMul(const DualQuaternion&lt;Type&gt; &amp;other) const { return (*this) * other; } \n\n        inline friend DualQuaternion&lt;Type&gt; dualQuatMul(const DualQuaternion&lt;Type&gt; &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const DualQuaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2DualQuaternionRef();\n            return lhs * rhs_;\n        }\n        inline void dualQuatMulEq(const UnitDualQuaternion&lt;Type&gt; &amp;other) { *this *= other; } // alias for operator*= for readability\n\n        inline friend void dualQuatMulEq(DualQuaternion&lt;Type&gt; &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            lhs *= rhs.cast2DualQuaternionRef();\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator/(const OtherContainer &amp;other) const\n        {\n            if constexpr (is_same_v&lt;OtherContainer, UnitDualQuaternion&lt;Type&gt;&gt;)\n            {\n                return (*this) * other.inversed();\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, DualQuaternion&lt;Type&gt;&gt;)\n            {\n                return DualQuaternion&lt;Type&gt;::operator/(other);\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Type&gt;)\n            {\n                return DualQuaternion&lt;Type&gt;::operator/(other);\n            }\n            else\n            {\n                static_assert(is_same_v&lt;OtherContainer, UnitDualQuaternion&lt;Type&gt;&gt; ||\n                                  is_same_v&lt;OtherContainer, DualQuaternion&lt;Type&gt;&gt;,\n                              \"Invalid type for operator/ must be UnitDualQuaternion or Quaternion\");\n                return Matrix&lt;8, 1, Type&gt;();\n            }\n        }\n        inline friend DualQuaternion&lt;Type&gt; operator/(const DualQuaternion&lt;Type&gt; &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const DualQuaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2DualQuaternionRef();\n            return lhs * rhs_.inversed();\n        }\n        inline void operator/=(const UnitDualQuaternion&lt;Type&gt; &amp;other) \n        {\n            *this = *this / other;\n        }\n        inline friend void operator/=(DualQuaternion&lt;Type&gt; &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const DualQuaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2DualQuaternionRef();\n            lhs *= rhs_.inversed();\n        }\n        inline UnitDualQuaternion&lt;Type&gt; dualQuatDiv(const UnitDualQuaternion&lt;Type&gt; &amp;other) const { return (*this) / other; } // alias for operator/ for readability\n\n        inline DualQuaternion&lt;Type&gt; dualQuatDiv(const DualQuaternion&lt;Type&gt; &amp;other) const { return (*this) / other; } \n\n        inline void dualQuatDivEq(const UnitDualQuaternion&lt;Type&gt; &amp;other) { *this /= other; } // alias for operator/= for readability\n\n        inline friend void dualQuatDivEq(DualQuaternion&lt;Type&gt; &amp;lhs, const UnitDualQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const DualQuaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitDualQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2DualQuaternionRef();\n            lhs *= rhs_.inversed();\n        }\n\n        inline UnitDualQuaternion&lt;Type&gt; normalized() const \n        {\n            return UnitDualQuaternion&lt;Type&gt;(DualQuaternion&lt;Type&gt;::normalized());\n        }\n        inline void normalize() { *this = normalized(); } \n\n        inline UnitDualQuaternion&lt;Type&gt; conjugated() const \n        {\n            return UnitDualQuaternion&lt;Type&gt;(DualQuaternion&lt;Type&gt;::conjugatedPrimary());\n        }\n\n        inline void conjugate() { *this = conjugated(); } \n\n        inline UnitDualQuaternion&lt;Type&gt; inversed() const \n        {\n            return conjugated();\n        }\n\n        inline void inverse() { *this = inversed(); } \n\n        inline Vector&lt;2, Type&gt; actOnVector2D(const Vector&lt;2, Type&gt; &amp;v) const \n        {\n            return Re().rotateVector2D(v) + toTranslationVec2D();\n        }\n        inline Vector&lt;3, Type&gt; actOnVector3D(const Vector&lt;3, Type&gt; &amp;v) const \n        {\n            // 1. dv = 1+q_vE\n            // 2. d dv d* = 1 + q_v'E. (full conjugated)\n\n            return Re().rotateVector3D(v) + toTranslationVec3D();\n        }\n\n        static inline UnitDualQuaternion&lt;Type&gt; identity() { return UnitDualQuaternion&lt;Type&gt;{UnitQuaternion&lt;Type&gt;::identity(), Quaternion&lt;Type&gt;::zeros()}; }\n\n        inline SEGroup&lt;2, Type&gt; toSE2Group() const \n        {\n            return SEGroup&lt;2, Type&gt;{Re().toRotMatrix2D(), toTranslationVec2D()};\n        }\n\n        inline SEGroup&lt;3, Type&gt; toSE3Group() const \n        {\n            return SEGroup&lt;3, Type&gt;{Re().toRotMatrix3D(), toTranslationVec3D()};\n        }\n\n        inline Vector&lt;2, Type&gt; toTranslationVec2D() const \n        {\n            return Vector&lt;2, Type&gt;{{2 * (rw() * dx() - rz() * dy()), 2 * (rz() * dx() + rw() * dy())}};\n        }\n\n        inline Vector&lt;3, Type&gt; toTranslationVec3D() const \n        {\n            return 2 * (Du() * Re().inversed()).Im();\n        }\n    };\n\n    using UnitDualQuaternionf = UnitDualQuaternion&lt;float&gt;;\n    using UnitDualQuaterniond = UnitDualQuaternion&lt;double&gt;;\n    using UnitDualQuaternionld = UnitDualQuaternion&lt;long double&gt;;\n}\n</code></pre>"},{"location":"translotator/UnitQuaternion_8hpp/","title":"File UnitQuaternion.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; UnitQuaternion.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/UnitQuaternion_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/UnitQuaternion_8hpp/#classes","title":"Classes","text":"Type Name class UnitQuaternion &lt;typename Type&gt;UnitQuaternion class. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/UnitQuaternion.hpp</code></p>"},{"location":"translotator/UnitQuaternion_8hpp_source/","title":"File UnitQuaternion.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; UnitQuaternion.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : UnitQuaternion.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class UnitQuaternion : public Quaternion&lt;Type&gt;\n    {\n    private:\n        explicit UnitQuaternion(const Quaternion&lt;Type&gt; &amp;quat) : Quaternion&lt;Type&gt;(quat) {}\n\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::UNIT_QUATERNION;\n        using Quaternion&lt;Type&gt;::Quaternion;\n\n        inline UnitQuaternion() : Quaternion&lt;Type&gt;(static_cast&lt;Type&gt;(1),\n                                                   static_cast&lt;Type&gt;(0),\n                                                   static_cast&lt;Type&gt;(0),\n                                                   static_cast&lt;Type&gt;(0)) {}\n        inline UnitQuaternion(const Vector&lt;3, Type&gt; &amp;angleVec) : Quaternion&lt;Type&gt;(AxisAngle&lt;Type&gt;{angleVec}.toUnitQuaternion()) {}\n\n        using Quaternion&lt;Type&gt;::Re;\n        using Quaternion&lt;Type&gt;::Im;\n        using Quaternion&lt;Type&gt;::w;\n        using Quaternion&lt;Type&gt;::x;\n        using Quaternion&lt;Type&gt;::y;\n        using Quaternion&lt;Type&gt;::z;\n\n        template &lt;typename OtherContainer&gt;\n        inline Quaternion&lt;Type&gt; operator+(const OtherContainer &amp;other) const\n        {\n            static_assert(is_matrix_base_v&lt;OtherContainer&gt;, \"Invalid type for operator+. Must have matrix base\");\n            return Quaternion&lt;Type&gt;::operator+(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline Quaternion&lt;Type&gt; operator-(const OtherContainer &amp;other) const\n        {\n            static_assert(is_matrix_base_v&lt;OtherContainer&gt;, \"Invalid type for operator-. Must have matrix base\");\n            return Quaternion&lt;Type&gt;::operator-(other);\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator*(const OtherContainer &amp;other) const\n        {\n            if constexpr (is_same_v&lt;OtherContainer, UnitQuaternion&lt;Type&gt;&gt;)\n            {\n                const Quaternion&lt;Type&gt; &amp;other_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;other)-&gt;cast2QuaternionRef();\n                return UnitQuaternion&lt;Type&gt;{Quaternion&lt;Type&gt;::operator*(other_)};\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Quaternion&lt;Type&gt;&gt;)\n            {\n                return Quaternion&lt;Type&gt;::operator*(other);\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Type&gt;)\n            {\n                return Quaternion&lt;Type&gt;::operator*(other);\n            }\n            else\n            {\n                return Quaternion&lt;Type&gt;::operator*(other);\n            }\n        }\n        inline friend Quaternion&lt;Type&gt; operator*(const Quaternion&lt;Type&gt; &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const Quaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2QuaternionRef();\n            return lhs * rhs_;\n        }\n        inline friend Quaternion&lt;Type&gt; operator*(const Type &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const Quaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2QuaternionRef();\n            return lhs * rhs_;\n        }\n        inline void operator*=(const UnitQuaternion&lt;Type&gt; &amp;other) \n        {\n            *this = *this * other;\n        }\n        inline friend void operator*=(Quaternion&lt;Type&gt; &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const Quaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2QuaternionRef();\n            lhs *= rhs_;\n        }\n        inline UnitQuaternion&lt;Type&gt; quatNumMul(const UnitQuaternion&lt;Type&gt; &amp;other) const { return (*this) * other; } \n\n        inline Quaternion&lt;Type&gt; quatNumMul(const Quaternion&lt;Type&gt; &amp;other) const { return (*this) * other; } \n\n        inline friend Quaternion&lt;Type&gt; quatNumMul(const Quaternion&lt;Type&gt; &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const Quaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2QuaternionRef();\n            return lhs * rhs_;\n        }\n        inline void quatNumMulEq(const UnitQuaternion&lt;Type&gt; &amp;other) { *this *= other; } \n\n        inline friend void quatNumMulEq(Quaternion&lt;Type&gt; &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            lhs *= rhs.cast2QuaternionRef();\n        }\n\n        template &lt;typename OtherContainer&gt;\n        inline auto operator/(const OtherContainer &amp;other) const\n        {\n            if constexpr (is_same_v&lt;OtherContainer, UnitQuaternion&lt;Type&gt;&gt;)\n            {\n                return (*this) * other.conjugated();\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Quaternion&lt;Type&gt;&gt;)\n            {\n                return Quaternion&lt;Type&gt;::operator/(other);\n            }\n            else if constexpr (is_same_v&lt;OtherContainer, Type&gt;)\n            {\n                return Quaternion&lt;Type&gt;::operator/(other);\n            }\n            else\n            {\n                static_assert(is_same_v&lt;OtherContainer, UnitQuaternion&lt;Type&gt;&gt; ||\n                                  is_same_v&lt;OtherContainer, Quaternion&lt;Type&gt;&gt; ||\n                                  is_same_v&lt;OtherContainer, Type&gt;,\n                              \"Invalid type for operator/ must be UnitQuaternion, Quaternion or Type\");\n                return Matrix&lt;4, 1, Type&gt;();\n            }\n        }\n        inline friend Quaternion&lt;Type&gt; operator/(const Quaternion&lt;Type&gt; &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const Quaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2QuaternionRef();\n            return lhs * rhs_.conjugated();\n        }\n        inline void operator/=(const UnitQuaternion&lt;Type&gt; &amp;other) \n        {\n            *this = *this / other;\n        }\n        inline friend void operator/=(Quaternion&lt;Type&gt; &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const Quaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2QuaternionRef();\n            lhs *= rhs_.conjugated();\n        }\n        inline UnitQuaternion&lt;Type&gt; quatNumDiv(const UnitQuaternion&lt;Type&gt; &amp;other) const { return (*this) / other; } \n\n        inline Quaternion&lt;Type&gt; quatNumDiv(const Quaternion&lt;Type&gt; &amp;other) const { return (*this) / other; } \n\n        inline void quatNumDivEq(const UnitQuaternion&lt;Type&gt; &amp;other) { *this /= other; } \n\n        inline friend void quatNumDivEq(Quaternion&lt;Type&gt; &amp;lhs, const UnitQuaternion&lt;Type&gt; &amp;rhs) \n        {\n            const Quaternion&lt;Type&gt; &amp;rhs_ = const_cast&lt;UnitQuaternion&lt;Type&gt; *&gt;(&amp;rhs)-&gt;cast2QuaternionRef();\n            lhs *= rhs_.conjugated();\n        }\n\n        inline UnitQuaternion&lt;Type&gt; normalized() const \n        {\n            return UnitQuaternion&lt;Type&gt;(Quaternion&lt;Type&gt;::normalized());\n        }\n        inline UnitQuaternion&lt;Type&gt; conjugated() const \n        {\n            return UnitQuaternion&lt;Type&gt;(Quaternion&lt;Type&gt;::conjugated());\n        }\n        inline UnitQuaternion&lt;Type&gt; inversed() const \n        {\n            return conjugated();\n        }\n        inline void inverse() { *this = inversed(); } \n\n        inline Vector&lt;3, Type&gt; rotateVector3D(const Vector&lt;3, Type&gt; &amp;v) const \n        {\n            const Quaternion&lt;Type&gt; qv{static_cast&lt;Type&gt;(0), v};\n            const Quaternionf q_res = ((*this) * qv * conjugated());\n            return q_res.Im();\n        }\n        inline Vector&lt;2, Type&gt; rotateVector2D(const Vector&lt;2, Type&gt; &amp;v) const \n        {\n            const Type angle = static_cast&lt;Type&gt;(2) * translotator::acos(w());\n            const Type c = translotator::cos(angle);\n            const Type s = translotator::sin(angle);\n            return Vector&lt;2, Type&gt;{{c * v.x() - s * v.y(),\n                                    s * v.x() + c * v.y()}};\n        }\n        inline UnitQuaternion&lt;Type&gt; canonicalized() const \n        {\n            return UnitQuaternion&lt;Type&gt;(Quaternion&lt;Type&gt;::canonicalized());\n        }\n        inline void canonicalize() { *this = canonicalized(); } \n\n        inline UnitQuaternion&lt;Type&gt; pow(const Type &amp;t) const \n        {\n            using LieOp = lie::LieOperator&lt;ObjectType::UNIT_QUATERNION, Type&gt;;\n            return LieOp::Exp(LieOp::Log(*this) * t);\n        }\n\n        static inline UnitQuaternion&lt;Type&gt; identity() { return UnitQuaternion&lt;Type&gt;(static_cast&lt;Type&gt;(1), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)); }\n\n        template &lt;AXIS Axis&gt;\n        static inline UnitQuaternion&lt;Type&gt; axisRotation(const Type &amp;angle)\n        { // TODO add test code for this\n            const Type half_angle = angle / static_cast&lt;Type&gt;(2);\n            const Type c = translotator::cos(half_angle);\n            const Type s = translotator::sin(half_angle);\n            if constexpr (Axis == AXIS::X)\n                return UnitQuaternion&lt;Type&gt;{c, s, static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0)};\n            else if constexpr (Axis == AXIS::Y)\n                return UnitQuaternion&lt;Type&gt;{c, static_cast&lt;Type&gt;(0), s, static_cast&lt;Type&gt;(0)};\n            else if constexpr (Axis == AXIS::Z)\n                return UnitQuaternion&lt;Type&gt;{c, static_cast&lt;Type&gt;(0), static_cast&lt;Type&gt;(0), s};\n            else\n                static_assert(Axis == AXIS::X || Axis == AXIS::Y || Axis == AXIS::Z, \"Invalid Axis\");\n        }\n\n        inline SOGroup&lt;2, Type&gt; toRotMatrix2D() const \n        {\n            const Type angle = static_cast&lt;Type&gt;(2) * translotator::acos(w());\n            const Type c = translotator::cos(angle);\n            const Type s = translotator::sin(angle);\n            return SOGroup&lt;2, Type&gt;{{+c, -s,\n                                     +s, +c}};\n        }\n        inline SOGroup&lt;3, Type&gt; toRotMatrix3D() const \n        {\n            const Type xx = x() * x();\n            const Type xy = x() * y();\n            const Type xz = x() * z();\n            const Type xw = x() * w();\n            const Type yy = y() * y();\n            const Type yz = y() * z();\n            const Type yw = y() * w();\n            const Type zz = z() * z();\n            const Type zw = z() * w();\n            return SOGroup&lt;3, Type&gt;{{1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw),\n                                     2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw),\n                                     2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy)}};\n        }\n        inline AxisAngle&lt;Type&gt; toAxisAngle() const \n        {\n            const Type angle = static_cast&lt;Type&gt;(2) * translotator::acos(w());\n            if (translotator::abs(angle) &lt; translotator::epsilon&lt;Type&gt;())\n            {\n                return AxisAngle&lt;Type&gt;::identity();\n            }\n\n            return AxisAngle&lt;Type&gt;{angle, Im() / translotator::sin(angle / static_cast&lt;Type&gt;(2))};\n        }\n\n        template &lt;EULER_ORDER AxisOrder&gt;\n        inline EulerAngle&lt;Type, AxisOrder&gt; toEulerAngle2D() const\n        {\n            return toRotMatrix2D().template toEulerAngle&lt;AxisOrder&gt;();\n        }\n\n        template &lt;EULER_ORDER NewOrder&gt;\n        inline EulerAngle&lt;Type, NewOrder&gt; toEulerAngle3D() const\n        {\n            return toRotMatrix3D().template toEulerAngle&lt;NewOrder&gt;();\n        }\n\n    private:\n    };\n\n    using UnitQuaternionf = UnitQuaternion&lt;float&gt;;\n    using UnitQuaterniond = UnitQuaternion&lt;double&gt;;\n    using UnitQuaternionld = UnitQuaternion&lt;long double&gt;;\n\n    using S3f = UnitQuaternionf;\n    using S3d = UnitQuaterniond;\n    using S3ld = UnitQuaternionld;\n}\n</code></pre>"},{"location":"translotator/Vector_8hpp/","title":"File Vector.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; Vector.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/Vector_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/Vector_8hpp/#classes","title":"Classes","text":"Type Name class Vector &lt;N, typename Type&gt;Vector class. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/Vector.hpp</code></p>"},{"location":"translotator/Vector_8hpp_source/","title":"File Vector.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; Vector.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : Vector.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;size_t N, typename Type = TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE&gt;\n    class Vector : public MatrixBase&lt;N, 1, Type, Vector&lt;N, Type&gt;&gt;\n    {\n    public:\n        constexpr static ObjectType OBJECT_TYPE = ObjectType::VECTOR;\n        using MatrixBase&lt;N, 1, Type, Vector&lt;N, Type&gt;&gt;::MatrixBase;\n\n        inline Type norm() const { return this-&gt;frobeniusNorm(); } \n\n        inline Type normSquared() const { return this-&gt;frobeniusNormSquared(); } \n\n        inline Vector&lt;N, Type&gt; normalized() const \n        {\n            Vector&lt;N, Type&gt; result;\n            Type norm = this-&gt;norm();\n            for (size_t i = 0; i &lt; N; i++)\n                result[i] = this-&gt;data_[i] / norm;\n            return result;\n        }\n        inline void normalize() { *this = normalized(); } \n\n        inline Type dot(const Vector&lt;N, Type&gt; &amp;other) const \n        {\n            Type result = 0;\n            for (size_t i = 0; i &lt; N; i++)\n                result += this-&gt;data_[i] * other[i];\n            return result;\n        }\n\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;Dim == 3, true_type&gt;&gt;\n        inline Vector&lt;3, Type&gt; cross(const Vector&lt;3, Type&gt; &amp;other) const\n        {\n            Vector&lt;3, Type&gt; result;\n            result[0] = y() * other.z() - z() * other.y();\n            result[1] = z() * other.x() - x() * other.z();\n            result[2] = x() * other.y() - y() * other.x();\n            return result;\n        }\n\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;Dim == 3, true_type&gt;&gt;\n        inline SquareMatrix&lt;3, Type&gt; toCrossMatrix() const\n        {\n            return SquareMatrix&lt;3, Type&gt;{{static_cast&lt;Type&gt;(0), -z(), y(),\n                                          z(), static_cast&lt;Type&gt;(0), -x(),\n                                          -y(), x(), static_cast&lt;Type&gt;(0)}};\n        }\n        inline SquareMatrix&lt;N, Type&gt; toDiagMatrix() const \n        {\n            SquareMatrix&lt;N, Type&gt; result{SquareMatrix&lt;N, Type&gt;::zeros()};\n            for (size_t i = 0; i &lt; N; i++)\n                result(i, i) = this-&gt;data_[i];\n            return result;\n        }\n\n        inline Type &amp;operator[](size_t i) { return this-&gt;data_[i]; }\n        inline const Type &amp;operator[](size_t i) const { return this-&gt;data_[i]; }\n\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;1 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        inline Type x() const { return this-&gt;data_[0]; }\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;2 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        inline Type y() const { return this-&gt;data_[1]; }\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;3 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        inline Type z() const { return this-&gt;data_[2]; }\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;1 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        inline Type &amp;x() { return this-&gt;data_[0]; }\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;2 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        inline Type &amp;y() { return this-&gt;data_[1]; }\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;3 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        inline Type &amp;z() { return this-&gt;data_[2]; }\n\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;1 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        static inline Vector&lt;N, Type&gt; xAxis()\n        {\n            Vector&lt;N, Type&gt; v{Vector&lt;N, Type&gt;::zeros()};\n            v.x() = static_cast&lt;Type&gt;(1);\n            return v;\n        }\n\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;2 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        static inline Vector&lt;N, Type&gt; yAxis()\n        {\n            Vector&lt;N, Type&gt; v{Vector&lt;N, Type&gt;::zeros()};\n            v.y() = static_cast&lt;Type&gt;(1);\n            return v;\n        }\n\n        template &lt;size_t Dim = N, typename = enable_if_t&lt;3 &lt;= Dim &amp;&amp; Dim &lt;= 3, true_type&gt;&gt;\n        static inline Vector&lt;N, Type&gt; zAxis()\n        {\n            Vector&lt;N, Type&gt; v{Vector&lt;N, Type&gt;::zeros()};\n            v.z() = static_cast&lt;Type&gt;(1);\n            return v;\n        }\n    };\n\n    template &lt;size_t N&gt;\n    using Vectorf = Vector&lt;N, float&gt;;\n    template &lt;size_t N&gt;\n    using Vectord = Vector&lt;N, double&gt;;\n    template &lt;size_t N&gt;\n    using Vectorld = Vector&lt;N, long double&gt;;\n}\n</code></pre>"},{"location":"translotator/initializer__list_8hpp/","title":"File initializer_list.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; initializer_list.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/initializer__list_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/initializer__list_8hpp/#classes","title":"Classes","text":"Type Name struct initializer_list &lt;N, typename Type&gt;initializer_list struct <p>The documentation for this class was generated from the following file <code>include/translotator/objects/initializer_list.hpp</code></p>"},{"location":"translotator/initializer__list_8hpp_source/","title":"File initializer_list.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; initializer_list.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : initializer_list.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    template &lt;size_t N, typename Type&gt;\n    struct initializer_list\n    {\n        Type data[N];\n\n        template &lt;typename... Args&gt;\n        initializer_list(Args... args) : data{args...}\n        {\n            static_assert(all_same_v&lt;Type, Args...&gt;, \"Initializer list must have the same type\");\n            static_assert(sizeof...(args) == N, \"Initializer list size must match matrix size\");\n        }\n    };\n}\n</code></pre>"},{"location":"translotator/objectdefs_8hpp/","title":"File objectdefs.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; objectdefs.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> </ul>"},{"location":"translotator/objectdefs_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator namespace EULER_CONSTEXPR Namespace for Euler Order constexpr functions. namespace lie Namespace for Lie Group and Algebra Operations. <p>The documentation for this class was generated from the following file <code>include/translotator/objects/objectdefs.hpp</code></p>"},{"location":"translotator/objectdefs_8hpp_source/","title":"File objectdefs.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; objectdefs.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : objectdefs.hpp\n */\n\n#pragma once\n\n#include &lt;stddef.h&gt;\n\nnamespace translotator\n{\n\n    enum class ObjectType\n    {\n        MATRIX,\n        VECTOR,\n        SQUARE_MATRIX,\n        COMPLEX_NUM,\n        QUATERNION,\n        DUAL_NUMBER,\n        DUAL_QUATERNION,\n        UNIT_COMPLEX_NUM,\n        UNIT_QUATERNION,\n        AXIS_ANGLE,\n        EULER_ANGLE,\n        SO_GROUP,\n        SE_GROUP,\n        UNIT_DUAL_QUATERNION,\n    };\n\n    enum class AXIS\n    {\n        X = 0x1,\n        Y = 0x2,\n        Z = 0x3,\n    };\n\n    enum class EULER_ORDER\n    {\n        XYZ = 0x123,\n        XZY = 0x132,\n        YXZ = 0x213,\n        YZX = 0x231,\n        ZXY = 0x312,\n        ZYX = 0x321,\n    };\n\n    namespace EULER_CONSTEXPR\n    {\n        template &lt;size_t N, EULER_ORDER Order&gt;\n        constexpr AXIS AXIS_AT() noexcept\n        {\n            static_assert(N &lt; 3, \"N must be less than 3\");\n            return static_cast&lt;AXIS&gt;((static_cast&lt;uint32_t&gt;(Order) &gt;&gt; (4 * (2 - N))) &amp; 0xF);\n        }\n\n        template &lt;AXIS Axis&gt;\n        constexpr size_t AXIS_TO_IDX() noexcept { return static_cast&lt;size_t&gt;(Axis) - 1; }\n\n        template &lt;size_t N, EULER_ORDER Order&gt;\n        constexpr size_t AXIS_IDX_AT() noexcept\n        {\n            return AXIS_TO_IDX&lt;AXIS_AT&lt;N, Order&gt;()&gt;();\n        }\n    }\n    namespace lie\n    {\n        template &lt;ObjectType oType, typename dataType&gt;\n        struct LieOperator;\n    }\n\n    // ####################\n    // ## matrix objects ##\n    // ####################\n\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    class MatrixBase;\n\n    template &lt;size_t N, size_t M, typename Type&gt;\n    class Matrix;\n\n    template &lt;size_t N, typename Type&gt;\n    class SquareMatrix;\n\n    template &lt;size_t N, typename Type&gt;\n    class Vector;\n\n    // ###################\n    // ## number system ##\n    // ###################\n\n    template &lt;typename Type&gt;\n    class ComplexNum;\n\n    template &lt;typename Type&gt;\n    class Quaternion;\n\n    template &lt;typename Type&gt;\n    class DualNumber;\n\n    template &lt;typename Type&gt;\n    class DualQuaternion;\n\n    // ######################\n    // ## rotation objects ##\n    // ######################\n\n    template &lt;typename Type&gt;\n    class UnitComplexNum;\n\n    template &lt;typename Type&gt;\n    class UnitQuaternion;\n\n    template &lt;typename Type&gt;\n    class AxisAngle;\n\n    template &lt;typename Type, EULER_ORDER AxisOrder&gt;\n    class EulerAngle;\n\n    template &lt;size_t N, typename Type&gt;\n    class SOGroup;\n\n    // ########################################\n    // ## homogeneous transformation objects ##\n    // ########################################\n\n    template &lt;size_t N, typename Type&gt;\n    class SEGroup;\n\n    template &lt;typename Type&gt;\n    class UnitDualQuaternion;\n\n}\n</code></pre>"},{"location":"translotator/tail_8hpp/","title":"File tail.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; objects &gt; tail.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/tail_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator <p>The documentation for this class was generated from the following file <code>include/translotator/objects/tail.hpp</code></p>"},{"location":"translotator/tail_8hpp_source/","title":"File tail.hpp","text":"<p>File List &gt; include &gt; translotator &gt; objects &gt; tail.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : tail.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    // ################################\n    // ### MatrixBase castContainer ###\n    // ################################\n\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;typename NewContainer&gt;\n    inline NewContainer MatrixBase&lt;N, M, Type, Derived&gt;::castContainer() const\n    {\n        static_assert(NewContainer::ROWS == N, \"Matrix dimensions must be the same\");\n        static_assert(NewContainer::COLS == M, \"Matrix dimensions must be the same\");\n        static_assert(is_same_v&lt;typename NewContainer::DATATYPE, Type&gt;, \"Matrix data types must be the same\");\n        return *reinterpret_cast&lt;const NewContainer *&gt;(this);\n    };\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    inline Matrix&lt;N, M, Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2Matrix() const\n    {\n        return castContainer&lt;Matrix&lt;N, M, Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline SquareMatrix&lt;N, Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2SquareMatrix() const\n    {\n        return castContainer&lt;SquareMatrix&lt;N, Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline Vector&lt;N, Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2Vector() const\n    {\n        return castContainer&lt;Vector&lt;N, Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline ComplexNum&lt;Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2ComplexNum() const\n    {\n        return castContainer&lt;ComplexNum&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline UnitComplexNum&lt;Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2UnitComplexNum() const\n    {\n        UnitComplexNum&lt;Type&gt; c = castContainer&lt;UnitComplexNum&lt;Type&gt;&gt;();\n        c.normalize();\n        return c;\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline Quaternion&lt;Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2Quaternion() const\n    {\n        return castContainer&lt;Quaternion&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline UnitQuaternion&lt;Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2UnitQuaternion() const\n    {\n        UnitQuaternion&lt;Type&gt; q = castContainer&lt;UnitQuaternion&lt;Type&gt;&gt;();\n        q.normalize();\n        return q;\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline SOGroup&lt;N, Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2SOGroup() const\n    {\n        SOGroup&lt;N, Type&gt; so = castContainer&lt;SOGroup&lt;N, Type&gt;&gt;();\n        so.normalize();\n        return so;\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline DualNumber&lt;Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2DualNumber() const\n    {\n        return castContainer&lt;DualNumber&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline DualQuaternion&lt;Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2DualQuaternion() const\n    {\n        return castContainer&lt;DualQuaternion&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline UnitDualQuaternion&lt;Type&gt; MatrixBase&lt;N, M, Type, Derived&gt;::cast2UnitDualQuaternion() const\n    {\n        UnitDualQuaternion&lt;Type&gt; udq = castContainer&lt;UnitDualQuaternion&lt;Type&gt;&gt;();\n        udq.normalize();\n        return udq;\n    }\n\n    // ###################################\n    // ### MatrixBase castContainerRef ###\n    // ###################################\n\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;typename NewDerived&gt;\n    inline NewDerived &amp;MatrixBase&lt;N, M, Type, Derived&gt;::castContainerRef()\n    {\n        static_assert(NewDerived::ROWS == N, \"Matrix dimensions must be the same\");\n        static_assert(NewDerived::COLS == M, \"Matrix dimensions must be the same\");\n        static_assert(is_same_v&lt;typename NewDerived::DATATYPE, Type&gt;, \"Matrix data types must be the same\");\n\n        return *reinterpret_cast&lt;NewDerived *&gt;(this);\n    };\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    inline Matrix&lt;N, M, Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2MatrixRef()\n    {\n        return castContainerRef&lt;Matrix&lt;N, M, Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline SquareMatrix&lt;N, Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2SquareMatrixRef()\n    {\n        return castContainerRef&lt;SquareMatrix&lt;N, Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline Vector&lt;N, Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2VectorRef()\n    {\n        return castContainerRef&lt;Vector&lt;N, Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline ComplexNum&lt;Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2ComplexNumRef()\n    {\n        return castContainerRef&lt;ComplexNum&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline UnitComplexNum&lt;Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2UnitComplexNumRef()\n    {\n        auto &amp;c = castContainerRef&lt;UnitComplexNum&lt;Type&gt;&gt;();\n        c.normalize();\n        return c;\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline Quaternion&lt;Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2QuaternionRef()\n    {\n        return castContainerRef&lt;Quaternion&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline UnitQuaternion&lt;Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2UnitQuaternionRef()\n    {\n        auto &amp;q = castContainerRef&lt;UnitQuaternion&lt;Type&gt;&gt;();\n        q.normalize();\n        return q;\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline SOGroup&lt;N, Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2SOGroupRef()\n    {\n        auto &amp;so = castContainerRef&lt;SOGroup&lt;N, Type&gt;&gt;();\n        so.normalize();\n        return so;\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline DualNumber&lt;Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2DualNumberRef()\n    {\n        return castContainerRef&lt;DualNumber&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline DualQuaternion&lt;Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2DualQuaternionRef()\n    {\n        return castContainerRef&lt;DualQuaternion&lt;Type&gt;&gt;();\n    }\n    template &lt;size_t N, size_t M, typename Type, typename Derived&gt;\n    template &lt;size_t N_, size_t M_, typename&gt;\n    inline UnitDualQuaternion&lt;Type&gt; &amp;MatrixBase&lt;N, M, Type, Derived&gt;::cast2UnitDualQuaternionRef()\n    {\n        auto &amp;udq = castContainerRef&lt;UnitDualQuaternion&lt;Type&gt;&gt;();\n        udq.normalize();\n        return udq;\n    }\n\n}\n</code></pre>"},{"location":"translotator/dir_19a7ecde96094a236c7c8e28b6698d62/","title":"Dir include/translotator/utils","text":"<p>FileList &gt; include &gt; translotator &gt; utils</p>"},{"location":"translotator/dir_19a7ecde96094a236c7c8e28b6698d62/#files","title":"Files","text":"Type Name file default_type.hpp file epsilon.hpp file micro_math.hpp file micro_type_traits.hpp <p>The documentation for this class was generated from the following file <code>include/translotator/utils/</code></p>"},{"location":"translotator/default__type_8hpp/","title":"File default_type.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; utils &gt; default_type.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../config.hpp\"</code></li> </ul>"},{"location":"translotator/default__type_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/default__type_8hpp/#macros","title":"Macros","text":"Type Name define TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE  float"},{"location":"translotator/default__type_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"translotator/default__type_8hpp/#define-translotator_default_floating_point_type","title":"define TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE","text":"<pre><code>#define TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE float\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/utils/default_type.hpp</code></p>"},{"location":"translotator/default__type_8hpp_source/","title":"File default_type.hpp","text":"<p>File List &gt; include &gt; translotator &gt; utils &gt; default_type.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : default_type.hpp\n */\n\n#pragma once\n\n#include \"../config.hpp\"\n\nnamespace translotator\n{\n\n#ifdef CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32\n#define TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE float\n#elif CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_64\n#define TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE double\n#elif CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_128\n#define TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE long double\n#endif\n\n}\n</code></pre>"},{"location":"translotator/epsilon_8hpp/","title":"File epsilon.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; utils &gt; epsilon.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"../config.hpp\"</code></li> <li><code>#include \"micro_type_traits.hpp\"</code></li> <li><code>#include &lt;cstddef&gt;</code></li> </ul>"},{"location":"translotator/epsilon_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator <p>The documentation for this class was generated from the following file <code>include/translotator/utils/epsilon.hpp</code></p>"},{"location":"translotator/epsilon_8hpp_source/","title":"File epsilon.hpp","text":"<p>File List &gt; include &gt; translotator &gt; utils &gt; epsilon.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : epsilon.hpp\n */\n\n#pragma once\n\n#include \"../config.hpp\"\n#include \"micro_type_traits.hpp\"\n#include &lt;cstddef&gt;\n\nnamespace translotator\n{\n    template &lt;typename T, size_t N&gt;\n    constexpr T exponent_epsilon()\n    {\n        static_assert(is_float_v&lt;T&gt; &amp;&amp; 1U &lt;= N &amp;&amp; N &lt;= 20U, \"exponent_epsilon only supports float, double, long double and 1 &lt;= N &lt;= 20\");\n        if constexpr (N == 1U) // TODO change all template variables + U for neat and clean code\n            return static_cast&lt;T&gt;(1e-1L);\n        else if constexpr (N == 2U)\n            return static_cast&lt;T&gt;(1e-2L);\n        else if constexpr (N == 3U)\n            return static_cast&lt;T&gt;(1e-3L);\n        else if constexpr (N == 4U)\n            return static_cast&lt;T&gt;(1e-4L);\n        else if constexpr (N == 5U)\n            return static_cast&lt;T&gt;(1e-5L);\n        else if constexpr (N == 6U)\n            return static_cast&lt;T&gt;(1e-6L);\n        else if constexpr (N == 7U)\n            return static_cast&lt;T&gt;(1e-7L);\n        else if constexpr (N == 8U)\n            return static_cast&lt;T&gt;(1e-8L);\n        else if constexpr (N == 9U)\n            return static_cast&lt;T&gt;(1e-9L);\n        else if constexpr (N == 10U)\n            return static_cast&lt;T&gt;(1e-10L);\n        else if constexpr (N == 11U)\n            return static_cast&lt;T&gt;(1e-11L);\n        else if constexpr (N == 12U)\n            return static_cast&lt;T&gt;(1e-12L);\n        else if constexpr (N == 13U)\n            return static_cast&lt;T&gt;(1e-13L);\n        else if constexpr (N == 14U)\n            return static_cast&lt;T&gt;(1e-14L);\n        else if constexpr (N == 15U)\n            return static_cast&lt;T&gt;(1e-15L);\n        else if constexpr (N == 16U)\n            return static_cast&lt;T&gt;(1e-16L);\n        else if constexpr (N == 17U)\n            return static_cast&lt;T&gt;(1e-17L);\n        else if constexpr (N == 18U)\n            return static_cast&lt;T&gt;(1e-18L);\n        else if constexpr (N == 19U)\n            return static_cast&lt;T&gt;(1e-19L);\n        else if constexpr (N == 20U)\n            return static_cast&lt;T&gt;(1e-20L);\n    }\n\n    template &lt;typename T&gt;\n    constexpr T epsilon()\n    {\n        static_assert(is_float_v&lt;T&gt;, \"epsilon only supports float, double, long double\");\n\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return exponent_epsilon&lt;float, CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32_EPSILON&gt;();\n        if constexpr (is_same_v&lt;T, double&gt;)\n            return exponent_epsilon&lt;double, CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_64_EPSILON&gt;();\n        if constexpr (is_same_v&lt;T, long double&gt;)\n            return exponent_epsilon&lt;long double, CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_128_EPSILON&gt;();\n        else\n            static_assert(is_float_v&lt;T&gt;, \"epsilon only supports float, double, long double\");\n    }\n}\n</code></pre>"},{"location":"translotator/micro__math_8hpp/","title":"File micro_math.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; utils &gt; micro_math.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include \"micro_type_traits.hpp\"</code></li> </ul>"},{"location":"translotator/micro__math_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_math.hpp</code></p>"},{"location":"translotator/micro__math_8hpp_source/","title":"File micro_math.hpp","text":"<p>File List &gt; include &gt; translotator &gt; utils &gt; micro_math.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : micro_math.hpp\n */\n\n#pragma once\n\n#include &lt;math.h&gt;\n#include \"micro_type_traits.hpp\"\n\nnamespace translotator\n{\n\n    template &lt;typename T&gt;\n    inline T sqrt(const T &amp;v)\n    {\n\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::sqrtf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::sqrt(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::sqrtl(v);\n        else\n            return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T sin(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::sinf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::sin(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::sinl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T cos(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::cosf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::cos(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::cosl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T tan(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::tanf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::tan(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::tanl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T asin(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::asinf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::asin(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::asinl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T acos(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::acosf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::acos(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::acosl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T atan(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::atanf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::atan(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::atanl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T atan2(const T &amp;y, const T &amp;x)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::atan2f(y, x);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::atan2(y, x);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::atan2l(y, x);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T fmin(const T &amp;x, const T &amp;y)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::fminf(x, y);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::fmin(x, y);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::fminl(x, y);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T fmax(const T &amp;x, const T &amp;y)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::fmaxf(x, y);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::fmax(x, y);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::fmaxl(x, y);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T powf(const T &amp;x, const T &amp;y)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::powf(x, y);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::pow(x, y);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::powl(x, y);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T square(const T &amp;v) { return v * v; }\n\n    template &lt;typename T&gt;\n    inline T cube(const T &amp;v) { return v * v * v; }\n\n    template &lt;typename T&gt;\n    inline T abs(const T &amp;v) { return v &lt; 0 ? -v : v; }\n\n    template &lt;typename T&gt;\n    inline T exp(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::expf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::exp(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::expl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T ceil(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::ceilf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::ceil(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::ceill(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T floorf(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::floorf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::floor(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::floorl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T ceilf(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::ceilf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::ceil(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::ceill(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T roundf(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::roundf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::round(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::roundl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n\n    template &lt;typename T&gt;\n    inline T truncf(const T &amp;v)\n    {\n        static_assert(is_float_v&lt;T&gt;, \"Unsupported type\");\n        if constexpr (is_same_v&lt;T, float&gt;)\n            return ::truncf(v);\n        else if constexpr (is_same_v&lt;T, double&gt;)\n            return ::trunc(v);\n        else if constexpr (is_same_v&lt;T, long double&gt;)\n            return ::truncl(v);\n        return static_cast&lt;T&gt;(0);\n    }\n}\n</code></pre>"},{"location":"translotator/micro__type__traits_8hpp/","title":"File micro_type_traits.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; utils &gt; micro_type_traits.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/micro__type__traits_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace translotator"},{"location":"translotator/micro__type__traits_8hpp/#classes","title":"Classes","text":"Type Name struct all_same&lt; T &gt; &lt;typename T&gt; struct all_same&lt; T, First, Rest... &gt; &lt;typename T, typename First, Rest&gt; struct conditional_if &lt;B, typename T, typename F&gt; struct conditional_if&lt; false, T, F &gt; &lt;typename T, typename F&gt; struct enable_if &lt;B, typename T&gt; struct enable_if&lt; true, T &gt; &lt;typename T&gt; struct integral_constant &lt;typename T, v&gt; struct is_float &lt;typename T&gt; struct is_float&lt; double &gt; &lt;&gt; struct is_float&lt; float &gt; &lt;&gt; struct is_float&lt; long double &gt; &lt;&gt; struct is_matrix_base &lt;typename T, typename&gt; struct is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt; &lt;typename T&gt; struct is_same &lt;typename T, typename U&gt; struct is_same&lt; T, T &gt; &lt;typename T&gt; <p>The documentation for this class was generated from the following file <code>include/translotator/utils/micro_type_traits.hpp</code></p>"},{"location":"translotator/micro__type__traits_8hpp_source/","title":"File micro_type_traits.hpp","text":"<p>File List &gt; include &gt; translotator &gt; utils &gt; micro_type_traits.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : micro_type_traits.hpp\n */\n\n#pragma once\n\nnamespace translotator\n{\n    //  enable_if\n    template &lt;bool B, typename T = void&gt;\n    struct enable_if\n    {\n    };\n    template &lt;typename T&gt;\n    struct enable_if&lt;true, T&gt;\n    {\n        using type = T;\n    };\n\n    // enable_if_t\n    template &lt;bool B, typename T = void&gt;\n    using enable_if_t = typename enable_if&lt;B, T&gt;::type;\n\n    // conditional_if\n    template &lt;bool B, typename T, typename F&gt;\n    struct conditional_if\n    {\n        using type = T;\n    };\n    template &lt;typename T, typename F&gt;\n    struct conditional_if&lt;false, T, F&gt;\n    {\n        using type = F;\n    };\n\n    // conditional_if_t\n    template &lt;bool B, typename T, typename F&gt;\n    using conditional_if_t = typename conditional_if&lt;B, T, F&gt;::type;\n\n    // integral constant\n    template &lt;typename T, T v&gt;\n    struct integral_constant\n    {\n        static constexpr T value = v;\n        using value_type = T;\n        using type = integral_constant;\n        constexpr operator value_type() const noexcept { return value; }\n        constexpr value_type operator()() const noexcept { return value; }\n    };\n\n    // true false type\n    using true_type = integral_constant&lt;bool, true&gt;;\n    using false_type = integral_constant&lt;bool, false&gt;;\n\n    // is_same\n    template &lt;typename T, typename U&gt;\n    struct is_same : false_type\n    {\n    };\n    template &lt;typename T&gt;\n    struct is_same&lt;T, T&gt; : true_type\n    {\n    };\n\n    // is_same_v\n    template &lt;typename T, typename U&gt;\n    inline constexpr bool is_same_v = is_same&lt;T, U&gt;::value;\n\n    // all_same\n    template &lt;typename T, typename... Args&gt;\n    struct all_same;\n    template &lt;typename T&gt;\n    struct all_same&lt;T&gt;\n    {\n        static constexpr bool value = true;\n    };\n    template &lt;typename T, typename First, typename... Rest&gt;\n    struct all_same&lt;T, First, Rest...&gt;\n    {\n        static constexpr bool value = is_same_v&lt;T, First&gt; &amp;&amp; all_same&lt;T, Rest...&gt;::value;\n    };\n\n    // all_same_v\n    template &lt;typename T, typename... Args&gt;\n    inline constexpr bool all_same_v = all_same&lt;T, Args...&gt;::value;\n\n    // is_float\n    template &lt;typename T&gt;\n    struct is_float : false_type\n    {\n    };\n    template &lt;&gt;\n    struct is_float&lt;float&gt; : true_type\n    {\n    };\n    template &lt;&gt;\n    struct is_float&lt;double&gt; : true_type\n    {\n    };\n    template &lt;&gt;\n    struct is_float&lt;long double&gt; : true_type\n    {\n    };\n\n    // is_float_v\n    template &lt;typename T&gt;\n    inline constexpr bool is_float_v = is_float&lt;T&gt;::value;\n\n    // is_matrix_base\n\n    template &lt;typename T, typename = void&gt;\n    struct is_matrix_base : false_type\n    {\n    };\n    template &lt;typename T&gt;\n    struct is_matrix_base&lt;T, typename enable_if&lt;T::MATRIX_BASE&gt;::type&gt; : true_type\n    {\n    };\n\n    // is_matrix_base_v\n    template &lt;typename T&gt;\n    inline constexpr bool is_matrix_base_v = is_matrix_base&lt;T&gt;::value;\n}\n</code></pre>"},{"location":"translotator/translotator_8hpp/","title":"File translotator.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; translotator.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;assert.h&gt;</code></li> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include \"utils/default_type.hpp\"</code></li> <li><code>#include \"utils/micro_math.hpp\"</code></li> <li><code>#include \"utils/epsilon.hpp\"</code></li> <li><code>#include \"objects/objectdefs.hpp\"</code></li> <li><code>#include \"objects/initializer_list.hpp\"</code></li> <li><code>#include \"objects/MatrixBaseInternal.hpp\"</code></li> <li><code>#include \"objects/MatrixBase.hpp\"</code></li> <li><code>#include \"objects/Matrix.hpp\"</code></li> <li><code>#include \"objects/SquareMatrix.hpp\"</code></li> <li><code>#include \"objects/Vector.hpp\"</code></li> <li><code>#include \"objects/ComplexNum.hpp\"</code></li> <li><code>#include \"objects/Quaternion.hpp\"</code></li> <li><code>#include \"objects/DualNumber.hpp\"</code></li> <li><code>#include \"objects/DualQuaternion.hpp\"</code></li> <li><code>#include \"objects/UnitComplexNum.hpp\"</code></li> <li><code>#include \"objects/UnitQuaternion.hpp\"</code></li> <li><code>#include \"objects/SOGroup.hpp\"</code></li> <li><code>#include \"objects/AxisAngle.hpp\"</code></li> <li><code>#include \"objects/EulerAngle.hpp\"</code></li> <li><code>#include \"objects/SEGroup.hpp\"</code></li> <li><code>#include \"objects/UnitDualQuaternion.hpp\"</code></li> <li><code>#include \"lie/LieOperator.hpp\"</code></li> <li><code>#include \"interpolators/Lerp.hpp\"</code></li> <li><code>#include \"interpolators/Slerp.hpp\"</code></li> <li><code>#include \"interpolators/ScLerp.hpp\"</code></li> <li><code>#include \"interpolators/Slerp_Lerp.hpp\"</code></li> <li><code>#include \"objects/tail.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>include/translotator/translotator.hpp</code></p>"},{"location":"translotator/translotator_8hpp_source/","title":"File translotator.hpp","text":"<p>File List &gt; include &gt; translotator &gt; translotator.hpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * The MIT License (MIT)\n * Copyright (c) 2024 Jiseok Lee\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Created on Tue Nov 19 2024\n * @file : translotator.hpp\n */\n\n#pragma once\n\n#include &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n\n#include \"utils/default_type.hpp\"\n#include \"utils/micro_math.hpp\"\n#include \"utils/epsilon.hpp\"\n\n// basic object definitions\n#include \"objects/objectdefs.hpp\"\n#include \"objects/initializer_list.hpp\"\n\n// matrix based objects\n#include \"objects/MatrixBaseInternal.hpp\"\n#include \"objects/MatrixBase.hpp\"\n#include \"objects/Matrix.hpp\"\n#include \"objects/SquareMatrix.hpp\"\n#include \"objects/Vector.hpp\"\n\n// number systems\n#include \"objects/ComplexNum.hpp\"\n#include \"objects/Quaternion.hpp\"\n#include \"objects/DualNumber.hpp\"\n#include \"objects/DualQuaternion.hpp\"\n\n// rotation objects, SO(2), SO(3)\n#include \"objects/UnitComplexNum.hpp\"\n#include \"objects/UnitQuaternion.hpp\"\n#include \"objects/SOGroup.hpp\"\n#include \"objects/AxisAngle.hpp\"\n#include \"objects/EulerAngle.hpp\"\n\n// homogeneous transformation objects\n#include \"objects/SEGroup.hpp\"\n#include \"objects/UnitDualQuaternion.hpp\"\n\n// lie group operations\n#include \"lie/LieOperator.hpp\"\n\n// interpolators\n#include \"interpolators/Lerp.hpp\"\n#include \"interpolators/Slerp.hpp\"\n#include \"interpolators/ScLerp.hpp\"\n#include \"interpolators/Slerp_Lerp.hpp\"\n\n#include \"objects/tail.hpp\"\n</code></pre>"},{"location":"translotator/version_8hpp/","title":"File version.hpp","text":"<p>FileList &gt; include &gt; translotator &gt; version.hpp</p> <p>Go to the source code of this file</p>"},{"location":"translotator/version_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace TRANSLOTATOR"},{"location":"translotator/version_8hpp/#macros","title":"Macros","text":"Type Name define TRANSLOTATOR_MAJOR_VERSION  0 define TRANSLOTATOR_MINOR_VERSION  0 define TRANSLOTATOR_PATCH_VERSION  0 define TRANSLOTATOR_TWEAK_VERSION  \"8eda355\" define TRANSLOTATOR_VERSION  \"0.0.0\""},{"location":"translotator/version_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"translotator/version_8hpp/#define-translotator_major_version","title":"define TRANSLOTATOR_MAJOR_VERSION","text":"<pre><code>#define TRANSLOTATOR_MAJOR_VERSION 0\n</code></pre>"},{"location":"translotator/version_8hpp/#define-translotator_minor_version","title":"define TRANSLOTATOR_MINOR_VERSION","text":"<pre><code>#define TRANSLOTATOR_MINOR_VERSION 0\n</code></pre>"},{"location":"translotator/version_8hpp/#define-translotator_patch_version","title":"define TRANSLOTATOR_PATCH_VERSION","text":"<pre><code>#define TRANSLOTATOR_PATCH_VERSION 0\n</code></pre>"},{"location":"translotator/version_8hpp/#define-translotator_tweak_version","title":"define TRANSLOTATOR_TWEAK_VERSION","text":"<pre><code>#define TRANSLOTATOR_TWEAK_VERSION \"8eda355\"\n</code></pre>"},{"location":"translotator/version_8hpp/#define-translotator_version","title":"define TRANSLOTATOR_VERSION","text":"<pre><code>#define TRANSLOTATOR_VERSION \"0.0.0\"\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/translotator/version.hpp</code></p>"},{"location":"translotator/version_8hpp_source/","title":"File version.hpp","text":"<p>File List &gt; include &gt; translotator &gt; version.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\nnamespace TRANSLOTATOR\n{\n#define TRANSLOTATOR_VERSION \"0.0.0\"\n\n#define TRANSLOTATOR_MAJOR_VERSION 0\n#define TRANSLOTATOR_MINOR_VERSION 0\n#define TRANSLOTATOR_PATCH_VERSION 0\n#define TRANSLOTATOR_TWEAK_VERSION \"8eda355\"\n}\n</code></pre>"},{"location":"translotator/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace TRANSLOTATOR </li> <li>namespace translotator <ul> <li>namespace EULER_CONSTEXPR Namespace for Euler Order constexpr functions. </li> <li>namespace MatrixBaseInternal Internal namespace for MatrixBase implementation. </li> <li>namespace interpolators </li> <li>namespace lie Namespace for Lie Group and Algebra Operations. </li> </ul> </li> </ul>"},{"location":"translotator/classes/","title":"Class Index","text":""},{"location":"translotator/classes/#a","title":"a","text":"<ul> <li>all_same (translotator)</li> <li>all_same&lt; T &gt; (translotator)</li> <li>all_same&lt; T, First, Rest... &gt; (translotator)</li> <li>AxisAngle (translotator)</li> </ul>"},{"location":"translotator/classes/#c","title":"c","text":"<ul> <li>ComplexNum (translotator)</li> <li>conditional_if (translotator)</li> <li>conditional_if&lt; false, T, F &gt; (translotator)</li> </ul>"},{"location":"translotator/classes/#d","title":"d","text":"<ul> <li>DualNumber (translotator)</li> <li>DualQuaternion (translotator)</li> </ul>"},{"location":"translotator/classes/#e","title":"e","text":"<ul> <li>enable_if (translotator)</li> <li>enable_if&lt; true, T &gt; (translotator)</li> <li>EulerAngle (translotator)</li> </ul>"},{"location":"translotator/classes/#i","title":"i","text":"<ul> <li>initializer_list (translotator)</li> <li>integral_constant (translotator)</li> <li>is_float (translotator)</li> <li>is_float&lt; double &gt; (translotator)</li> <li>is_float&lt; float &gt; (translotator)</li> <li>is_float&lt; long double &gt; (translotator)</li> <li>is_matrix_base (translotator)</li> <li>is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt; (translotator)</li> <li>is_same (translotator)</li> <li>is_same&lt; T, T &gt; (translotator)</li> </ul>"},{"location":"translotator/classes/#l","title":"l","text":"<ul> <li>Lerper (translotator::interpolators)</li> <li>LieOperator (translotator::lie)</li> <li>LieOperator&lt; ObjectType::SE_GROUP, Type &gt; (translotator::lie)</li> <li>LieOperator&lt; ObjectType::SO_GROUP, Type &gt; (translotator::lie)</li> <li>LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt; (translotator::lie)</li> <li>LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt; (translotator::lie)</li> </ul>"},{"location":"translotator/classes/#m","title":"m","text":"<ul> <li>Matrix (translotator)</li> <li>MatrixBase (translotator)</li> </ul>"},{"location":"translotator/classes/#o","title":"o","text":"<ul> <li>operator_cast_typemapper (translotator::MatrixBaseInternal)</li> <li>operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt; (translotator::MatrixBaseInternal)</li> <li>operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt; (translotator::MatrixBaseInternal)</li> <li>operator_mul_typemapper (translotator::MatrixBaseInternal)</li> <li>operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; (translotator::MatrixBaseInternal)</li> <li>operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; (translotator::MatrixBaseInternal)</li> <li>operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; (translotator::MatrixBaseInternal)</li> <li>operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; (translotator::MatrixBaseInternal)</li> </ul>"},{"location":"translotator/classes/#q","title":"q","text":"<ul> <li>Quaternion (translotator)</li> </ul>"},{"location":"translotator/classes/#s","title":"s","text":"<ul> <li>ScLerper (translotator::interpolators)</li> <li>SEGroup (translotator)</li> <li>Slerper (translotator::interpolators)</li> <li>SlerperFast (translotator::interpolators)</li> <li>SlerpLerper (translotator::interpolators)</li> <li>SOGroup (translotator)</li> <li>SquareMatrix (translotator)</li> </ul>"},{"location":"translotator/classes/#u","title":"u","text":"<ul> <li>UnitComplexNum (translotator)</li> <li>UnitDualQuaternion (translotator)</li> <li>UnitQuaternion (translotator)</li> </ul>"},{"location":"translotator/classes/#v","title":"v","text":"<ul> <li>Vector (translotator)</li> </ul>"},{"location":"translotator/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class translotator::AxisAngle Represents a rotation in 3D space by an angle around an axis. </li> <li>class translotator::MatrixBase Base class for all matrix objects. <ul> <li>class translotator::Vector Vector class.</li> </ul> </li> <li>class translotator::EulerAngle Represents Euler angle 3D rotation. </li> <li>class translotator::SEGroup Special Euclidean Group. </li> <li>class translotator::interpolators::Lerper Linear interpolation class. </li> <li>class translotator::interpolators::ScLerper Screw linear interpolation class. </li> <li>class translotator::interpolators::SlerpLerper Slerp for rotation component, lerp for translation component class. </li> <li>class translotator::interpolators::Slerper Slerp for rotation component interpolation class. </li> <li>class translotator::interpolators::SlerperFast Slerp for rotation component interpolation class. Faster than Slerper for S1, S3 group.</li> <li>struct translotator::MatrixBaseInternal::operator_cast_typemapper </li> <li>struct translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt; </li> <li>struct translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt; </li> <li>struct translotator::MatrixBaseInternal::operator_mul_typemapper </li> <li>struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; </li> <li>struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; </li> <li>struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt; </li> <li>struct translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt; </li> <li>struct translotator::all_same </li> <li>struct translotator::all_same&lt; T &gt; </li> <li>struct translotator::all_same&lt; T, First, Rest... &gt; </li> <li>struct translotator::conditional_if </li> <li>struct translotator::conditional_if&lt; false, T, F &gt; </li> <li>struct translotator::enable_if </li> <li>struct translotator::enable_if&lt; true, T &gt; </li> <li>struct translotator::initializer_list initializer_list struct</li> <li>struct translotator::integral_constant <ul> <li>struct translotator::is_float </li> <li>struct translotator::is_float&lt; double &gt; </li> <li>struct translotator::is_float&lt; float &gt; </li> <li>struct translotator::is_float&lt; long double &gt; </li> <li>struct translotator::is_matrix_base </li> <li>struct translotator::is_matrix_base&lt; T, typename enable_if&lt; T::MATRIX_BASE &gt;::type &gt; </li> <li>struct translotator::is_same </li> <li>struct translotator::is_same&lt; T, T &gt; </li> </ul> </li> <li>struct translotator::lie::LieOperator Lie Operator for Lie Group and Lie Algebra. </li> <li>struct translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt; Lie Operator for SE. </li> <li>struct translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt; Special Orthogonal Group. </li> <li>struct translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt; Lie Operator for S1. </li> <li>struct translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt; Lie Operator for S3. </li> </ul>"},{"location":"translotator/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"translotator/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"translotator/class_members/","title":"Class Members","text":""},{"location":"translotator/class_members/#a","title":"a","text":"<ul> <li>AxisAngle (translotator::AxisAngle)</li> <li>angle (translotator::AxisAngle)</li> <li>angle_ (translotator::AxisAngle)</li> <li>axis (translotator::AxisAngle)</li> <li>axisNormalize (translotator::AxisAngle)</li> <li>axisNormalized (translotator::AxisAngle)</li> <li>axisRotation (translotator::AxisAngle, translotator::EulerAngle, translotator::SOGroup, translotator::UnitQuaternion)</li> <li>axis_ (translotator::AxisAngle)</li> <li>angles_ (translotator::EulerAngle)</li> <li>actOnVector (translotator::SEGroup)</li> <li>actOnVector2D (translotator::UnitDualQuaternion)</li> <li>actOnVector3D (translotator::UnitDualQuaternion)</li> </ul>"},{"location":"translotator/class_members/#b","title":"b","text":"<ul> <li>block (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_members/#c","title":"c","text":"<ul> <li>castDataType (translotator::AxisAngle, translotator::EulerAngle, translotator::MatrixBase)</li> <li>ComplexNum (translotator::ComplexNum)</li> <li>complexNumDiv (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>complexNumDivEq (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>complexNumMul (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>complexNumMulEq (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>conjugate (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::UnitDualQuaternion)</li> <li>conjugated (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>conjugateDual (translotator::DualQuaternion)</li> <li>conjugateFull (translotator::DualQuaternion)</li> <li>conjugatePrimary (translotator::DualQuaternion)</li> <li>conjugatedDual (translotator::DualQuaternion)</li> <li>conjugatedFull (translotator::DualQuaternion)</li> <li>conjugatedPrimary (translotator::DualQuaternion)</li> <li>castAxisOrder (translotator::EulerAngle)</li> <li>COLS (translotator::MatrixBase)</li> <li>cast2ComplexNum (translotator::MatrixBase)</li> <li>cast2ComplexNumRef (translotator::MatrixBase)</li> <li>cast2DualNumber (translotator::MatrixBase)</li> <li>cast2DualNumberRef (translotator::MatrixBase)</li> <li>cast2DualQuaternion (translotator::MatrixBase)</li> <li>cast2DualQuaternionRef (translotator::MatrixBase)</li> <li>cast2Matrix (translotator::MatrixBase)</li> <li>cast2MatrixRef (translotator::MatrixBase)</li> <li>cast2Quaternion (translotator::MatrixBase)</li> <li>cast2QuaternionRef (translotator::MatrixBase)</li> <li>cast2SOGroup (translotator::MatrixBase)</li> <li>cast2SOGroupRef (translotator::MatrixBase)</li> <li>cast2SquareMatrix (translotator::MatrixBase)</li> <li>cast2SquareMatrixRef (translotator::MatrixBase)</li> <li>cast2UnitComplexNum (translotator::MatrixBase)</li> <li>cast2UnitComplexNumRef (translotator::MatrixBase)</li> <li>cast2UnitDualQuaternion (translotator::MatrixBase)</li> <li>cast2UnitDualQuaternionRef (translotator::MatrixBase)</li> <li>cast2UnitQuaternion (translotator::MatrixBase)</li> <li>cast2UnitQuaternionRef (translotator::MatrixBase)</li> <li>cast2Vector (translotator::MatrixBase)</li> <li>cast2VectorRef (translotator::MatrixBase)</li> <li>castContainer (translotator::MatrixBase)</li> <li>castContainerRef (translotator::MatrixBase)</li> <li>col (translotator::MatrixBase)</li> <li>colSize (translotator::MatrixBase)</li> <li>copyTo (translotator::MatrixBase)</li> <li>canonicalize (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>canonicalized (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>cross (translotator::Vector)</li> </ul>"},{"location":"translotator/class_members/#d","title":"d","text":"<ul> <li>Du (translotator::DualNumber, translotator::DualQuaternion)</li> <li>DualNumber (translotator::DualNumber)</li> <li>dualNumDiv (translotator::DualNumber)</li> <li>dualNumDivEq (translotator::DualNumber)</li> <li>dualNumMul (translotator::DualNumber)</li> <li>dualNumMulEq (translotator::DualNumber)</li> <li>DualQuaternion (translotator::DualQuaternion)</li> <li>dualQuatDiv (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dualQuatDivEq (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dualQuatMul (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dualQuatMulEq (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dw (translotator::DualQuaternion)</li> <li>dx (translotator::DualQuaternion)</li> <li>dy (translotator::DualQuaternion)</li> <li>dz (translotator::DualQuaternion)</li> <li>DATATYPE (translotator::MatrixBase, translotator::SEGroup)</li> <li>data_ (translotator::MatrixBase)</li> <li>Data_ (translotator::SOGroup, translotator::SquareMatrix)</li> <li>determinant (translotator::SquareMatrix)</li> <li>dot (translotator::Vector)</li> <li>data (translotator::initializer_list)</li> <li>diff_ (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> </ul>"},{"location":"translotator/class_members/#e","title":"e","text":"<ul> <li>EulerAngle (translotator::EulerAngle)</li> <li>eye (translotator::MatrixBase)</li> <li>end_ (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>Exp (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>exp (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_members/#f","title":"f","text":"<ul> <li>fill (translotator::MatrixBase)</li> <li>frobeniusNorm (translotator::MatrixBase)</li> <li>frobeniusNormSquared (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_members/#g","title":"g","text":"<ul> <li>getAngleInOrder (translotator::EulerAngle)</li> <li>getAxisInOrder (translotator::EulerAngle)</li> <li>getData (translotator::MatrixBase)</li> <li>getDiff (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> <li>getEnd (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>getStart (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_members/#i","title":"i","text":"<ul> <li>identity (translotator::AxisAngle, translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>inverse (translotator::AxisAngle, translotator::ComplexNum, translotator::DualQuaternion, translotator::Quaternion, translotator::SOGroup, translotator::SquareMatrix, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>inversed (translotator::AxisAngle, translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::SquareMatrix, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>Im (translotator::ComplexNum, translotator::Quaternion)</li> <li>initializer_list (translotator::initializer_list)</li> <li>interpolate (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_members/#l","title":"l","text":"<ul> <li>Lerper (translotator::interpolators::Lerper)</li> <li>LieAlgebra2Vector (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>LieAlgebraType (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>LieGroupType (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>Log (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>log (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_members/#m","title":"m","text":"<ul> <li>MATRIX_BASE (translotator::MatrixBase)</li> <li>MatrixBase (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_members/#n","title":"n","text":"<ul> <li>norm (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::Vector)</li> <li>normSquared (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::Vector)</li> <li>normalize (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::SOGroup, translotator::UnitDualQuaternion, translotator::Vector)</li> <li>normalized (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion, translotator::Vector)</li> <li>normDualNum (translotator::DualQuaternion)</li> <li>normDualNumSquared (translotator::DualQuaternion)</li> <li>normScalar (translotator::DualQuaternion)</li> <li>normScalarSquared (translotator::DualQuaternion)</li> <li>NaN (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_members/#o","title":"o","text":"<ul> <li>OBJECT_TYPE (translotator::AxisAngle, translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::EulerAngle, translotator::Matrix, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::SquareMatrix, translotator::UnitDualQuaternion, translotator::UnitQuaternion, translotator::Vector)</li> <li>operator* (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator*= (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator/ (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator/= (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator[] (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::EulerAngle, translotator::Quaternion, translotator::Vector)</li> <li>ones (translotator::MatrixBase)</li> <li>operator() (translotator::MatrixBase, translotator::integral_constant, translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>operator+ (translotator::MatrixBase, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator+= (translotator::MatrixBase)</li> <li>operator- (translotator::MatrixBase, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator-= (translotator::MatrixBase)</li> <li>operator= (translotator::MatrixBase)</li> <li>objType (translotator::UnitComplexNum)</li> <li>operator value_type (translotator::integral_constant)</li> </ul>"},{"location":"translotator/class_members/#p","title":"p","text":"<ul> <li>pitch (translotator::EulerAngle)</li> <li>print (translotator::MatrixBase, translotator::SEGroup)</li> <li>pow (translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> </ul>"},{"location":"translotator/class_members/#q","title":"q","text":"<ul> <li>Quaternion (translotator::Quaternion)</li> <li>quatNumDiv (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>quatNumDivEq (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>quatNumMul (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>quatNumMulEq (translotator::Quaternion, translotator::UnitQuaternion)</li> </ul>"},{"location":"translotator/class_members/#r","title":"r","text":"<ul> <li>rotateVector2D (translotator::AxisAngle, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>rotateVector3D (translotator::AxisAngle, translotator::UnitQuaternion)</li> <li>Re (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::UnitDualQuaternion)</li> <li>rw (translotator::DualQuaternion)</li> <li>rx (translotator::DualQuaternion)</li> <li>ry (translotator::DualQuaternion)</li> <li>rz (translotator::DualQuaternion)</li> <li>roll (translotator::EulerAngle)</li> <li>rotateVec2D (translotator::EulerAngle)</li> <li>rotateVec3D (translotator::EulerAngle)</li> <li>ROWS (translotator::MatrixBase)</li> <li>row (translotator::MatrixBase)</li> <li>rowSize (translotator::MatrixBase)</li> <li>R_ (translotator::SEGroup)</li> <li>rotation (translotator::SEGroup)</li> </ul>"},{"location":"translotator/class_members/#s","title":"s","text":"<ul> <li>sqrt (translotator::DualNumber)</li> <li>setBlock (translotator::MatrixBase)</li> <li>setCol (translotator::MatrixBase)</li> <li>setRow (translotator::MatrixBase)</li> <li>swapCols (translotator::MatrixBase)</li> <li>swapRows (translotator::MatrixBase)</li> <li>SEGroup (translotator::SEGroup)</li> <li>SOGroup (translotator::SOGroup)</li> <li>ScalarType (translotator::interpolators::Lerper)</li> <li>setDiff (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> <li>setEnd (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>setStart (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>start_ (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>ScLerper (translotator::interpolators::ScLerper)</li> <li>SlerpLerper (translotator::interpolators::SlerpLerper)</li> <li>Slerper (translotator::interpolators::Slerper)</li> <li>SlerperFast (translotator::interpolators::SlerperFast)</li> <li>shortest_path_ (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_members/#t","title":"t","text":"<ul> <li>toAngleVector (translotator::AxisAngle)</li> <li>toEulerAngle2D (translotator::AxisAngle, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>toEulerAngle3D (translotator::AxisAngle, translotator::UnitQuaternion)</li> <li>toRotMatrix2D (translotator::AxisAngle, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>toRotMatrix3D (translotator::AxisAngle, translotator::UnitQuaternion)</li> <li>toUnitComplexNum (translotator::AxisAngle, translotator::EulerAngle, translotator::SOGroup)</li> <li>toUnitQuaternion (translotator::AxisAngle, translotator::EulerAngle, translotator::SOGroup)</li> <li>toMulMatrix (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion)</li> <li>toRightMulMatrix (translotator::DualQuaternion, translotator::Quaternion)</li> <li>toAxisAngle (translotator::EulerAngle, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>toSO2Group (translotator::EulerAngle)</li> <li>toSO3Group (translotator::EulerAngle)</li> <li>toVector (translotator::EulerAngle)</li> <li>T (translotator::MatrixBase, translotator::SOGroup)</li> <li>toScalar (translotator::MatrixBase)</li> <li>type (translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt;, translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;, translotator::conditional_if, translotator::conditional_if&lt; false, T, F &gt;, translotator::enable_if&lt; true, T &gt;, translotator::integral_constant)</li> <li>t_ (translotator::SEGroup)</li> <li>toSquareMatrix (translotator::SEGroup)</li> <li>translation (translotator::SEGroup)</li> <li>toEulerAngle (translotator::SOGroup)</li> <li>trace (translotator::SquareMatrix)</li> <li>toSE2Group (translotator::UnitDualQuaternion)</li> <li>toSE3Group (translotator::UnitDualQuaternion)</li> <li>toTranslationVec2D (translotator::UnitDualQuaternion)</li> <li>toTranslationVec3D (translotator::UnitDualQuaternion)</li> <li>toCrossMatrix (translotator::Vector)</li> <li>toDiagMatrix (translotator::Vector)</li> <li>Type (translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>theta_ (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_members/#u","title":"u","text":"<ul> <li>UnitComplexNum (translotator::UnitComplexNum)</li> <li>UnitDualQuaternion (translotator::UnitDualQuaternion)</li> <li>UnitQuaternion (translotator::UnitQuaternion)</li> <li>updateDiff (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> <li>update_theta (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_members/#v","title":"v","text":"<ul> <li>value (translotator::all_same&lt; T &gt;, translotator::all_same&lt; T, First, Rest... &gt;, translotator::integral_constant)</li> <li>value_type (translotator::integral_constant)</li> <li>Vector2LieAlgebra (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>VectorType (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_members/#w","title":"w","text":"<ul> <li>w (translotator::Quaternion)</li> </ul>"},{"location":"translotator/class_members/#x","title":"x","text":"<ul> <li>x (translotator::AxisAngle, translotator::EulerAngle, translotator::Quaternion)</li> </ul>"},{"location":"translotator/class_members/#y","title":"y","text":"<ul> <li>y (translotator::AxisAngle, translotator::EulerAngle, translotator::Quaternion)</li> <li>yaw (translotator::EulerAngle)</li> </ul>"},{"location":"translotator/class_members/#z","title":"z","text":"<ul> <li>z (translotator::AxisAngle, translotator::EulerAngle, translotator::Quaternion)</li> <li>zeros (translotator::DualQuaternion, translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_members/#_1","title":"~","text":"<ul> <li>~DualQuaternion (translotator::DualQuaternion)</li> <li>~SEGroup (translotator::SEGroup)</li> <li>~Lerper (translotator::interpolators::Lerper)</li> <li>~ScLerper (translotator::interpolators::ScLerper)</li> <li>~SlerpLerper (translotator::interpolators::SlerpLerper)</li> <li>~Slerper (translotator::interpolators::Slerper)</li> <li>~SlerperFast (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_functions/","title":"Class Member Functions","text":""},{"location":"translotator/class_member_functions/#a","title":"a","text":"<ul> <li>AxisAngle (translotator::AxisAngle)</li> <li>angle (translotator::AxisAngle)</li> <li>axis (translotator::AxisAngle)</li> <li>axisNormalize (translotator::AxisAngle)</li> <li>axisNormalized (translotator::AxisAngle)</li> <li>axisRotation (translotator::AxisAngle, translotator::EulerAngle, translotator::SOGroup, translotator::UnitQuaternion)</li> <li>actOnVector (translotator::SEGroup)</li> <li>actOnVector2D (translotator::UnitDualQuaternion)</li> <li>actOnVector3D (translotator::UnitDualQuaternion)</li> </ul>"},{"location":"translotator/class_member_functions/#b","title":"b","text":"<ul> <li>block (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_member_functions/#c","title":"c","text":"<ul> <li>castDataType (translotator::AxisAngle, translotator::EulerAngle, translotator::MatrixBase)</li> <li>ComplexNum (translotator::ComplexNum)</li> <li>complexNumDiv (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>complexNumDivEq (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>complexNumMul (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>complexNumMulEq (translotator::ComplexNum, translotator::UnitComplexNum)</li> <li>conjugate (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::UnitDualQuaternion)</li> <li>conjugated (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>conjugateDual (translotator::DualQuaternion)</li> <li>conjugateFull (translotator::DualQuaternion)</li> <li>conjugatePrimary (translotator::DualQuaternion)</li> <li>conjugatedDual (translotator::DualQuaternion)</li> <li>conjugatedFull (translotator::DualQuaternion)</li> <li>conjugatedPrimary (translotator::DualQuaternion)</li> <li>castAxisOrder (translotator::EulerAngle)</li> <li>cast2ComplexNum (translotator::MatrixBase)</li> <li>cast2ComplexNumRef (translotator::MatrixBase)</li> <li>cast2DualNumber (translotator::MatrixBase)</li> <li>cast2DualNumberRef (translotator::MatrixBase)</li> <li>cast2DualQuaternion (translotator::MatrixBase)</li> <li>cast2DualQuaternionRef (translotator::MatrixBase)</li> <li>cast2Matrix (translotator::MatrixBase)</li> <li>cast2MatrixRef (translotator::MatrixBase)</li> <li>cast2Quaternion (translotator::MatrixBase)</li> <li>cast2QuaternionRef (translotator::MatrixBase)</li> <li>cast2SOGroup (translotator::MatrixBase)</li> <li>cast2SOGroupRef (translotator::MatrixBase)</li> <li>cast2SquareMatrix (translotator::MatrixBase)</li> <li>cast2SquareMatrixRef (translotator::MatrixBase)</li> <li>cast2UnitComplexNum (translotator::MatrixBase)</li> <li>cast2UnitComplexNumRef (translotator::MatrixBase)</li> <li>cast2UnitDualQuaternion (translotator::MatrixBase)</li> <li>cast2UnitDualQuaternionRef (translotator::MatrixBase)</li> <li>cast2UnitQuaternion (translotator::MatrixBase)</li> <li>cast2UnitQuaternionRef (translotator::MatrixBase)</li> <li>cast2Vector (translotator::MatrixBase)</li> <li>cast2VectorRef (translotator::MatrixBase)</li> <li>castContainer (translotator::MatrixBase)</li> <li>castContainerRef (translotator::MatrixBase)</li> <li>col (translotator::MatrixBase)</li> <li>colSize (translotator::MatrixBase)</li> <li>copyTo (translotator::MatrixBase)</li> <li>canonicalize (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>canonicalized (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>cross (translotator::Vector)</li> </ul>"},{"location":"translotator/class_member_functions/#d","title":"d","text":"<ul> <li>Du (translotator::DualNumber, translotator::DualQuaternion)</li> <li>DualNumber (translotator::DualNumber)</li> <li>dualNumDiv (translotator::DualNumber)</li> <li>dualNumDivEq (translotator::DualNumber)</li> <li>dualNumMul (translotator::DualNumber)</li> <li>dualNumMulEq (translotator::DualNumber)</li> <li>DualQuaternion (translotator::DualQuaternion)</li> <li>dualQuatDiv (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dualQuatDivEq (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dualQuatMul (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dualQuatMulEq (translotator::DualQuaternion, translotator::UnitDualQuaternion)</li> <li>dw (translotator::DualQuaternion)</li> <li>dx (translotator::DualQuaternion)</li> <li>dy (translotator::DualQuaternion)</li> <li>dz (translotator::DualQuaternion)</li> <li>Data_ (translotator::SOGroup, translotator::SquareMatrix)</li> <li>determinant (translotator::SquareMatrix)</li> <li>dot (translotator::Vector)</li> </ul>"},{"location":"translotator/class_member_functions/#e","title":"e","text":"<ul> <li>EulerAngle (translotator::EulerAngle)</li> <li>eye (translotator::MatrixBase)</li> <li>Exp (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>exp (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_member_functions/#f","title":"f","text":"<ul> <li>fill (translotator::MatrixBase)</li> <li>frobeniusNorm (translotator::MatrixBase)</li> <li>frobeniusNormSquared (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_member_functions/#g","title":"g","text":"<ul> <li>getAngleInOrder (translotator::EulerAngle)</li> <li>getAxisInOrder (translotator::EulerAngle)</li> <li>getData (translotator::MatrixBase)</li> <li>getDiff (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> <li>getEnd (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>getStart (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_functions/#i","title":"i","text":"<ul> <li>identity (translotator::AxisAngle, translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>inverse (translotator::AxisAngle, translotator::ComplexNum, translotator::DualQuaternion, translotator::Quaternion, translotator::SOGroup, translotator::SquareMatrix, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>inversed (translotator::AxisAngle, translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::SquareMatrix, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>Im (translotator::ComplexNum, translotator::Quaternion)</li> <li>initializer_list (translotator::initializer_list)</li> <li>interpolate (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_functions/#l","title":"l","text":"<ul> <li>Lerper (translotator::interpolators::Lerper)</li> <li>LieAlgebra2Vector (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>Log (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>log (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_member_functions/#m","title":"m","text":"<ul> <li>MatrixBase (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_member_functions/#n","title":"n","text":"<ul> <li>norm (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::Vector)</li> <li>normSquared (translotator::ComplexNum, translotator::DualNumber, translotator::Quaternion, translotator::Vector)</li> <li>normalize (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::SOGroup, translotator::UnitDualQuaternion, translotator::Vector)</li> <li>normalized (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion, translotator::Vector)</li> <li>normDualNum (translotator::DualQuaternion)</li> <li>normDualNumSquared (translotator::DualQuaternion)</li> <li>normScalar (translotator::DualQuaternion)</li> <li>normScalarSquared (translotator::DualQuaternion)</li> <li>NaN (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_member_functions/#o","title":"o","text":"<ul> <li>operator* (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator*= (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator/ (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator/= (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::MatrixBase, translotator::Quaternion, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator[] (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::EulerAngle, translotator::Quaternion, translotator::Vector)</li> <li>ones (translotator::MatrixBase)</li> <li>operator() (translotator::MatrixBase, translotator::integral_constant, translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>operator+ (translotator::MatrixBase, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator+= (translotator::MatrixBase)</li> <li>operator- (translotator::MatrixBase, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitDualQuaternion, translotator::UnitQuaternion)</li> <li>operator-= (translotator::MatrixBase)</li> <li>operator= (translotator::MatrixBase)</li> <li>operator value_type (translotator::integral_constant)</li> </ul>"},{"location":"translotator/class_member_functions/#p","title":"p","text":"<ul> <li>pitch (translotator::EulerAngle)</li> <li>print (translotator::MatrixBase, translotator::SEGroup)</li> <li>pow (translotator::SEGroup, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> </ul>"},{"location":"translotator/class_member_functions/#q","title":"q","text":"<ul> <li>Quaternion (translotator::Quaternion)</li> <li>quatNumDiv (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>quatNumDivEq (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>quatNumMul (translotator::Quaternion, translotator::UnitQuaternion)</li> <li>quatNumMulEq (translotator::Quaternion, translotator::UnitQuaternion)</li> </ul>"},{"location":"translotator/class_member_functions/#r","title":"r","text":"<ul> <li>rotateVector2D (translotator::AxisAngle, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>rotateVector3D (translotator::AxisAngle, translotator::UnitQuaternion)</li> <li>Re (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion, translotator::UnitDualQuaternion)</li> <li>rw (translotator::DualQuaternion)</li> <li>rx (translotator::DualQuaternion)</li> <li>ry (translotator::DualQuaternion)</li> <li>rz (translotator::DualQuaternion)</li> <li>roll (translotator::EulerAngle)</li> <li>rotateVec2D (translotator::EulerAngle)</li> <li>rotateVec3D (translotator::EulerAngle)</li> <li>row (translotator::MatrixBase)</li> <li>rowSize (translotator::MatrixBase)</li> <li>rotation (translotator::SEGroup)</li> </ul>"},{"location":"translotator/class_member_functions/#s","title":"s","text":"<ul> <li>sqrt (translotator::DualNumber)</li> <li>setBlock (translotator::MatrixBase)</li> <li>setCol (translotator::MatrixBase)</li> <li>setRow (translotator::MatrixBase)</li> <li>swapCols (translotator::MatrixBase)</li> <li>swapRows (translotator::MatrixBase)</li> <li>SEGroup (translotator::SEGroup)</li> <li>SOGroup (translotator::SOGroup)</li> <li>setDiff (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> <li>setEnd (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>setStart (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>ScLerper (translotator::interpolators::ScLerper)</li> <li>SlerpLerper (translotator::interpolators::SlerpLerper)</li> <li>Slerper (translotator::interpolators::Slerper)</li> <li>SlerperFast (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_functions/#t","title":"t","text":"<ul> <li>toAngleVector (translotator::AxisAngle)</li> <li>toEulerAngle2D (translotator::AxisAngle, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>toEulerAngle3D (translotator::AxisAngle, translotator::UnitQuaternion)</li> <li>toRotMatrix2D (translotator::AxisAngle, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>toRotMatrix3D (translotator::AxisAngle, translotator::UnitQuaternion)</li> <li>toUnitComplexNum (translotator::AxisAngle, translotator::EulerAngle, translotator::SOGroup)</li> <li>toUnitQuaternion (translotator::AxisAngle, translotator::EulerAngle, translotator::SOGroup)</li> <li>toMulMatrix (translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::Quaternion)</li> <li>toRightMulMatrix (translotator::DualQuaternion, translotator::Quaternion)</li> <li>toAxisAngle (translotator::EulerAngle, translotator::SOGroup, translotator::UnitComplexNum, translotator::UnitQuaternion)</li> <li>toSO2Group (translotator::EulerAngle)</li> <li>toSO3Group (translotator::EulerAngle)</li> <li>toVector (translotator::EulerAngle)</li> <li>T (translotator::MatrixBase, translotator::SOGroup)</li> <li>toScalar (translotator::MatrixBase)</li> <li>toSquareMatrix (translotator::SEGroup)</li> <li>translation (translotator::SEGroup)</li> <li>toEulerAngle (translotator::SOGroup)</li> <li>trace (translotator::SquareMatrix)</li> <li>toSE2Group (translotator::UnitDualQuaternion)</li> <li>toSE3Group (translotator::UnitDualQuaternion)</li> <li>toTranslationVec2D (translotator::UnitDualQuaternion)</li> <li>toTranslationVec3D (translotator::UnitDualQuaternion)</li> <li>toCrossMatrix (translotator::Vector)</li> <li>toDiagMatrix (translotator::Vector)</li> </ul>"},{"location":"translotator/class_member_functions/#u","title":"u","text":"<ul> <li>UnitComplexNum (translotator::UnitComplexNum)</li> <li>UnitDualQuaternion (translotator::UnitDualQuaternion)</li> <li>UnitQuaternion (translotator::UnitQuaternion)</li> <li>updateDiff (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> <li>update_theta (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_functions/#v","title":"v","text":"<ul> <li>Vector2LieAlgebra (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_member_functions/#w","title":"w","text":"<ul> <li>w (translotator::Quaternion)</li> </ul>"},{"location":"translotator/class_member_functions/#x","title":"x","text":"<ul> <li>x (translotator::AxisAngle, translotator::EulerAngle, translotator::Quaternion)</li> </ul>"},{"location":"translotator/class_member_functions/#y","title":"y","text":"<ul> <li>y (translotator::AxisAngle, translotator::EulerAngle, translotator::Quaternion)</li> <li>yaw (translotator::EulerAngle)</li> </ul>"},{"location":"translotator/class_member_functions/#z","title":"z","text":"<ul> <li>z (translotator::AxisAngle, translotator::EulerAngle, translotator::Quaternion)</li> <li>zeros (translotator::DualQuaternion, translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_member_functions/#_1","title":"~","text":"<ul> <li>~DualQuaternion (translotator::DualQuaternion)</li> <li>~SEGroup (translotator::SEGroup)</li> <li>~Lerper (translotator::interpolators::Lerper)</li> <li>~ScLerper (translotator::interpolators::ScLerper)</li> <li>~SlerpLerper (translotator::interpolators::SlerpLerper)</li> <li>~Slerper (translotator::interpolators::Slerper)</li> <li>~SlerperFast (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_variables/","title":"Class Member Variables","text":""},{"location":"translotator/class_member_variables/#a","title":"a","text":"<ul> <li>angle_ (translotator::AxisAngle)</li> <li>axis_ (translotator::AxisAngle)</li> <li>angles_ (translotator::EulerAngle)</li> </ul>"},{"location":"translotator/class_member_variables/#c","title":"c","text":"<ul> <li>COLS (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_member_variables/#d","title":"d","text":"<ul> <li>data_ (translotator::MatrixBase)</li> <li>data (translotator::initializer_list)</li> <li>diff_ (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper)</li> </ul>"},{"location":"translotator/class_member_variables/#e","title":"e","text":"<ul> <li>end_ (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_variables/#m","title":"m","text":"<ul> <li>MATRIX_BASE (translotator::MatrixBase)</li> </ul>"},{"location":"translotator/class_member_variables/#o","title":"o","text":"<ul> <li>OBJECT_TYPE (translotator::AxisAngle, translotator::ComplexNum, translotator::DualNumber, translotator::DualQuaternion, translotator::EulerAngle, translotator::Matrix, translotator::Quaternion, translotator::SEGroup, translotator::SOGroup, translotator::SquareMatrix, translotator::UnitDualQuaternion, translotator::UnitQuaternion, translotator::Vector)</li> <li>objType (translotator::UnitComplexNum)</li> </ul>"},{"location":"translotator/class_member_variables/#r","title":"r","text":"<ul> <li>ROWS (translotator::MatrixBase)</li> <li>R_ (translotator::SEGroup)</li> </ul>"},{"location":"translotator/class_member_variables/#s","title":"s","text":"<ul> <li>start_ (translotator::interpolators::Lerper, translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> <li>shortest_path_ (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_variables/#t","title":"t","text":"<ul> <li>t_ (translotator::SEGroup)</li> <li>theta_ (translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_variables/#v","title":"v","text":"<ul> <li>value (translotator::all_same&lt; T &gt;, translotator::all_same&lt; T, First, Rest... &gt;, translotator::integral_constant)</li> </ul>"},{"location":"translotator/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"translotator/class_member_typedefs/#d","title":"d","text":"<ul> <li>DATATYPE (translotator::MatrixBase, translotator::SEGroup)</li> </ul>"},{"location":"translotator/class_member_typedefs/#l","title":"l","text":"<ul> <li>LieAlgebraType (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> <li>LieGroupType (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_member_typedefs/#s","title":"s","text":"<ul> <li>ScalarType (translotator::interpolators::Lerper)</li> </ul>"},{"location":"translotator/class_member_typedefs/#t","title":"t","text":"<ul> <li>type (translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Matrix&lt; N, M, Type &gt;, NewType &gt;, translotator::MatrixBaseInternal::operator_cast_typemapper&lt; Vector&lt; N, Type &gt;, NewType &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS !=OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==1 &amp;&amp;OtherDerived::COLS==1, void &gt; &gt;, translotator::MatrixBaseInternal::operator_mul_typemapper&lt; Derived, OtherDerived, enable_if_t&lt; Derived::ROWS==OtherDerived::COLS &amp;&amp;OtherDerived::COLS !=1, void &gt; &gt;, translotator::conditional_if, translotator::conditional_if&lt; false, T, F &gt;, translotator::enable_if&lt; true, T &gt;, translotator::integral_constant)</li> <li>Type (translotator::interpolators::ScLerper, translotator::interpolators::SlerpLerper, translotator::interpolators::Slerper, translotator::interpolators::SlerperFast)</li> </ul>"},{"location":"translotator/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (translotator::integral_constant)</li> <li>VectorType (translotator::lie::LieOperator&lt; ObjectType::SE_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::SO_GROUP, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_COMPLEX_NUM, Type &gt;, translotator::lie::LieOperator&lt; ObjectType::UNIT_QUATERNION, Type &gt;)</li> </ul>"},{"location":"translotator/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"translotator/namespace_members/","title":"Namespace Members","text":""},{"location":"translotator/namespace_members/#a","title":"a","text":"<ul> <li>AXIS (translotator)</li> <li>AxisAngled (translotator)</li> <li>AxisAnglef (translotator)</li> <li>AxisAngleld (translotator)</li> <li>abs (translotator)</li> <li>acos (translotator)</li> <li>all_same_v (translotator)</li> <li>asin (translotator)</li> <li>atan (translotator)</li> <li>atan2 (translotator)</li> <li>AXIS_AT (translotator::EULER_CONSTEXPR)</li> <li>AXIS_IDX_AT (translotator::EULER_CONSTEXPR)</li> <li>AXIS_TO_IDX (translotator::EULER_CONSTEXPR)</li> </ul>"},{"location":"translotator/namespace_members/#c","title":"c","text":"<ul> <li>ComplexNumd (translotator)</li> <li>ComplexNumf (translotator)</li> <li>ComplexNumld (translotator)</li> <li>ceil (translotator)</li> <li>ceilf (translotator)</li> <li>conditional_if_t (translotator)</li> <li>cos (translotator)</li> <li>cube (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#d","title":"d","text":"<ul> <li>DualNumberd (translotator)</li> <li>DualNumberf (translotator)</li> <li>DualNumberld (translotator)</li> <li>DualQuaterniond (translotator)</li> <li>DualQuaternionf (translotator)</li> <li>DualQuaternionld (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#e","title":"e","text":"<ul> <li>EULER_ORDER (translotator)</li> <li>EulerAngleXYZ (translotator)</li> <li>EulerAngleXYZd (translotator)</li> <li>EulerAngleXYZf (translotator)</li> <li>EulerAngleXYZld (translotator)</li> <li>EulerAngleZYX (translotator)</li> <li>EulerAngleZYXd (translotator)</li> <li>EulerAngleZYXf (translotator)</li> <li>EulerAngleZYXld (translotator)</li> <li>EulerAngled (translotator)</li> <li>EulerAnglef (translotator)</li> <li>EulerAngleld (translotator)</li> <li>enable_if_t (translotator)</li> <li>epsilon (translotator)</li> <li>exp (translotator)</li> <li>exponent_epsilon (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#f","title":"f","text":"<ul> <li>false_type (translotator)</li> <li>floorf (translotator)</li> <li>fmax (translotator)</li> <li>fmin (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#i","title":"i","text":"<ul> <li>is_float_v (translotator)</li> <li>is_matrix_base_v (translotator)</li> <li>is_same_v (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#l","title":"l","text":"<ul> <li>LerpDiff (translotator::interpolators)</li> <li>Lerping (translotator::interpolators)</li> <li>LieOperator_S1 (translotator::lie)</li> <li>LieOperator_S1d (translotator::lie)</li> <li>LieOperator_S1f (translotator::lie)</li> <li>LieOperator_S1ld (translotator::lie)</li> <li>LieOperator_S3 (translotator::lie)</li> <li>LieOperator_S3d (translotator::lie)</li> <li>LieOperator_S3f (translotator::lie)</li> <li>LieOperator_S3ld (translotator::lie)</li> <li>LieOperator_SE (translotator::lie)</li> <li>LieOperator_SEd (translotator::lie)</li> <li>LieOperator_SEf (translotator::lie)</li> <li>LieOperator_SEld (translotator::lie)</li> <li>LieOperator_SO (translotator::lie)</li> <li>LieOperator_SOd (translotator::lie)</li> <li>LieOperator_SOf (translotator::lie)</li> <li>LieOperator_SOld (translotator::lie)</li> </ul>"},{"location":"translotator/namespace_members/#m","title":"m","text":"<ul> <li>Matrixd (translotator)</li> <li>Matrixf (translotator)</li> <li>Matrixld (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#o","title":"o","text":"<ul> <li>ObjectType (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#p","title":"p","text":"<ul> <li>powf (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#q","title":"q","text":"<ul> <li>Quaterniond (translotator)</li> <li>Quaternionf (translotator)</li> <li>Quaternionld (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#r","title":"r","text":"<ul> <li>RotationMatrix2D (translotator)</li> <li>RotationMatrix2Dd (translotator)</li> <li>RotationMatrix2Df (translotator)</li> <li>RotationMatrix2Dld (translotator)</li> <li>RotationMatrix3D (translotator)</li> <li>RotationMatrix3Dd (translotator)</li> <li>RotationMatrix3Df (translotator)</li> <li>RotationMatrix3Dld (translotator)</li> <li>RotationMatrixd (translotator)</li> <li>RotationMatrixf (translotator)</li> <li>RotationMatrixld (translotator)</li> <li>roundf (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#s","title":"s","text":"<ul> <li>S1d (translotator)</li> <li>S1f (translotator)</li> <li>S1ld (translotator)</li> <li>S3d (translotator)</li> <li>S3f (translotator)</li> <li>S3ld (translotator)</li> <li>SE2Group (translotator)</li> <li>SE2Groupd (translotator)</li> <li>SE2Groupf (translotator)</li> <li>SE2Groupld (translotator)</li> <li>SE3Group (translotator)</li> <li>SE3Groupd (translotator)</li> <li>SE3Groupf (translotator)</li> <li>SE3Groupld (translotator)</li> <li>SEGroupd (translotator)</li> <li>SEGroupf (translotator)</li> <li>SEGroupld (translotator)</li> <li>SO2Group (translotator)</li> <li>SO2Groupd (translotator)</li> <li>SO2Groupf (translotator)</li> <li>SO2Groupld (translotator)</li> <li>SO3Group (translotator)</li> <li>SO3Groupd (translotator)</li> <li>SO3Groupf (translotator)</li> <li>SO3Groupld (translotator)</li> <li>SOGroupd (translotator)</li> <li>SOGroupf (translotator)</li> <li>SOGroupld (translotator)</li> <li>SquareMatrixd (translotator)</li> <li>SquareMatrixf (translotator)</li> <li>SquareMatrixld (translotator)</li> <li>sin (translotator)</li> <li>sqrt (translotator)</li> <li>square (translotator)</li> <li>ScLerpDiff (translotator::interpolators)</li> <li>ScLerping (translotator::interpolators)</li> <li>SlerpDiff (translotator::interpolators)</li> <li>SlerpLerpDiff (translotator::interpolators)</li> <li>SlerpLerping (translotator::interpolators)</li> <li>Slerping (translotator::interpolators)</li> </ul>"},{"location":"translotator/namespace_members/#t","title":"t","text":"<ul> <li>tan (translotator)</li> <li>true_type (translotator)</li> <li>truncf (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#u","title":"u","text":"<ul> <li>UnitComplexNumd (translotator)</li> <li>UnitComplexNumf (translotator)</li> <li>UnitComplexNumld (translotator)</li> <li>UnitDualQuaterniond (translotator)</li> <li>UnitDualQuaternionf (translotator)</li> <li>UnitDualQuaternionld (translotator)</li> <li>UnitQuaterniond (translotator)</li> <li>UnitQuaternionf (translotator)</li> <li>UnitQuaternionld (translotator)</li> </ul>"},{"location":"translotator/namespace_members/#v","title":"v","text":"<ul> <li>Vectord (translotator)</li> <li>Vectorf (translotator)</li> <li>Vectorld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"translotator/namespace_member_functions/#a","title":"a","text":"<ul> <li>abs (translotator)</li> <li>acos (translotator)</li> <li>asin (translotator)</li> <li>atan (translotator)</li> <li>atan2 (translotator)</li> <li>AXIS_AT (translotator::EULER_CONSTEXPR)</li> <li>AXIS_IDX_AT (translotator::EULER_CONSTEXPR)</li> <li>AXIS_TO_IDX (translotator::EULER_CONSTEXPR)</li> </ul>"},{"location":"translotator/namespace_member_functions/#c","title":"c","text":"<ul> <li>ceil (translotator)</li> <li>ceilf (translotator)</li> <li>cos (translotator)</li> <li>cube (translotator)</li> </ul>"},{"location":"translotator/namespace_member_functions/#e","title":"e","text":"<ul> <li>epsilon (translotator)</li> <li>exp (translotator)</li> <li>exponent_epsilon (translotator)</li> </ul>"},{"location":"translotator/namespace_member_functions/#f","title":"f","text":"<ul> <li>floorf (translotator)</li> <li>fmax (translotator)</li> <li>fmin (translotator)</li> </ul>"},{"location":"translotator/namespace_member_functions/#l","title":"l","text":"<ul> <li>LerpDiff (translotator::interpolators)</li> <li>Lerping (translotator::interpolators)</li> </ul>"},{"location":"translotator/namespace_member_functions/#p","title":"p","text":"<ul> <li>powf (translotator)</li> </ul>"},{"location":"translotator/namespace_member_functions/#r","title":"r","text":"<ul> <li>roundf (translotator)</li> </ul>"},{"location":"translotator/namespace_member_functions/#s","title":"s","text":"<ul> <li>sin (translotator)</li> <li>sqrt (translotator)</li> <li>square (translotator)</li> <li>ScLerpDiff (translotator::interpolators)</li> <li>ScLerping (translotator::interpolators)</li> <li>SlerpDiff (translotator::interpolators)</li> <li>SlerpLerpDiff (translotator::interpolators)</li> <li>SlerpLerping (translotator::interpolators)</li> <li>Slerping (translotator::interpolators)</li> </ul>"},{"location":"translotator/namespace_member_functions/#t","title":"t","text":"<ul> <li>tan (translotator)</li> <li>truncf (translotator)</li> </ul>"},{"location":"translotator/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"translotator/namespace_member_variables/#a","title":"a","text":"<ul> <li>all_same_v (translotator)</li> </ul>"},{"location":"translotator/namespace_member_variables/#i","title":"i","text":"<ul> <li>is_float_v (translotator)</li> <li>is_matrix_base_v (translotator)</li> <li>is_same_v (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"translotator/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>AxisAngled (translotator)</li> <li>AxisAnglef (translotator)</li> <li>AxisAngleld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>ComplexNumd (translotator)</li> <li>ComplexNumf (translotator)</li> <li>ComplexNumld (translotator)</li> <li>conditional_if_t (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>DualNumberd (translotator)</li> <li>DualNumberf (translotator)</li> <li>DualNumberld (translotator)</li> <li>DualQuaterniond (translotator)</li> <li>DualQuaternionf (translotator)</li> <li>DualQuaternionld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#e","title":"e","text":"<ul> <li>EulerAngleXYZ (translotator)</li> <li>EulerAngleXYZd (translotator)</li> <li>EulerAngleXYZf (translotator)</li> <li>EulerAngleXYZld (translotator)</li> <li>EulerAngleZYX (translotator)</li> <li>EulerAngleZYXd (translotator)</li> <li>EulerAngleZYXf (translotator)</li> <li>EulerAngleZYXld (translotator)</li> <li>EulerAngled (translotator)</li> <li>EulerAnglef (translotator)</li> <li>EulerAngleld (translotator)</li> <li>enable_if_t (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>false_type (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#l","title":"l","text":"<ul> <li>LieOperator_S1 (translotator::lie)</li> <li>LieOperator_S1d (translotator::lie)</li> <li>LieOperator_S1f (translotator::lie)</li> <li>LieOperator_S1ld (translotator::lie)</li> <li>LieOperator_S3 (translotator::lie)</li> <li>LieOperator_S3d (translotator::lie)</li> <li>LieOperator_S3f (translotator::lie)</li> <li>LieOperator_S3ld (translotator::lie)</li> <li>LieOperator_SE (translotator::lie)</li> <li>LieOperator_SEd (translotator::lie)</li> <li>LieOperator_SEf (translotator::lie)</li> <li>LieOperator_SEld (translotator::lie)</li> <li>LieOperator_SO (translotator::lie)</li> <li>LieOperator_SOd (translotator::lie)</li> <li>LieOperator_SOf (translotator::lie)</li> <li>LieOperator_SOld (translotator::lie)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>Matrixd (translotator)</li> <li>Matrixf (translotator)</li> <li>Matrixld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#q","title":"q","text":"<ul> <li>Quaterniond (translotator)</li> <li>Quaternionf (translotator)</li> <li>Quaternionld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>RotationMatrix2D (translotator)</li> <li>RotationMatrix2Dd (translotator)</li> <li>RotationMatrix2Df (translotator)</li> <li>RotationMatrix2Dld (translotator)</li> <li>RotationMatrix3D (translotator)</li> <li>RotationMatrix3Dd (translotator)</li> <li>RotationMatrix3Df (translotator)</li> <li>RotationMatrix3Dld (translotator)</li> <li>RotationMatrixd (translotator)</li> <li>RotationMatrixf (translotator)</li> <li>RotationMatrixld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>S1d (translotator)</li> <li>S1f (translotator)</li> <li>S1ld (translotator)</li> <li>S3d (translotator)</li> <li>S3f (translotator)</li> <li>S3ld (translotator)</li> <li>SE2Group (translotator)</li> <li>SE2Groupd (translotator)</li> <li>SE2Groupf (translotator)</li> <li>SE2Groupld (translotator)</li> <li>SE3Group (translotator)</li> <li>SE3Groupd (translotator)</li> <li>SE3Groupf (translotator)</li> <li>SE3Groupld (translotator)</li> <li>SEGroupd (translotator)</li> <li>SEGroupf (translotator)</li> <li>SEGroupld (translotator)</li> <li>SO2Group (translotator)</li> <li>SO2Groupd (translotator)</li> <li>SO2Groupf (translotator)</li> <li>SO2Groupld (translotator)</li> <li>SO3Group (translotator)</li> <li>SO3Groupd (translotator)</li> <li>SO3Groupf (translotator)</li> <li>SO3Groupld (translotator)</li> <li>SOGroupd (translotator)</li> <li>SOGroupf (translotator)</li> <li>SOGroupld (translotator)</li> <li>SquareMatrixd (translotator)</li> <li>SquareMatrixf (translotator)</li> <li>SquareMatrixld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>true_type (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#u","title":"u","text":"<ul> <li>UnitComplexNumd (translotator)</li> <li>UnitComplexNumf (translotator)</li> <li>UnitComplexNumld (translotator)</li> <li>UnitDualQuaterniond (translotator)</li> <li>UnitDualQuaternionf (translotator)</li> <li>UnitDualQuaternionld (translotator)</li> <li>UnitQuaterniond (translotator)</li> <li>UnitQuaternionf (translotator)</li> <li>UnitQuaternionld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>Vectord (translotator)</li> <li>Vectorf (translotator)</li> <li>Vectorld (translotator)</li> </ul>"},{"location":"translotator/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"translotator/namespace_member_enums/#a","title":"a","text":"<ul> <li>AXIS (translotator)</li> </ul>"},{"location":"translotator/namespace_member_enums/#e","title":"e","text":"<ul> <li>EULER_ORDER (translotator)</li> </ul>"},{"location":"translotator/namespace_member_enums/#o","title":"o","text":"<ul> <li>ObjectType (translotator)</li> </ul>"},{"location":"translotator/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"translotator/macros/","title":"Macros","text":""},{"location":"translotator/macros/#c","title":"c","text":"<ul> <li>CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_128_EPSILON (config.hpp)</li> <li>CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32 (config.hpp)</li> <li>CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_32_EPSILON (config.hpp)</li> <li>CONFIG_TRANSLOTATOR_DEFAULT_FLOATING_POINT_PRECISION_64_EPSILON (config.hpp)</li> </ul>"},{"location":"translotator/macros/#t","title":"t","text":"<ul> <li>TRANSLOTATOR_DEFAULT_FLOATING_POINT_TYPE (default_type.hpp)</li> <li>TRANSLOTATOR_MAJOR_VERSION (version.hpp)</li> <li>TRANSLOTATOR_MINOR_VERSION (version.hpp)</li> <li>TRANSLOTATOR_PATCH_VERSION (version.hpp)</li> <li>TRANSLOTATOR_TWEAK_VERSION (version.hpp)</li> <li>TRANSLOTATOR_VERSION (version.hpp)</li> </ul>"},{"location":"translotator/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"translotator/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}